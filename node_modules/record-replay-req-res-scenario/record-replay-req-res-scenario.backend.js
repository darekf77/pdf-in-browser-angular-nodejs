"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
//#region imports
var _ = require("lodash");
var path = require("path");
var tnp_helpers_1 = require("tnp-helpers");
var url_1 = require("url");
var tnp_config_1 = require("tnp-config");
var moment = require("moment");
var ng_talkback_1 = require("ng-talkback");
var glob = require("glob");
var scenario_backend_1 = require("./scenario.backend");
var chalk_1 = require("chalk");
var inquirer = require("inquirer");
//#endregion
var RecordReplayReqResScenario = /** @class */ (function () {
    function RecordReplayReqResScenario(cwd) {
        if (cwd === void 0) { cwd = process.cwd(); }
        this.cwd = cwd;
        //#region consts
        /**
         * by pinging to http://localhost:5544/path/to/something
         * you are actually recording request from
         * by pinging to http://< host for recording >/path/to/something
         */
        this.DEFAULT_TALKBACK_PROXY_SERVER_PORT = 5544;
        var pathToScenarios = path.join(cwd, tnp_config_1.config.folder.scenarios);
        var pathToScenariosTemp = path.join(cwd, tnp_config_1.config.folder.tmpScenarios);
        if (!tnp_helpers_1.Helpers.exists(pathToScenarios)) {
            tnp_helpers_1.Helpers.createSymLink(pathToScenariosTemp, pathToScenarios, { continueWhenExistedFolderDoesntExists: true });
        }
    }
    RecordReplayReqResScenario.Instance = function (cwd) {
        if (cwd === void 0) { cwd = process.cwd(); }
        if (!RecordReplayReqResScenario._instances[cwd]) {
            RecordReplayReqResScenario._instances[cwd] = new RecordReplayReqResScenario(cwd);
        }
        return RecordReplayReqResScenario._instances[cwd];
    };
    //#endregion
    //#region resolve recoard args
    RecordReplayReqResScenario.prototype.resolveArgsRecord = function (serverHostOrPort) {
        var results = [];
        var configMeta = ((_.isObject(serverHostOrPort) && !_.isArray(serverHostOrPort))
            ? serverHostOrPort : void 0);
        var scenarioName = '';
        var talkbackPorts = [this.DEFAULT_TALKBACK_PROXY_SERVER_PORT];
        if (configMeta) {
            //#region by config
            scenarioName = configMeta.scenarioName;
            _.keys(configMeta)
                .filter(function (key) { return _.isObject(configMeta[key]); })
                .forEach(function (name, i) {
                var url = tnp_helpers_1.Helpers.urlParse(configMeta[name].host);
                results.push({
                    record: {
                        name: name,
                        url: url
                    },
                    talkbackProxyPort: Number(configMeta[name].talkbackProxyPort) + i
                });
            });
            //#endregion
        }
        else {
            //#region by command line argument
            var _a = tnp_helpers_1.Helpers.cliTool.argsFromBegin(serverHostOrPort, function (a) { return tnp_helpers_1.Helpers.urlParse(a); }), commandString = _a.commandString, resolved = _a.resolved;
            scenarioName = commandString;
            var options = tnp_helpers_1.Helpers.cliTool.argsFrom(scenarioName);
            scenarioName = tnp_helpers_1.Helpers.cliTool.cleanCommand(scenarioName, options);
            if (_.isArray(options.port)) {
                talkbackPorts = options.port;
            }
            else if (!isNaN(Number(options.port))) {
                talkbackPorts = [Number(options.port)];
            }
            var hostName_1 = _.isString(options.hostName) ? [options.hostName]
                : (_.isArray(options.hostName) ? options.hostName : []);
            if (talkbackPorts.length === 0) {
                tnp_helpers_1.Helpers.error("[rec-scenario-rep-rec] Incorrect configuration of ports:\n          recordHosts = " + resolved.map(function (c) { return tnp_helpers_1.Helpers.urlParse(c); }).join(', ') + "\n          talkback ports = " + talkbackPorts.join(', ') + "\n\n          ", false, true);
            }
            if (talkbackPorts.length < resolved.length) {
                var lastN_1 = talkbackPorts[talkbackPorts.length - 1];
                _.times((resolved.length - talkbackPorts.length), function (i) { return talkbackPorts.push(lastN_1 + (i + 1)); });
            }
            resolved.forEach(function (recordHost, i) {
                results.push({
                    record: {
                        name: hostName_1[i] ? hostName_1[i] : '',
                        url: recordHost
                    },
                    talkbackProxyPort: talkbackPorts[i]
                });
            });
            //#endregion
        }
        return { args: results, scenarioName: scenarioName };
    };
    //#endregion
    //#region command from config
    RecordReplayReqResScenario.prototype.recordAsWorker = function (config, cwd) {
        if (cwd === void 0) { cwd = process.cwd(); }
        var hosts = Object
            .keys(config)
            .filter(function (hostName) { return _.isObject(config[hostName]); })
            .map(function (hostName) {
            var v = config[hostName];
            return v.host.origin;
        });
        var portName = Object
            .keys(config)
            .filter(function (hostName) { return _.isObject(config[hostName]); })
            .map(function (hostName) {
            var v = config[hostName];
            return "--port " + v.talkbackProxyPort + " --hostName " + hostName;
        });
        var command = "record-replay-req-res-scenario record " + hosts.join(' ') + " '" + config.scenarioName + "' " + portName.join(' ');
        tnp_helpers_1.Helpers.run(command, { cwd: cwd }).async();
    };
    //#endregion
    //#region record
    /**
     *  rest-scenario-rep-rec record http://localhost:4444 Recording localhost data
     *  rest-scenario-rep-rec record http://192.168.10.22:4444 Test scenario
     *  rest-scenario-rep-rec record 4444 local setup test
     *  rest-scenario-rep-rec record 4444 5555 http://192.168.12.3 "my super scenario"
     *  rest-scenario-rep-rec record 4444 5555 http://192.168.12.3 192.158.32.3 'my super scenario --port 6767'
    *                                <port or host for record   >  <scenario name    > < talkbback server ports for proxy >
     *  rest-scenario-rep-rec record 4444 5555  http://my.api.com   'my super scenario --port 6767 --port 7777 --port 8888'
     *  ins.record( { portOrHost: http://192.129.23.12; name: 'localApiProxy'  }, 'super scenario')
     */
    RecordReplayReqResScenario.prototype.record = function (serverHostOrPort, debug) {
        if (debug === void 0) { debug = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var currentDate = new Date();
                        var _a = _this.resolveArgsRecord(serverHostOrPort), args = _a.args, scenarioName = _a.scenarioName;
                        //#region prepare main scenario folder
                        var description = scenarioName;
                        if (!_.isString(scenarioName) || scenarioName.trim() === '') {
                            scenarioName = "new-scenario-" + _.kebabCase(moment(currentDate).format('MMMM Do YYYY, h:mm:ss a'));
                            ;
                            description = _.startCase(scenarioName);
                        }
                        var scenarioNameKebabKase = _.kebabCase(scenarioName);
                        var scenariosFolder = path.join(_this.cwd, tnp_config_1.config.folder.tmpScenarios);
                        var scenarioKebabPath = path.join(scenariosFolder, scenarioNameKebabKase);
                        var packageJsonFroScenario = path.join(scenarioKebabPath, tnp_config_1.config.file.package_json);
                        if (!tnp_helpers_1.Helpers.exists(scenariosFolder)) {
                            tnp_helpers_1.Helpers.mkdirp(scenariosFolder);
                        }
                        tnp_helpers_1.Helpers.removeFolderIfExists(scenarioKebabPath);
                        //#endregion
                        //#region write package.json
                        tnp_helpers_1.Helpers.writeFile(packageJsonFroScenario, {
                            name: scenarioNameKebabKase,
                            description: description,
                            version: '0.0.0',
                            creationDate: currentDate.toDateString(),
                            scripts: {
                                start: 'firedev serve',
                            },
                            tnp: {
                                type: 'scenario',
                            },
                        });
                        //#endregion
                        args.forEach(function (recData) {
                            tnp_helpers_1.Helpers.log("RECORD FROM: " + recData.record.url.href);
                            var scenarioPath = path.join(_this.cwd, tnp_config_1.config.folder.tmpScenarios, scenarioNameKebabKase, (_.kebabCase(recData.record.url.href)).toString() + "__" + _.camelCase(recData.record.name));
                            tnp_helpers_1.Helpers.remove(scenarioPath);
                            var talkbackHost = recData.record.url.origin;
                            debug && tnp_helpers_1.Helpers.info("Talkback host: " + talkbackHost);
                            var server = ng_talkback_1.talkback({
                                host: talkbackHost,
                                record: ng_talkback_1.RecordMode.NEW,
                                port: recData.talkbackProxyPort,
                                path: scenarioPath,
                                silent: true,
                            });
                            server.start(function () {
                                var _a;
                                tnp_helpers_1.Helpers.info("\"Talkback Started\" on port " + recData.talkbackProxyPort + " "
                                    + ("( click for test " + chalk_1.default.bold(((_a = recData.record) === null || _a === void 0 ? void 0 : _a.name) ? recData.record.name : '') + " ")
                                    + ("http://localhost:" + recData.talkbackProxyPort + "/ng-talkback-test  )  => proxy to " + recData.record.url.href));
                                resolve(void 0);
                            });
                        });
                    })];
            });
        });
    };
    Object.defineProperty(RecordReplayReqResScenario.prototype, "allScenarios", {
        //#endregion
        //#region all scenaroios
        get: function () {
            return glob.sync(path.join(this.cwd, tnp_config_1.config.folder.tmpScenarios) + "/*")
                .filter(function (f) { return !!tnp_helpers_1.Project.From(f); })
                .map(function (f) { return scenario_backend_1.Scenario.From(f); })
                .filter(function (f) { return !!f; });
        },
        enumerable: true,
        configurable: true
    });
    //#endregion
    //#region select scenario
    RecordReplayReqResScenario.prototype.selectScenario = function (goBackButtonOnList) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var mainMessage, choices, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mainMessage = "Select scenario from list:";
                        choices = scenario_backend_1.Scenario.allCurrent.map(function (c) {
                            return { name: "\"" + c.description + "\"", value: c };
                        });
                        if (goBackButtonOnList) {
                            choices.push({ name: '<= Go back', value: void 0 });
                        }
                        return [4 /*yield*/, inquirer.prompt({
                                type: 'list',
                                name: 'value',
                                message: mainMessage,
                                choices: choices
                            })];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, res.value];
                }
            });
        });
    };
    //#endregion
    //#region resolve replay args
    RecordReplayReqResScenario.prototype.resolveReplayData = function (nameOrPathOrDescription, showListIfNotMatch, goBackButtonOnList) {
        if (showListIfNotMatch === void 0) { showListIfNotMatch = false; }
        if (goBackButtonOnList === void 0) { goBackButtonOnList = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var returnValue, configMeta, scenario, options, _a, resolved, commandString, scenarios, list, _b, matches, results, hostName, portsOrUrlsForReplayServer_1, params, maxPort_1, selectedScenario;
            var _this = this;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        returnValue = { scenarios: [], params: void 0 };
                        if (_.isObject(nameOrPathOrDescription) && !_.isArray(nameOrPathOrDescription)) {
                            configMeta = nameOrPathOrDescription;
                            scenario = scenario_backend_1.Scenario.From(configMeta.scenarioPath);
                            if (!scenario) {
                                tnp_helpers_1.Helpers.error("[rest-scenario...] Scenario not found in \"" + configMeta.scenarioPath + "\"", false, true);
                            }
                            returnValue.scenarios = [scenario];
                            returnValue.params = _.pickBy(configMeta, _.isObject);
                            //#endregion
                        }
                        else {
                            //#region from command line
                            nameOrPathOrDescription = (_.isArray(nameOrPathOrDescription)
                                ? nameOrPathOrDescription.join(' ') : nameOrPathOrDescription);
                            options = tnp_helpers_1.Helpers.cliTool.argsFrom(nameOrPathOrDescription);
                            nameOrPathOrDescription = tnp_helpers_1.Helpers.cliTool.cleanCommand(nameOrPathOrDescription, options);
                            _a = tnp_helpers_1.Helpers.cliTool
                                .argsFromBegin(nameOrPathOrDescription, function (possiblePathToScenario) {
                                var scenarioFromPath = (path.isAbsolute(possiblePathToScenario || '') &&
                                    tnp_helpers_1.Helpers.exists(possiblePathToScenario))
                                    ? possiblePathToScenario
                                    : path.join(_this.cwd, tnp_config_1.config.folder.tmpScenarios, (possiblePathToScenario || '').trim());
                                return scenario_backend_1.Scenario.From(scenarioFromPath);
                            }), resolved = _a.resolved, commandString = _a.commandString;
                            nameOrPathOrDescription = commandString;
                            scenarios = resolved;
                            if (scenarios.length === 0 && commandString.trim() !== '') {
                                list = this.allScenarios;
                                _b = tnp_helpers_1.Helpers
                                    .arrays
                                    .fuzzy(nameOrPathOrDescription, list, function (m) { return m.description; }), matches = _b.matches, results = _b.results;
                                scenarios = scenarios.concat(results);
                            }
                            hostName = _.isString(options.hostName) ? [options.hostName]
                                : (_.isArray(options.hostName) ? options.hostName : []);
                            portsOrUrlsForReplayServer_1 = (_.isString(options.port) ? [tnp_helpers_1.Helpers.urlParse(options.port)]
                                : (_.isArray(options.port) ? options.port.map(function (p) { return tnp_helpers_1.Helpers.urlParse(p); })
                                    : [tnp_helpers_1.Helpers.urlParse(this.DEFAULT_TALKBACK_PROXY_SERVER_PORT)])).filter(function (u) { return u instanceof url_1.URL; });
                            if (portsOrUrlsForReplayServer_1.length === 0) {
                                tnp_helpers_1.Helpers.error("Please provide correct number or ports and hostnames\n          host names = " + hostName.map(function (c) { return tnp_helpers_1.Helpers.urlParse(c); }).join(', ') + "\n          talkback ports = " + portsOrUrlsForReplayServer_1.join(', ') + "\n          ", false, true);
                            }
                            params = portsOrUrlsForReplayServer_1;
                            if (hostName.length > 0) {
                                if (hostName.length > portsOrUrlsForReplayServer_1.length) {
                                    maxPort_1 = _.maxBy(portsOrUrlsForReplayServer_1, function (p) { return Number(p.port); });
                                    _.times(hostName.length - portsOrUrlsForReplayServer_1.length, function (n) {
                                        portsOrUrlsForReplayServer_1.push(tnp_helpers_1.Helpers.urlParse(Number(maxPort_1.port) + (n + 1)));
                                    });
                                }
                                params = hostName.reduce(function (prev, name, i) {
                                    var _a;
                                    return _.merge(prev, (_a = {}, _a[name] = portsOrUrlsForReplayServer_1[i], _a));
                                }, {});
                            }
                            returnValue.params = params;
                            returnValue.scenarios = scenarios;
                            //#endregion
                        }
                        if (!(returnValue.scenarios.length === 0)) return [3 /*break*/, 2];
                        if (!showListIfNotMatch) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.selectScenario(goBackButtonOnList)];
                    case 1:
                        selectedScenario = _c.sent();
                        returnValue.scenarios.push(selectedScenario);
                        _c.label = 2;
                    case 2: 
                    //#endregion
                    return [2 /*return*/, returnValue];
                }
            });
        });
    };
    //#endregion
    //#region replay
    RecordReplayReqResScenario.prototype.resolveScenariosData = function (nameOrPathOrDescription, showListIfNotMatch, goBackButtonOnList) {
        if (showListIfNotMatch === void 0) { showListIfNotMatch = false; }
        if (goBackButtonOnList === void 0) { goBackButtonOnList = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, scenarios, params;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.resolveReplayData(nameOrPathOrDescription, showListIfNotMatch, goBackButtonOnList)];
                    case 1:
                        _a = _b.sent(), scenarios = _a.scenarios, params = _a.params;
                        if (scenarios.length === 0) {
                            tnp_helpers_1.Helpers.error("[record - replay - req - res - scenario]"
                                + ("Not able to find scenario by name or path \"" + nameOrPathOrDescription + "\""), false, true);
                        }
                        // const tmpScenarioInfo = (s: Scenario) => {
                        //   const paramsTmpls = _.isArray(params) ? params.map(p => ` replay on ${p}`).join(',')
                        //     : _.keys(params).reduce((a, b) => {
                        //       return `${a}\n\t${chalk.bold(b)}:${params[b].href}`
                        //     }, '')
                        //   return `> ${chalk.bold(s.basename)} "${s.description}"` +
                        //     paramsTmpls;
                        // };
                        // Helpers.info(`
                        // (${chalk.bold(scenarios.length.toString())}) scenario(s) to replay: `
                        //   + `${scenarios.map(s => tmpScenarioInfo(s)).join('\n')}`
                        // );
                        return [2 /*return*/, { scenario: _.first(scenarios), scenarios: scenarios, params: params }];
                }
            });
        });
    };
    //#endregion
    //#region singleton
    RecordReplayReqResScenario._instances = {};
    return RecordReplayReqResScenario;
}());
exports.RecordReplayReqResScenario = RecordReplayReqResScenario;
//# sourceMappingURL=record-replay-req-res-scenario.backend.js.map