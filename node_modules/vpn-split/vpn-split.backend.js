"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
//#region imports
var tnp_core_1 = require("tnp-core");
var express = require("express");
var httpProxy = require("http-proxy");
var tnp_helpers_1 = require("tnp-helpers");
var tnp_config_1 = require("tnp-config");
var hostile_backend_1 = require("./hostile.backend");
var models_backend_1 = require("./models.backend");
var axios_1 = require("axios");
//#endregion
//#region consts
var GENERATED = '#GENERATED_BY_NAVI_CLI#';
var WINDOWS = process.platform === 'win32';
var EOL = WINDOWS
    ? '\r\n'
    : '\n';
var SERVERS_PATH = '/$$$$servers$$$$';
var HOST_FILE_PATH = WINDOWS
    ? 'C:/Windows/System32/drivers/etc/hosts'
    : '/etc/hosts';
var from = models_backend_1.HostForServer.From;
var defaultHosts = {
    'localhost alias': from({
        ipOrDomain: '127.0.0.1',
        aliases: 'localhost',
        isDefault: true,
    }),
    'broadcasthost': from({
        ipOrDomain: '255.255.255.255',
        aliases: 'broadcasthost',
        isDefault: true,
    }),
    'localhost alias ipv6': from({
        ipOrDomain: '::1',
        aliases: 'localhost',
        isDefault: true,
    }),
};
//#endregion
var VpnSplit = /** @class */ (function () {
    function VpnSplit(hosts, cwd) {
        this.hosts = hosts;
        this.cwd = cwd;
        this.__hostile = new hostile_backend_1.Hostile();
    }
    Object.defineProperty(VpnSplit.prototype, "hostsArr", {
        //#region getters
        get: function () {
            var hosts = this.hosts;
            return tnp_core_1._.keys(hosts).map(function (hostName) {
                var v = hosts[hostName];
                v.name = hostName;
                return v;
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VpnSplit.prototype, "hostsArrWithoutDefault", {
        get: function () {
            return this.hostsArr.filter(function (f) { return !f.isDefault; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VpnSplit.prototype, "serveKeyName", {
        get: function () { return 'tmp-' + tnp_config_1.config.file.server_key; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VpnSplit.prototype, "serveKeyPath", {
        get: function () { return tnp_core_1.path.join(this.cwd, this.serveKeyName); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VpnSplit.prototype, "serveCertName", {
        get: function () { return 'tmp-' + tnp_config_1.config.file.server_cert; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VpnSplit.prototype, "serveCertPath", {
        get: function () { return tnp_core_1.path.join(this.cwd, this.serveCertName); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VpnSplit.prototype, "serveCertChainName", {
        get: function () { return 'tmp-' + tnp_config_1.config.file.server_chain_cert; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VpnSplit.prototype, "serveCertChainPath", {
        get: function () { return tnp_core_1.path.join(this.cwd, this.serveCertChainName); },
        enumerable: true,
        configurable: true
    });
    VpnSplit.Instance = function (_a) {
        var _b = _a === void 0 ? {} : _a, additionalDefaultHosts = _b.additionalDefaultHosts, _c = _b.cwd, cwd = _c === void 0 ? process.cwd() : _c;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, tnp_core_1.isElevated()];
                    case 1:
                        if (!(_d.sent())) {
                            tnp_helpers_1.Helpers.error("[vpn-split] Please run this program as sudo (or admin on windows)", false, true);
                        }
                        if (!VpnSplit._instances[cwd]) {
                            VpnSplit._instances[cwd] = new VpnSplit(tnp_core_1._.merge(defaultHosts, additionalDefaultHosts), cwd);
                        }
                        return [2 /*return*/, VpnSplit._instances[cwd]];
                }
            });
        });
    };
    //#endregion
    //#region privaet methods
    //#region create certificate
    VpnSplit.prototype.createCertificateIfNotExists = function () {
        if (!tnp_helpers_1.Helpers.exists(this.serveKeyPath) || !tnp_helpers_1.Helpers.exists(this.serveCertPath)) {
            tnp_helpers_1.Helpers.info("[vpn-split] Generating new certification for localhost... please follow instructions..");
            var commandGen = "openssl req -nodes -new -x509 -keyout " + this.serveKeyName + " -out " + this.serveCertName;
            tnp_helpers_1.Helpers.run(commandGen, { cwd: this.cwd, output: true }).sync();
            // Helpers.run(`openssl verify -verbose -x509_strict -CAfile ${this.serveKeyName} ${this.serveCertChainName}`,
            //   { cwd: this.cwd, output: true }).sync()
        }
    };
    //#endregion
    //#region proxy passthrough
    //#region start server passthrough
    VpnSplit.prototype.serverPassthrough = function (port) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var isHttps, app, proxy, currentLocalIps, h;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        isHttps = (port === 443);
                        process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
                        app = express();
                        proxy = httpProxy.createProxyServer({});
                        currentLocalIps = tslib_1.__spreadArrays([
                            'localhost',
                            '127.0.0.1'
                        ], tnp_helpers_1.Helpers.allLocalIpAddresses().map(function (a) { return a.hostname; }));
                        app.use(function (req, res, next) {
                            if (currentLocalIps.includes(req.hostname)) {
                                if (req.method === 'GET' && req.originalUrl === SERVERS_PATH) {
                                    res.send(JSON.stringify(_this.hostsArrWithoutDefault.map(function (h) {
                                        return { ip: h.ip, alias: tnp_helpers_1.Helpers.arrays.from(h.aliases).join(' ') };
                                    })));
                                }
                                else {
                                    res.send("hello from here... server passthrough\n          protocol: " + req.protocol + " <br>\n          hostname: " + req.hostname + " <br>\n          originalUrl: " + req.originalUrl + " <br>\n          ");
                                }
                                next();
                            }
                            else {
                                var target = req.protocol + "://" + req.hostname;
                                proxy.web(req, res, {
                                    target: target,
                                    ssl: {
                                        key: tnp_core_1.fse.readFileSync(_this.serveKeyPath),
                                        cert: tnp_core_1.fse.readFileSync(_this.serveCertPath)
                                    },
                                    secure: false
                                }, next);
                            }
                        });
                        h = isHttps ? (new tnp_core_1.https.Server({
                            key: tnp_core_1.fse.readFileSync(this.serveKeyPath),
                            cert: tnp_core_1.fse.readFileSync(this.serveCertPath)
                        }, app)) : (new tnp_core_1.http.Server(app));
                        return [4 /*yield*/, tnp_helpers_1.Helpers.killProcessByPort(port)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, (new Promise(function (resolve, reject) {
                                h.listen(port, function () {
                                    console.log("Passthrough " + (isHttps ? 'SECURE' : '') + " server"
                                        + (" listening on por: " + port + "\n        env: " + app.settings.env + "\n          "));
                                });
                                resolve(void 0);
                            }))];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    //#endregion
    //#region start client passthrough
    VpnSplit.prototype.clientPassthrough = function (port, vpnServerTarget) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var isHttps, app, proxy, h;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        isHttps = (port === 443);
                        // if (isHttps) {
                        process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
                        app = express();
                        proxy = httpProxy.createProxyServer({});
                        app.use(function (req, res, next) {
                            if (req.hostname === 'localhost') {
                                res.send("hello from here... client passthrough\n      protocol: " + req.protocol + " <br>\n      hostname: " + req.hostname + " <br>\n      originalUrl: " + req.originalUrl + " <br>\n      ");
                                next();
                            }
                            else {
                                var target = req.protocol + "://" + vpnServerTarget.hostname;
                                proxy.web(req, res, {
                                    target: target,
                                    ssl: {
                                        key: tnp_core_1.fse.readFileSync(_this.serveKeyPath),
                                        cert: tnp_core_1.fse.readFileSync(_this.serveCertPath)
                                    },
                                    secure: false
                                }, next);
                            }
                        });
                        h = isHttps ? (new tnp_core_1.https.Server({
                            key: tnp_core_1.fse.readFileSync(this.serveKeyPath),
                            cert: tnp_core_1.fse.readFileSync(this.serveCertPath)
                        }, app)) : (new tnp_core_1.http.Server(app));
                        return [4 /*yield*/, tnp_helpers_1.Helpers.killProcessByPort(port)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, (new Promise(function (resolve, reject) {
                                h.listen(port, function () {
                                    console.log("Passthrough " + (isHttps ? 'SECURE' : '') + " client"
                                        + (" listening on port: " + port + "\n        env: " + app.settings.env + "\n          "));
                                });
                                resolve(void 0);
                            }))];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    //#endregion
    //#endregion
    //#region prevent bad target for client
    VpnSplit.prototype.preventBadTargetForClient = function (vpnServerTarget) {
        if (!vpnServerTarget) {
            var currentLocalIp = tnp_helpers_1.Helpers.localIpAddress();
            tnp_helpers_1.Helpers.error("[vpn-server] Please provide (correct?) target server\n      Example:\n      vpn-server " + currentLocalIp + " # or whatever ip of your machine with vpn\n\n      # your local ip is: " + currentLocalIp + "\n\n      your args:\n      " + process.argv.slice(2).join(', ') + "\n      ", false, true);
        }
    };
    //#endregion
    //#endregion
    //#region server
    VpnSplit.prototype.server = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.createCertificateIfNotExists();
                        //#region modify /etc/host 80,443 to redirect to proper server domain/ip
                        saveHosts(this.hosts);
                        //#endregion
                        return [4 /*yield*/, this.serverPassthrough(22)];
                    case 1:
                        //#endregion
                        _a.sent();
                        return [4 /*yield*/, this.serverPassthrough(80)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.serverPassthrough(443)];
                    case 3:
                        _a.sent();
                        tnp_helpers_1.Helpers.info("Activated.");
                        return [2 /*return*/];
                }
            });
        });
    };
    //#endregion
    //#region client
    VpnSplit.prototype.getRemoteHosts = function (vpnServerTarget) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var url, response, err_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        url = "http://" + vpnServerTarget.hostname + SERVERS_PATH;
                        return [4 /*yield*/, axios_1.default({
                                url: url,
                                method: 'GET',
                            })];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, response.data];
                    case 2:
                        err_1 = _a.sent();
                        tnp_helpers_1.Helpers.error("Remote server: " + vpnServerTarget.hostname + " maybe inactive..."
                            + " nothing to passthrought ", true, true);
                        return [2 /*return*/, []];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    VpnSplit.prototype.client = function (vpnServerTarget) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var hosts, originalHosts, cloned;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.preventBadTargetForClient(vpnServerTarget);
                        this.createCertificateIfNotExists();
                        return [4 /*yield*/, this.getRemoteHosts(vpnServerTarget)];
                    case 1:
                        hosts = _a.sent();
                        originalHosts = this.hostsArr;
                        cloned = tnp_core_1._.values(tslib_1.__spreadArrays(originalHosts, hosts.map(function (h) { return models_backend_1.HostForServer.From({
                            aliases: h.alias,
                            ipOrDomain: h.ip
                        }, "external host " + h.alias + " " + h.ip); })).map(function (c) {
                            var copy = c.clone();
                            if (!copy.isDefault) {
                                copy.ip = "127.0.0.1";
                            }
                            return copy;
                        }).reduce(function (prev, curr) {
                            var _a;
                            return tnp_core_1._.merge(prev, (_a = {},
                                _a[curr.aliases.join(' ')] = curr,
                                _a));
                        }, {}));
                        saveHosts(cloned);
                        //#endregion
                        return [4 /*yield*/, this.clientPassthrough(22, vpnServerTarget)];
                    case 2:
                        //#endregion
                        _a.sent();
                        return [4 /*yield*/, this.clientPassthrough(80, vpnServerTarget)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, this.clientPassthrough(443, vpnServerTarget)];
                    case 4:
                        _a.sent();
                        tnp_helpers_1.Helpers.info("Client activated");
                        return [2 /*return*/];
                }
            });
        });
    };
    VpnSplit.HOST_FILE_PATH = HOST_FILE_PATH;
    //#endregion
    //#region singleton
    VpnSplit._instances = {};
    return VpnSplit;
}());
exports.VpnSplit = VpnSplit;
//#region helpers
//#region gen msg
var genMsg = "\n################################################\n## This file is generated by coomand navi vpn ##\n################################################\n".trim() + EOL;
//#endregion
//#region save hosts
function saveHosts(hosts) {
    if (tnp_core_1._.isArray(hosts)) {
        hosts = hosts.reduce(function (prev, curr) {
            var _a;
            return tnp_core_1._.merge(prev, (_a = {},
                _a[curr.name] = curr,
                _a));
        }, {});
    }
    var toSave = parseHost(hosts);
    // Object.values(hosts).forEach( c => c )
    // console.log(toSave)
    tnp_helpers_1.Helpers.writeFile(HOST_FILE_PATH, toSave);
}
//#endregion
//#region parse hosts
function parseHost(hosts) {
    tnp_core_1._.keys(hosts).forEach(function (hostName) {
        var v = hosts[hostName];
        v.name = hostName;
    });
    return genMsg + EOL + tnp_core_1._.keys(hosts).map(function (hostName) {
        var v = hosts[hostName];
        return "" + (v.disabled ? '#' : '') + v.ipOrDomain + " " + v.aliases.join(' ')
            + (" # " + v.name + " " + GENERATED);
    }).join(EOL) + EOL + EOL + genMsg;
}
//#endregion
//#endregion
//# sourceMappingURL=vpn-split.backend.js.map