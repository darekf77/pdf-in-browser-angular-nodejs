"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
//#region imports
var _ = require("lodash");
var tnp_helpers_1 = require("tnp-helpers");
var entites_1 = require("../entites");
var typescript_class_helpers_1 = require("typescript-class-helpers");
//#endregion
var PortsSet = /** @class */ (function () {
    function PortsSet(ports, saveCallback) {
        var _this = this;
        this.saveCallback = function (portsArgs) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        portsArgs = generateAllInstaces(portsArgs);
                        portsArgs = _.sortBy(portsArgs, function (o) { return o.sortIndex; });
                        portsArgs = makeSmaller(portsArgs);
                        portsArgs = _.sortBy(portsArgs, function (o) { return o.sortIndex; });
                        return [4 /*yield*/, tnp_helpers_1.Helpers.runSyncOrAsync(saveCallback, portsArgs)];
                    case 1:
                        portsArgs = _a.sent();
                        this.ports = portsArgs.map(function (c) { return entites_1.PortInstance.clone(c); });
                        return [2 /*return*/];
                }
            });
        }); };
        this.ports = ports.map(function (c) { return entites_1.PortInstance.clone(c); });
    }
    PortsSet_1 = PortsSet;
    Object.defineProperty(PortsSet.prototype, "numOfFreePortsAvailable", {
        //#region private getters
        get: function () {
            return PortsSet_1.count.freePorts(this.ports);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PortsSet.prototype, "numOfTakenPortsAvailable", {
        get: function () {
            return this.numOfAllPortsAvailable - this.numOfFreePortsAvailable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PortsSet.prototype, "numOfAllPortsAvailable", {
        get: function () {
            return PortsSet_1.count.allPorts(this.ports);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PortsSet, "count", {
        //#endregion
        //#region count ports
        get: function () {
            return {
                freePorts: function (ports) {
                    var sum = 0;
                    ports.forEach(function (ins) {
                        if (ins.isFree) {
                            sum += ins.size;
                        }
                    });
                    return sum;
                },
                allPorts: function (ports) {
                    var sum = 0;
                    ports.forEach(function (ins) {
                        sum += ins.size;
                    });
                    return sum;
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    //#endregion
    //#region check if enought ports for project or service
    PortsSet.prototype.checkIfFreePortAmountEnouth = function (projectLocationOrSystemService, howManyPorts, ports) {
        if (_.isUndefined(howManyPorts) && _.isString(projectLocationOrSystemService)) {
            var proj = tnp_helpers_1.Project.From(projectLocationOrSystemService);
            howManyPorts = 1 + (proj.isWorkspace ? proj.children.length : 0);
        }
        return PortsSet_1.count.freePorts(ports) >= howManyPorts;
    };
    //#endregion
    //#region reserve free ports for
    /**
     * @deprecated
     * // TODO refactor this
     */
    PortsSet.prototype.reserveFreePortsFor = function (projectLocationOrSystemService, howManyPorts) {
        if (howManyPorts === void 0) { howManyPorts = 1; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._reserveFreePortsFor(projectLocationOrSystemService, howManyPorts, this.ports)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PortsSet.prototype._reserveFreePortsFor = function (projectLocationOrSystemService, howManyPorts, ports, allInstaces) {
        if (howManyPorts === void 0) { howManyPorts = 1; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var saveInstancesToDb, isProject, project, countReserved, childrenSuccessReserverPortsArr, children, index, child, childrenSuccessReserverPorts;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        saveInstancesToDb = false;
                        if (!this.checkIfFreePortAmountEnouth(projectLocationOrSystemService, howManyPorts, ports)) {
                            return [2 /*return*/, false];
                        }
                        isProject = (projectLocationOrSystemService &&
                            _.isString(projectLocationOrSystemService.location));
                        if (isProject && howManyPorts > 1) {
                            throw "One project can only have on port";
                        }
                        if (isProject) {
                            project = projectLocationOrSystemService;
                            if (project.isWorkspace || project.isStandaloneProject) {
                                saveInstancesToDb = true;
                            }
                        }
                        if (_.isUndefined(allInstaces)) {
                            allInstaces = generateAllInstaces(ports);
                        }
                        countReserved = 0;
                        allInstaces.some(function (ins) {
                            if (countReserved < howManyPorts) {
                                if (ins.isFree) {
                                    ins.reservedFor = projectLocationOrSystemService;
                                    countReserved++;
                                }
                                return false;
                            }
                            return true;
                        });
                        if (!(isProject && project.children.length > 0)) return [3 /*break*/, 5];
                        childrenSuccessReserverPortsArr = [];
                        children = project.children;
                        index = 0;
                        _a.label = 1;
                    case 1:
                        if (!(index < children.length)) return [3 /*break*/, 4];
                        child = children[index];
                        return [4 /*yield*/, this._reserveFreePortsFor(child, undefined, ports, allInstaces)];
                    case 2:
                        if (_a.sent()) {
                            childrenSuccessReserverPortsArr.push(child);
                        }
                        _a.label = 3;
                    case 3:
                        index++;
                        return [3 /*break*/, 1];
                    case 4:
                        childrenSuccessReserverPorts = (childrenSuccessReserverPortsArr.length === children.length);
                        if (!childrenSuccessReserverPorts) {
                            return [2 /*return*/, false];
                        }
                        _a.label = 5;
                    case 5:
                        if (!saveInstancesToDb) return [3 /*break*/, 7];
                        return [4 /*yield*/, tnp_helpers_1.Helpers.runSyncOrAsync(this.saveCallback, allInstaces)];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7: return [2 /*return*/, true];
                }
            });
        });
    };
    //#endregion
    //#region register service on free port
    /**
     * Get port of just registerd service
     */
    PortsSet.prototype.registerOnFreePort = function (service, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var itWasRegisterd, actionWhenAssignedPort, killAlreadyRegisterd, allInstaces, portInstacnce;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!options) {
                            options = {};
                        }
                        ;
                        if (_.isUndefined(options.killAlreadyRegisterd)) {
                            options.killAlreadyRegisterd = false;
                        }
                        itWasRegisterd = false;
                        actionWhenAssignedPort = options.actionWhenAssignedPort, killAlreadyRegisterd = options.killAlreadyRegisterd;
                        allInstaces = generateAllInstaces(this.ports);
                        portInstacnce = allInstaces.find(function (p) { var _a; return ((_a = p.reservedFor) === null || _a === void 0 ? void 0 : _a.name) === service.name; });
                        if (portInstacnce) {
                            itWasRegisterd = true;
                        }
                        else {
                            portInstacnce = allInstaces.find(function (p) { return p.isFree; });
                            if (!portInstacnce) {
                                tnp_helpers_1.Helpers.error("There is not free port to register service:\n        name: " + (service === null || service === void 0 ? void 0 : service.name) + "\n        description: " + (service === null || service === void 0 ? void 0 : service.description) + "\n        ", false, true);
                            }
                        }
                        portInstacnce.reservedFor = service;
                        return [4 /*yield*/, tnp_helpers_1.Helpers.runSyncOrAsync(this.saveCallback, allInstaces)];
                    case 1:
                        _a.sent();
                        if (!killAlreadyRegisterd) return [3 /*break*/, 3];
                        tnp_helpers_1.Helpers.info("[tnp-db][registerOnFreePort] killing running services - port: " + portInstacnce.id);
                        return [4 /*yield*/, tnp_helpers_1.Helpers.killProcessByPort(Number(portInstacnce.id))];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [4 /*yield*/, tnp_helpers_1.Helpers.runSyncOrAsync(actionWhenAssignedPort, itWasRegisterd, portInstacnce.id)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/, portInstacnce.id];
                }
            });
        });
    };
    //#endregion
    //#region get reserved port instance for service or project
    PortsSet.prototype.getReserverFor = function (projectLocationOrSevice) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.ports.filter(function (f) { return _.isEqual(f.reservedFor, projectLocationOrSevice); })];
            });
        });
    };
    PortsSet.prototype.getPortOf = function (service) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var a;
            return tslib_1.__generator(this, function (_a) {
                a = this.ports.find(function (f) { return f.reservedFor && f.reservedFor.name === (service === null || service === void 0 ? void 0 : service.name); });
                if (a && _.isNumber(a.id)) {
                    return [2 /*return*/, a.id];
                }
                return [2 /*return*/, void 0];
            });
        });
    };
    //#endregion
    //#region update port instance
    PortsSet.prototype.update = function (port) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var ins;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        ins = this.ports.find(function (f) { return f.isEqual(port); });
                        if (!ins) {
                            return [2 /*return*/, false];
                        }
                        _.merge(ins, port);
                        return [4 /*yield*/, tnp_helpers_1.Helpers.runSyncOrAsync(this.saveCallback, this.ports)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, true];
                }
            });
        });
    };
    //#endregion
    //#region remove port instance
    PortsSet.prototype.remove = function (port) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.ports = this.ports.filter(function (f) { return !f.isEqual(port); });
                        return [4 /*yield*/, tnp_helpers_1.Helpers.runSyncOrAsync(this.saveCallback, this.ports)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    PortsSet.prototype.makeFree = function (port) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.ports.forEach(function (f) {
                            if (f.isEqual(port)) {
                                f.reservedFor = void 0;
                            }
                        });
                        return [4 /*yield*/, tnp_helpers_1.Helpers.runSyncOrAsync(this.saveCallback, this.ports)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    // public async killService(service: Models.system.SystemService) {
    //   const a = this.ports.find(s => s.reservedFor && (s.reservedFor.name === service?.name));
    //   if (!a) {
    //     Helpers.warn(`[killService] Not able to kill service by name "${service?.name}" `)
    //   }
    //   await this.makeFreeAndKill(a);
    // }
    PortsSet.prototype.makeFreeAndKill = function (portIns) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var j, port;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        j = 0;
                        _a.label = 1;
                    case 1:
                        if (!(j < portIns.array.length)) return [3 /*break*/, 4];
                        port = portIns.array[j];
                        return [4 /*yield*/, tnp_helpers_1.Helpers.killProcessByPort(port)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        j++;
                        return [3 /*break*/, 1];
                    case 4: return [4 /*yield*/, this.makeFree(portIns)];
                    case 5:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    //#endregion
    //#region add port instance
    PortsSet.prototype.add = function (port) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.ports.filter(function (p) { return p.includes(port); }).length > 0) {
                            return [2 /*return*/, false];
                        }
                        this.ports.push(port);
                        return [4 /*yield*/, tnp_helpers_1.Helpers.runSyncOrAsync(this.saveCallback, this.ports)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, true];
                }
            });
        });
    };
    var PortsSet_1;
    PortsSet = PortsSet_1 = tslib_1.__decorate([
        typescript_class_helpers_1.CLASS.NAME('PortsSet'),
        tslib_1.__metadata("design:paramtypes", [Array, Function])
    ], PortsSet);
    return PortsSet;
}());
exports.PortsSet = PortsSet;
function makeSmaller(allInstacesSingle) {
    var ports = [];
    var currentProjectLocationOrSystemService = undefined;
    var curretnPortIns;
    allInstacesSingle.forEach(function (ins) {
        if (!_.isEqual(ins.reservedFor, currentProjectLocationOrSystemService)) {
            currentProjectLocationOrSystemService = ins.reservedFor;
            curretnPortIns = new entites_1.PortInstance(ins.id, currentProjectLocationOrSystemService);
            ports.push(curretnPortIns);
        }
        else {
            if (!curretnPortIns) {
                curretnPortIns = new entites_1.PortInstance(ins.id, currentProjectLocationOrSystemService);
                ports.push(curretnPortIns);
            }
            else {
                var anotherInsAdded = curretnPortIns.addIdIfPossible(ins.id);
                if (!anotherInsAdded) {
                    curretnPortIns = new entites_1.PortInstance(ins.id, currentProjectLocationOrSystemService);
                    ports.push(curretnPortIns);
                }
            }
        }
    });
    return ports;
}
function generateAllInstaces(ports) {
    var allInstaces = [];
    ports.forEach(function (ins) {
        if (ins.size === 1) {
            allInstaces.push(ins);
        }
        else {
            if (_.isArray(ins.id)) {
                ins.id.forEach(function (idelem) {
                    allInstaces.push(new entites_1.PortInstance(idelem, ins.reservedFor));
                });
            }
            else {
                var rangeID = ins.id;
                allInstaces = allInstaces.concat(rangeID.array.map(function (idelem) {
                    return new entites_1.PortInstance(idelem, ins.reservedFor);
                }));
            }
        }
    });
    return allInstaces;
}
//# sourceMappingURL=ports-set.backend.js.map