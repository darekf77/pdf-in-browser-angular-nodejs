"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
//#region @backend
var chalk_1 = require("chalk");
var path = require("path");
var wrapper_db_backend_1 = require("./wrapper-db.backend");
//#endregion
var tnp_config_1 = require("tnp-config");
var _ = require("lodash");
var tnp_helpers_1 = require("tnp-helpers");
var typescript_class_helpers_1 = require("typescript-class-helpers");
var BuildOptions = /** @class */ (function () {
    function BuildOptions() {
        var _this = this;
        this.toString = function () {
            return JSON.stringify(_.mergeWith({}, _.omit(_this, BuildOptions_1.PropsToOmmitWhenStringify)), null, 4);
        };
    }
    BuildOptions_1 = BuildOptions;
    BuildOptions.getMainOptions = function (args) {
        //#region @backendFunc
        var ars = (tnp_config_1.config.argsReplacementsBuild || {});
        var shortValuesArgs = Object.keys(ars);
        var toCheckArgs = Object.values(ars);
        var toCheckArgsSimplfied = Object.values(ars).map(function (c) { return tnp_helpers_1.Helpers.cliTool.simplifiedCmd(c); });
        var ind = args.findIndex(function (p, i) {
            var ends = ((tnp_config_1.config.coreBuildFrameworkNames || []).filter(function (c) {
                return p.endsWith("/" + c) || p == c;
            }).length > 0);
            var nextArgExisted = !!args[i + 1];
            if (nextArgExisted && shortValuesArgs.includes(args[i + 1])) {
                args[i + 1] = ars[args[i + 1]];
            }
            if (nextArgExisted && toCheckArgsSimplfied.includes(tnp_helpers_1.Helpers.cliTool.simplifiedCmd(args[i + 1]))) {
                args[i + 1] = toCheckArgs.find(function (c) {
                    return tnp_helpers_1.Helpers.cliTool.simplifiedCmd(c) === tnp_helpers_1.Helpers.cliTool.simplifiedCmd(args[i + 1]);
                });
            }
            return ends &&
                nextArgExisted &&
                (toCheckArgs
                    .map(function (c) { return tnp_helpers_1.Helpers.cliTool.simplifiedCmd(c); })
                    .includes(tnp_helpers_1.Helpers.cliTool.simplifiedCmd(args[i + 1])));
        });
        var prod = false, watch = false, uglify = false, obscure = false, nodts = false, outDir = 'dist', appBuild = false, staticBuild = false;
        if (ind >= 0) {
            var cmd = _.kebabCase(args[ind + 1]).split('-').slice(1);
            for (var index = 0; index < cmd.length; index++) {
                var cmdPart = cmd[index];
                if (cmdPart === 'static') {
                    staticBuild = true;
                }
                if (cmdPart === 'lib') {
                    outDir = 'dist';
                }
                if (cmdPart === 'dist' || cmdPart === 'bundle') {
                    outDir = cmdPart;
                }
                if (cmdPart === 'app') {
                    appBuild = true;
                }
                if (cmdPart === 'prod') {
                    prod = true;
                }
                if (cmdPart === 'watch') {
                    watch = true;
                }
                if (cmdPart === 'uglify') {
                    uglify = true;
                }
                if (cmdPart === 'obscure') {
                    obscure = true;
                }
                if (cmdPart === 'nodts') {
                    nodts = true;
                }
            }
            return { prod: prod, watch: watch, outDir: outDir, appBuild: appBuild, staticBuild: staticBuild, uglify: uglify, obscure: obscure, nodts: nodts };
        }
        //#endregion
    };
    BuildOptions.from = function (argsString, projectCurrent, mainOptions, reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var split, optionsToMerge, argsObj, index, argPath, project, _a, result;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        tnp_helpers_1.Helpers.log("[buildoptions][from] " + reason);
                        split = argsString.split(' ');
                        optionsToMerge = (!!mainOptions ? mainOptions : this.getMainOptions(split));
                        // console.log('optionsToMerge', optionsToMerge)
                        if (!optionsToMerge) {
                            tnp_helpers_1.Helpers.log("[build-options] NO options to merge");
                            return [2 /*return*/];
                        }
                        argsObj = require('minimist')(split);
                        Object.keys(argsObj).forEach(function (key) {
                            if (_.isString(key) && (key.length === 1) && _.isBoolean(argsObj[key])) {
                                tnp_helpers_1.Helpers.warn("[build-options] Removing argument: \"" + key + "=" + argsObj[key]);
                                delete argsObj[key];
                            }
                        });
                        // console.log('argsObj', argsObj)
                        argsObj.watch = optionsToMerge.watch;
                        argsObj.prod = optionsToMerge.prod;
                        argsObj.uglify = optionsToMerge.uglify;
                        argsObj.obscure = optionsToMerge.obscure;
                        argsObj.nodts = optionsToMerge.nodts;
                        argsObj.outDir = optionsToMerge.outDir;
                        argsObj.appBuild = optionsToMerge.appBuild;
                        argsObj.copyto = (_.isUndefined(argsObj.copyto) && _.isArray(optionsToMerge.copyto)) ?
                            optionsToMerge.copyto : argsObj.copyto;
                        argsObj.args = argsString;
                        if (!_.isNil(argsObj.forClient)) {
                            if (_.isString(argsObj.forClient)) {
                                argsObj.forClient = [argsObj.forClient];
                            }
                            if (!!projectCurrent && projectCurrent.isWorkspaceChildProject) {
                                argsObj.forClient = argsObj.forClient.map(function (projectParentChildName) {
                                    if (_.isObject(projectParentChildName)) {
                                        projectParentChildName = projectParentChildName.name;
                                    }
                                    // console.log('projectParentChildName', projectParentChildName)
                                    var proj = projectCurrent.parent.children.find(function (c) {
                                        return c.name === projectParentChildName || c.location === projectParentChildName;
                                    });
                                    if (!proj) {
                                        tnp_helpers_1.Helpers.log("\n            projectCurrent.parent.children: " + projectCurrent.parent.children.map(function (c) { return c.name; }) + "\n            ");
                                        tnp_helpers_1.Helpers.error(chalk_1.default.bold('--forClient argument') + " : Cannot find module " + chalk_1.default.bold(projectParentChildName) + " "
                                            + ("in workspace " + projectCurrent.parent.genericName));
                                    }
                                    // Helpers.info(`(${projectCurrent.name}) Build only for client ${chalk.bold(projectParentChildName)}`)
                                    return proj;
                                });
                            }
                        }
                        if (!_.isArray(argsObj.forClient)) {
                            argsObj.forClient = [];
                        }
                        argsObj.forClient = tnp_helpers_1.Helpers.arrays.uniqArray(argsObj.forClient, 'location');
                        if (!!_.isNil(argsObj.copyto)) return [3 /*break*/, 7];
                        if (_.isString(argsObj.copyto)) {
                            argsObj.copyto = [argsObj.copyto];
                        }
                        index = 0;
                        _b.label = 1;
                    case 1:
                        if (!(index < argsObj.copyto.length)) return [3 /*break*/, 6];
                        argPath = argsObj.copyto[index];
                        if (!_.isString(argPath && argPath.location)) return [3 /*break*/, 2];
                        _a = argPath;
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, getProjectFromArgPath(argPath, projectCurrent)];
                    case 3:
                        _a = _b.sent();
                        _b.label = 4;
                    case 4:
                        project = (_a);
                        if (!project) {
                            tnp_helpers_1.Helpers.error("[build-options] Incorrect \"copyto\" values. Path doesn't contain " + tnp_config_1.config.frameworkName + " type project: " + argPath, false, true);
                        }
                        argsObj.copyto[index] = project;
                        _b.label = 5;
                    case 5:
                        index++;
                        return [3 /*break*/, 1];
                    case 6:
                        argsObj.copyto = argsObj.copyto.filter(function (p) { return !!p; });
                        _b.label = 7;
                    case 7:
                        if (!_.isArray(argsObj.copyto)) {
                            argsObj.copyto = [];
                        }
                        argsObj.copyto = tnp_helpers_1.Helpers.arrays.uniqArray(argsObj.copyto, 'location');
                        argsObj.onlyWatchNoBuild = !!argsObj.onlyWatchNoBuild;
                        argsObj.genOnlyClientCode = !!argsObj.genOnlyClientCode;
                        result = _.merge(new BuildOptions_1(), argsObj);
                        // console.log(result)
                        return [2 /*return*/, result];
                }
            });
        });
    };
    BuildOptions.exportToCMD = function (buildOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, appBuild, outDir, _b, watch, copyto, baseHref, forClient, _c, prod, _d, uglify, _e, obscure, _f, nodts, _g, staticBuild, _h, skipCopyToSelection, genOnlyClientCode, onlyBackend, onlyWatchNoBuild, args, argsFromCopyto, index, argPath, project, _j, argsFromForClient, index, argPath, project, _k;
            return tslib_1.__generator(this, function (_l) {
                switch (_l.label) {
                    case 0:
                        //#region @backendFunc
                        if (!buildOptions) {
                            return [2 /*return*/, ''];
                        }
                        _a = buildOptions.appBuild, appBuild = _a === void 0 ? false : _a, outDir = buildOptions.outDir, _b = buildOptions.watch, watch = _b === void 0 ? false : _b, copyto = buildOptions.copyto, baseHref = buildOptions.baseHref, forClient = buildOptions.forClient, _c = buildOptions.prod, prod = _c === void 0 ? false : _c, _d = buildOptions.uglify, uglify = _d === void 0 ? false : _d, _e = buildOptions.obscure, obscure = _e === void 0 ? false : _e, _f = buildOptions.nodts, nodts = _f === void 0 ? false : _f, _g = buildOptions.staticBuild, staticBuild = _g === void 0 ? false : _g, _h = buildOptions.skipCopyToSelection, skipCopyToSelection = _h === void 0 ? false : _h, genOnlyClientCode = buildOptions.genOnlyClientCode, onlyBackend = buildOptions.onlyBackend, onlyWatchNoBuild = buildOptions.onlyWatchNoBuild;
                        args = [];
                        if (!_.isArray(copyto)) return [3 /*break*/, 7];
                        argsFromCopyto = [];
                        index = 0;
                        _l.label = 1;
                    case 1:
                        if (!(index < copyto.length)) return [3 /*break*/, 6];
                        argPath = copyto[index];
                        if (!_.isString(argPath && argPath.location)) return [3 /*break*/, 2];
                        _j = argPath;
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, getProjectFromArgPath(argPath)];
                    case 3:
                        _j = _l.sent();
                        _l.label = 4;
                    case 4:
                        project = (_j);
                        argsFromCopyto.push("--copyto " + project.location);
                        _l.label = 5;
                    case 5:
                        index++;
                        return [3 /*break*/, 1];
                    case 6:
                        args = args.concat(argsFromCopyto);
                        _l.label = 7;
                    case 7:
                        if (!_.isArray(forClient)) return [3 /*break*/, 14];
                        argsFromForClient = [];
                        index = 0;
                        _l.label = 8;
                    case 8:
                        if (!(index < forClient.length)) return [3 /*break*/, 13];
                        argPath = forClient[index];
                        if (!_.isString(argPath && argPath.location)) return [3 /*break*/, 9];
                        _k = argPath;
                        return [3 /*break*/, 11];
                    case 9: return [4 /*yield*/, getProjectFromArgPath(argPath)];
                    case 10:
                        _k = _l.sent();
                        _l.label = 11;
                    case 11:
                        project = (_k);
                        argsFromForClient.push("--forClient " + project.location);
                        _l.label = 12;
                    case 12:
                        index++;
                        return [3 /*break*/, 8];
                    case 13:
                        args = args.concat(argsFromForClient);
                        _l.label = 14;
                    case 14:
                        if (genOnlyClientCode) {
                            args.push('--genOnlyClientCode');
                        }
                        if (onlyBackend) {
                            args.push('--onlyBackend');
                        }
                        if (onlyWatchNoBuild) {
                            args.push('--onlyWatchNoBuild');
                        }
                        if (baseHref && baseHref.trim() !== '') {
                            args.push("--baseHref " + baseHref);
                        }
                        if (skipCopyToSelection) {
                            "--skipCopyToSelection true";
                        }
                        return [2 /*return*/, tnp_config_1.config.frameworkName + " " +
                                ("" + (staticBuild ? 'static:' : '')) +
                                "build:" +
                                ("" + (appBuild ? 'app' : outDir)) +
                                ("" + (prod ? ':prod' : '')) +
                                ("" + (watch ? ':watch' : '')) +
                                ("" + (uglify ? ':uglify' : '')) +
                                ("" + (obscure ? ':obscure' : '')) +
                                ("" + (nodts ? ':nodts' : '')) +
                                (" " + args.join(' '))
                            //#endregion
                        ];
                }
            });
        });
    };
    var BuildOptions_1;
    BuildOptions.PropsToOmmitWhenStringify = ['copyto', 'forClient'];
    BuildOptions = BuildOptions_1 = tslib_1.__decorate([
        typescript_class_helpers_1.CLASS.NAME('BuildOptions')
    ], BuildOptions);
    return BuildOptions;
}());
exports.BuildOptions = BuildOptions;
//#region @backend
function getProjectFromArgPath(argPath, projectCurrent) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var project, dbProjectsToCheck;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (_.isObject(argPath)) {
                        argPath = argPath.location;
                    }
                    if (_.isString(argPath) && !path.isAbsolute(argPath) && projectCurrent) {
                        project = tnp_helpers_1.Project.From(path.join(projectCurrent.location, argPath));
                    }
                    if (!project) {
                        project = tnp_helpers_1.Project.nearestTo(argPath);
                    }
                    if (!!project) return [3 /*break*/, 3];
                    return [4 /*yield*/, wrapper_db_backend_1.TnpDB.Instance()];
                case 1: return [4 /*yield*/, (_a.sent()).getProjects()];
                case 2:
                    dbProjectsToCheck = (_a.sent()).map(function (p) { return p.project; });
                    project = dbProjectsToCheck.find(function (p) { return p.genericName === argPath; });
                    if (!project) {
                        project = dbProjectsToCheck.find(function (p) { return p.name === argPath; });
                    }
                    _a.label = 3;
                case 3: return [2 /*return*/, project];
            }
        });
    });
}
//#endregion
//# sourceMappingURL=build-options.js.map