"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var _ = require("lodash");
var path = require("path");
var mocha_1 = require("mocha");
var chai_1 = require("chai");
var tnp_helpers_1 = require("tnp-helpers");
var tnp_models_1 = require("tnp-models");
var port_instance_1 = require("../entites/port-instance");
var ports_set_backend_1 = require("../controllers/ports-set.backend");
mocha_1.describe('Ports set tests', function () {
    var baseline = tnp_helpers_1.Project.From(path.join(tnp_helpers_1.Project.Tnp.location, '../firedev-projects', 'container', 'baseline'));
    var tnp = tnp_helpers_1.Project.Tnp;
    mocha_1.it('should call save after each add', function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var saveCallCounter, s;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        saveCallCounter = 0;
                        s = new ports_set_backend_1.PortsSet([], function (a) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            return tslib_1.__generator(this, function (_a) {
                                saveCallCounter++;
                                return [2 /*return*/, a];
                            });
                        }); });
                        return [4 /*yield*/, s.add(new port_instance_1.PortInstance(tnp_models_1.Models.other.Range.from(3000).to(4000)))];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, s.add(new port_instance_1.PortInstance(80, new tnp_models_1.Models.system.SystemService('http')))];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, s.add(new port_instance_1.PortInstance([21, 22], new tnp_models_1.Models.system.SystemService('System communication')))];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, s.add(new port_instance_1.PortInstance(tnp_models_1.Models.other.Range.from(4100).to(4110), baseline))];
                    case 4:
                        _a.sent();
                        chai_1.expect(saveCallCounter).to.be.eq(4);
                        return [2 /*return*/];
                }
            });
        });
    });
    mocha_1.it('should calculate,remove,add,update correcly', function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var s, twoThousandsFreePors;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        s = new ports_set_backend_1.PortsSet([
                            new port_instance_1.PortInstance([2000, 2001])
                        ], function (a) { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                            return [2 /*return*/, a];
                        }); }); });
                        chai_1.expect(s.numOfFreePortsAvailable).to.be.eq(2);
                        return [4 /*yield*/, s.update(new port_instance_1.PortInstance([2000, 2001], new tnp_models_1.Models.system.SystemService('test')))];
                    case 1:
                        _a.sent();
                        chai_1.expect(s.numOfFreePortsAvailable).to.be.eq(0);
                        twoThousandsFreePors = new port_instance_1.PortInstance(tnp_models_1.Models.other.Range.from(3000).to(5000));
                        return [4 /*yield*/, s.add(twoThousandsFreePors)];
                    case 2:
                        _a.sent();
                        chai_1.expect(s.numOfFreePortsAvailable).to.be.eq(2000);
                        chai_1.expect(s.numOfAllPortsAvailable).to.be.eq(2002);
                        return [4 /*yield*/, s.remove(twoThousandsFreePors)];
                    case 3:
                        _a.sent();
                        chai_1.expect(s.numOfFreePortsAvailable).to.be.eq(0);
                        chai_1.expect(s.numOfAllPortsAvailable).to.be.eq(2);
                        return [2 /*return*/];
                }
            });
        });
    });
    mocha_1.it('should return project ports', function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var baselinePorts, s, _a, _b, _c, _d, _e, _f;
            var _this = this;
            return tslib_1.__generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        baselinePorts = [
                            new port_instance_1.PortInstance(3000, baseline),
                            new port_instance_1.PortInstance(4000, baseline)
                        ];
                        s = new ports_set_backend_1.PortsSet(tslib_1.__spreadArrays([
                            new port_instance_1.PortInstance([2000, 2001])
                        ], baselinePorts), function (a) { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                            return [2 /*return*/, a];
                        }); }); });
                        _a = chai_1.expect;
                        _c = (_b = _).isEqual;
                        return [4 /*yield*/, s.getReserverFor(baseline)];
                    case 1:
                        _a.apply(void 0, [_c.apply(_b, [_g.sent(), baselinePorts])]).to.be.true;
                        baselinePorts = [];
                        _d = chai_1.expect;
                        _f = (_e = _).isEqual;
                        return [4 /*yield*/, s.getReserverFor(baseline)];
                    case 2:
                        _d.apply(void 0, [_f.apply(_e, [_g.sent(), baselinePorts])]).to.be.false;
                        return [2 /*return*/];
                }
            });
        });
    });
    mocha_1.it('should reserve correcly ports for standalone porject', function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var s, _a;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        s = new ports_set_backend_1.PortsSet([
                            new port_instance_1.PortInstance(4000, baseline),
                            new port_instance_1.PortInstance(6000),
                            new port_instance_1.PortInstance(tnp_models_1.Models.other.Range.from(7000).to(7005))
                        ], function (a) { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                            return [2 /*return*/, a];
                        }); }); });
                        _a = chai_1.expect;
                        return [4 /*yield*/, s.reserveFreePortsFor(tnp)];
                    case 1:
                        _a.apply(void 0, [_b.sent()]).to.be.true;
                        return [2 /*return*/];
                }
            });
        });
    });
    mocha_1.it('should reserve correcly ports for workspace porject', function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var s, _a;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        s = new ports_set_backend_1.PortsSet([
                            new port_instance_1.PortInstance(4000),
                            new port_instance_1.PortInstance(6000),
                            new port_instance_1.PortInstance(tnp_models_1.Models.other.Range.from(7000).to(7010))
                        ], function (a) { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                            return [2 /*return*/, a];
                        }); }); });
                        _a = chai_1.expect;
                        return [4 /*yield*/, s.reserveFreePortsFor(baseline)];
                    case 1:
                        _a.apply(void 0, [_b.sent()]).to.be.true;
                        chai_1.expect(s.numOfTakenPortsAvailable).to.be.eq(baseline.children.length + 1);
                        return [2 /*return*/];
                }
            });
        });
    });
    mocha_1.it('should not reserve ports if is not a space', function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var s, _a;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        s = new ports_set_backend_1.PortsSet([
                            new port_instance_1.PortInstance(tnp_models_1.Models.other.Range.from(7000).to(baseline.children.length))
                        ], function (a) { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                            return [2 /*return*/, a];
                        }); }); });
                        _a = chai_1.expect;
                        return [4 /*yield*/, s.reserveFreePortsFor(baseline)];
                    case 1:
                        _a.apply(void 0, [_b.sent()]).to.be.false;
                        return [2 /*return*/];
                }
            });
        });
    });
});
//# sourceMappingURL=ports-set.spec.js.map