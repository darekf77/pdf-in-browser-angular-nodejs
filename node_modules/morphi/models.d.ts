import { RequestHandler } from 'express';
import { Response as ExpressResponse, Request as ExpressRequest } from 'express';
import { Models as ModelsNg2Rest } from 'ng2-rest';
import 'rxjs/add/operator/map';
export declare namespace Models {
    export import Rest = ModelsNg2Rest;
    type ContextENDPOINT = {
        target: Function;
        initFN: Function;
    };
    type FormlyFromType = 'material' | 'bootstrap';
    type ExpressContext<T> = (req: ExpressRequest, res: ExpressResponse) => T;
    type SyncResponse<T> = string | T;
    type ResponseFuncOpt<T> = {
        limitSize?: (enties: Function | Function[], include: string[], exclude: string[]) => void;
    };
    type SyncResponseFunc<T> = (options?: ResponseFuncOpt<T>) => SyncResponse<T>;
    type MixResponse<T> = SyncResponse<T> | ExpressContext<T>;
    interface ClientAction<T> {
        received?: Rest.PromiseObservableMix<Rest.HttpResponse<T>>;
    }
    interface __Response<T> {
        send?: MixResponse<T>;
    }
    interface AsyncResponse<T> {
        (req?: ExpressRequest, res?: ExpressResponse): Promise<SyncResponse<T> | SyncResponseFunc<T>>;
    }
    type Response<T = string> = (__Response<T> | AsyncResponse<T>) & ClientAction<T> & __Response<T>;
    class Errors {
        message: string;
        private code;
        toString: () => string;
        private constructor();
        private static create;
        static entityNotFound(entity?: Function): Errors;
        static custom(message: string, code?: ModelsNg2Rest.HttpCode): Errors;
    }
    interface AuthCallBack {
        (methodReference: Function): RequestHandler;
    }
    type InlinePkg = {
        isIsomorphic: boolean;
        realName: string;
    };
}
