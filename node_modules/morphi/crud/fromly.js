"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tnp_core_1 = require("tnp-core");
var ng2_rest_1 = require("ng2-rest");
var type_from_entity_1 = require("./type-from-entity");
var typescript_class_helpers_1 = require("typescript-class-helpers");
function getFromlyConfigFor(target, options) {
    if (options === void 0) { options = {}; }
    var _a = options.formType, formType = _a === void 0 ? 'material' : _a, _b = options.keysPathesToExclude, keysPathesToExclude = _b === void 0 ? [] : _b, _c = options.keysPathesToInclude, keysPathesToInclude = _c === void 0 ? [] : _c, parentModel = options.parentModel, _d = options.relativePath, relativePath = _d === void 0 ? '' : _d, _e = options.level, level = _e === void 0 ? 0 : _e, _f = options.maxLevel, maxLevel = _f === void 0 ? 4 : _f;
    if (typescript_class_helpers_1.CLASS.getName(target) === 'Project') {
        return [];
    }
    if (level === maxLevel) {
        return [];
    }
    var mapping = ng2_rest_1.Mapping.getModelsMapping(target);
    // console.log('mapping', mapping)
    var fieldNames = typescript_class_helpers_1.CLASS.describeProperites(target);
    var checkExclude = (tnp_core_1._.isArray(keysPathesToExclude) && keysPathesToExclude.length > 0);
    var checkInclude = (tnp_core_1._.isArray(keysPathesToInclude) && keysPathesToInclude.length > 0);
    if (checkExclude && checkInclude) {
        throw "In morphi function getFromlyConfigFor(...) please use keysPathesToInclude or keysPathesToExclude, ";
    }
    // if (checkInclude) {
    //   console.log('check include', keysPathesToExclude)
    // }
    // if (checkExclude) {
    //   console.log('check exclude', keysPathesToExclude)
    // }
    var fields = [];
    function inputToPush(key, type, model, targetChild) {
        // console.log(`key(${key}) type: ${type} | model: ${model} targetChild: ${targetChild && targetChild.name}`)
        var res;
        if (type === 'repeat') {
            var fieldGroup = getFromlyConfigFor(targetChild, {
                formType: formType, keysPathesToInclude: keysPathesToInclude, keysPathesToExclude: keysPathesToExclude,
                relativePath: relativePath + "." + key,
                level: (level + 1), maxLevel: maxLevel
            });
            if (fieldGroup.length > 0) {
                res = {
                    key: key,
                    type: type,
                    defaultValue: [],
                    fieldArray: {
                        fieldGroupClassName: 'row',
                        templateOptions: {
                            label: "Add new " + tnp_core_1._.startCase(key)
                        },
                        fieldGroup: fieldGroup
                    }
                };
            }
        }
        else if (type === 'group') {
            var fieldGroup = getFromlyConfigFor(targetChild, {
                formType: formType, keysPathesToInclude: keysPathesToInclude, keysPathesToExclude: keysPathesToExclude, parentModel: model,
                relativePath: relativePath + "." + key,
                level: (level + 1), maxLevel: maxLevel
            });
            if (fieldGroup.length > 0) {
                res = {
                    fieldGroupClassName: 'row',
                    templateOptions: {
                        label: "" + tnp_core_1._.startCase(key)
                    },
                    wrappers: ['groupwrap'],
                    fieldGroup: fieldGroup
                };
            }
        }
        else {
            res = {
                key: key,
                model: model,
                type: type,
                defaultValue: !tnp_core_1._.isUndefined(target.prototype[key]) ? target.prototype[key] : undefined,
                templateOptions: {
                    label: tnp_core_1._.isString(model) ? model.split('.').map(function (l) { return tnp_core_1._.startCase(l); }).join(' / ') + " / " + tnp_core_1._.startCase(key)
                        : tnp_core_1._.startCase(key)
                }
            };
        }
        if (res) {
            Object.keys(res).forEach(function (key) { return res[key] === undefined ? delete res[key] : ''; });
        }
        return res;
    }
    function isAlowedPath(key) {
        var isAlowed = true;
        var matchPath = relativePath === '' ? key : relativePath + ":" + key;
        if (checkExclude) {
            if (keysPathesToExclude.includes(matchPath)) {
                // console.log(`Not allowed key: ${key}`)
                isAlowed = false;
            }
            else {
                isAlowed = true;
            }
        }
        else if (checkInclude) {
            if (keysPathesToInclude.includes(matchPath)) {
                // console.log(`Allowed key: ${key}`)
                isAlowed = true;
            }
            else {
                isAlowed = false;
            }
        }
        // console.log(`Is allowed;${matchPath} `, isAlowed)
        return isAlowed;
    }
    var simpleResolved = [];
    function resolveSimpleTypes() {
        for (var key in target.prototype) {
            if (target.prototype.hasOwnProperty(key) && !tnp_core_1._.isFunction(target.prototype[key])) {
                if (!isAlowedPath(key)) {
                    continue;
                }
                if (!tnp_core_1._.isUndefined(mapping[key])) {
                    continue;
                }
                var element = target.prototype[key];
                var type = 'input';
                if (tnp_core_1._.isBoolean(element)) {
                    type = 'switch';
                }
                else if (tnp_core_1._.isDate(element)) {
                    type = 'datepicker';
                }
                fields.push(inputToPush(key, type, parentModel));
                simpleResolved.push(key);
            }
        }
    }
    function resolveComplexTypes() {
        fieldNames
            .filter(function (key) { return !simpleResolved.includes(key); })
            .forEach(function (key) {
            if (isAlowedPath(key) && !tnp_core_1._.isUndefined(mapping[key])) {
                var className = mapping[key];
                var isArray = tnp_core_1._.isArray(className);
                className = isArray ? tnp_core_1._.first(className) : className;
                if (className === 'Date') {
                    fields.push(inputToPush(key, 'datepicker', parentModel));
                }
                else {
                    var targetChild = typescript_class_helpers_1.CLASS.getBy(className);
                    if (targetChild) {
                        var ftype = type_from_entity_1.findTypeForEntity(targetChild, isArray);
                        if (ftype) {
                            fields = fields.concat(inputToPush(key, ftype.name, key));
                        }
                        else {
                            if (isArray) {
                                fields = fields.concat(inputToPush(key, 'repeat', key, targetChild));
                            }
                            else {
                                fields = fields.concat(inputToPush(key, 'group', key, targetChild));
                            }
                        }
                    }
                }
            }
        });
    }
    function generate() {
        resolveSimpleTypes();
        resolveComplexTypes();
    }
    generate();
    return fields.filter(function (f) { return !!f; });
}
exports.getFromlyConfigFor = getFromlyConfigFor;
//# sourceMappingURL=fromly.js.map