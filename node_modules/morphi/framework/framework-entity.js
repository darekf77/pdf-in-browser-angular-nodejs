"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var tnp_core_1 = require("tnp-core");
var ng2_logger_1 = require("ng2-logger");
var symbols_1 = require("../symbols");
var framework_helpers_1 = require("./framework-helpers");
var ng2_rest_1 = require("ng2-rest");
//#region @backend
var typeorm_1 = require("typeorm");
var framework_helpers_2 = require("./framework-helpers");
//#endregion
var realtime_1 = require("../realtime");
var typescript_class_helpers_1 = require("typescript-class-helpers");
var log = ng2_logger_1.Log.create('Framework entity', ng2_logger_1.Level.__NOTHING);
function getUpdateID(id, entityName, propterty, config) {
    return tnp_core_1._.kebabCase(id) + "-" + tnp_core_1._.kebabCase(entityName) + "-" + tnp_core_1._.kebabCase(propterty) + "-" + (tnp_core_1._.isObject(config) ? tnp_core_1._.kebabCase(JSON.stringify(config)) : '');
}
var IS_RELATIME = Symbol();
var IS_RELATIME_PROPERTY = Symbol();
function getRealtimeIsRealtime(entity, property) {
    if (!tnp_core_1._.isObject(entity[IS_RELATIME_PROPERTY])) {
        entity[IS_RELATIME_PROPERTY] = {};
    }
    return entity[IS_RELATIME_PROPERTY][property];
}
function Entity(options) {
    if (!options) {
        options = { formly: {} };
    }
    if (!options.formly) {
        options.formly = {};
    }
    var defaultModelValues = options.defaultModelValues, tree = options.tree, mapping = options.mapping, _a = options.additionalMapping, additionalMapping = _a === void 0 ? {} : _a, _b = options.uniqueKeyProp, uniqueKeyProp = _b === void 0 ? 'id' : _b, classFamily = options.classFamily, className = options.className, classNameInBrowser = options.classNameInBrowser, _c = options.formly, _d = _c === void 0 ? {} : _c, _e = _d.transformFn, transformFn = _e === void 0 ? undefined : _e, _f = _d.include, include = _f === void 0 ? undefined : _f, _g = _d.exclude, exclude = _g === void 0 ? undefined : _g, 
    //#region @backend
    browserTransformFn = options.browserTransformFn, _h = options.createTable, createTable = _h === void 0 ? true : _h;
    return function (target) {
        className = framework_helpers_1.classNameVlidation(className, target);
        typescript_class_helpers_1.CLASS.NAME(className, {
            uniqueKey: uniqueKeyProp,
            classFamily: classFamily,
            classNameInBrowser: classNameInBrowser
        })(target);
        ng2_rest_1.Mapping.DefaultModelWithMapping(defaultModelValues, tnp_core_1._.merge(mapping, additionalMapping))(target);
        //#region @backend
        if (tnp_core_1._.isFunction(browserTransformFn)) {
            var configs = typescript_class_helpers_1.CLASS.getConfig(target);
            var config = tnp_core_1._.first(configs);
            config.browserTransformFn = browserTransformFn;
            // console.log('BROWSER TRANSFORM FUNCTION ADDED TO CONFIGS', configs)
        }
        if (createTable) {
            typeorm_1.Entity(framework_helpers_2.tableNameFrom(target))(target);
        }
        target[symbols_1.SYMBOL.HAS_TABLE_IN_DB] = createTable;
        if (tnp_core_1._.isString(tree)) {
            typeorm_1.Tree("closure-table")(target);
        }
        //#endregion
    };
}
exports.Entity = Entity;
var BASE_ENTITY = /** @class */ (function () {
    function BASE_ENTITY() {
    }
    BASE_ENTITY.prototype.isListeningToRealtimeChanges = function (property) {
        if (tnp_core_1._.isString(property)) {
            return !!getRealtimeIsRealtime(this, property);
        }
        else {
            return !!this[IS_RELATIME];
        }
    };
    BASE_ENTITY.prototype.unsubscribeRealtimeUpdatesOfProperties = function () {
        var _this = this;
        if (tnp_core_1._.isObject(this[IS_RELATIME_PROPERTY])) {
            Object.keys(this[IS_RELATIME_PROPERTY]).forEach(function (property) {
                _this.unsubscribeRealtimeUpdates(property);
            });
        }
    };
    BASE_ENTITY.prototype.unsubscribeRealtimeUpdates = function (property) {
        var _this = this;
        if (tnp_core_1._.isArray(property)) {
            property.forEach(function (p) {
                _this.unsubscribeRealtimeUpdates(p);
            });
            return;
        }
        if (tnp_core_1._.isString(property)) {
            realtime_1.RealtimeBrowser.UnsubscribeEntityPropertyChanges(this, property);
            this[IS_RELATIME_PROPERTY][property] = void 0;
        }
        else {
            this[IS_RELATIME] = false;
            realtime_1.RealtimeBrowser.UnsubscribeEntityChanges(this);
        }
    };
    BASE_ENTITY.prototype.subscribeRealtimeUpdates = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var modelDataConfig = options.modelDataConfig, callback = options.callback, afterMergeCallback = options.afterMergeCallback, property = options.property, update = options.update, bufforProperty = options.bufforProperty;
        if (!tnp_core_1._.isObject(this[IS_RELATIME_PROPERTY])) {
            this[IS_RELATIME_PROPERTY] = {};
        }
        var changesListener = function (entityToUpdate, info) {
            return function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var updateID, alreadyLength, data, newData, newDataCallaback, newDataType;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            updateID = getUpdateID(entityToUpdate.id, typescript_class_helpers_1.CLASS.getNameFromObject(entityToUpdate), property, modelDataConfig);
                            // log.d(`info: ${info} UPDATE ID: ${updateID}`)
                            if (BASE_ENTITY.__updatesInProgress[updateID]) {
                                console.warn("ANOTHER UPDATE IN PROGRESS FOR UPDATEID: \"" + updateID + "\"");
                                return [2 /*return*/];
                            }
                            BASE_ENTITY.__updatesInProgress[updateID] = true;
                            alreadyLength = 0;
                            if (tnp_core_1._.isString(bufforProperty)) {
                                if (!tnp_core_1._.isUndefined(entityToUpdate[bufforProperty]) &&
                                    (tnp_core_1._.isString(entityToUpdate[bufforProperty]) || tnp_core_1._.isArray(entityToUpdate[bufforProperty]))) {
                                    alreadyLength = entityToUpdate[bufforProperty].length;
                                }
                            }
                            data = { body: { json: entityToUpdate } };
                            if (!entityToUpdate.ctrl) {
                                log.w("There is not ctrl (controller) for entity \"" + typescript_class_helpers_1.CLASS.getNameFromObject(entityToUpdate) + "\"");
                                return [2 /*return*/];
                            }
                            if (!tnp_core_1._.isFunction(update)) return [3 /*break*/, 2];
                            return [4 /*yield*/, update()];
                        case 1:
                            data = _a.sent();
                            return [3 /*break*/, 6];
                        case 2:
                            if (!tnp_core_1._.isString(bufforProperty)) return [3 /*break*/, 4];
                            return [4 /*yield*/, entityToUpdate.ctrl.bufforedChanges(entityToUpdate.id, property, alreadyLength, modelDataConfig).received];
                        case 3:
                            data = _a.sent();
                            return [3 /*break*/, 6];
                        case 4: return [4 /*yield*/, entityToUpdate.ctrl.getBy(entityToUpdate.id, modelDataConfig).received];
                        case 5:
                            data = _a.sent();
                            _a.label = 6;
                        case 6:
                            newData = data.body.json;
                            if (tnp_core_1._.isFunction(callback)) {
                                newDataCallaback = callback(data);
                                if (!tnp_core_1._.isUndefined(newDataCallaback)) {
                                    newData = newDataCallaback;
                                }
                            }
                            newDataType = tnp_core_1._.isArray(newData) ? 'array' : (tnp_core_1._.isString(newData) ? 'string' : void 0);
                            if (tnp_core_1._.isString(bufforProperty) && !newDataType) {
                                console.warn(data);
                                console.warn('New data type is not string or array', newData);
                            }
                            if (tnp_core_1._.isString(property)) {
                                if (tnp_core_1._.isString(bufforProperty)) {
                                    if (tnp_core_1._.isNil(entityToUpdate[bufforProperty])) {
                                        entityToUpdate[bufforProperty] = ((newDataType === 'array') ? [] : '');
                                    }
                                    entityToUpdate[bufforProperty] = entityToUpdate[bufforProperty].concat(newData);
                                }
                                else {
                                    entityToUpdate[property] = newData;
                                }
                            }
                            else {
                                mergeWhatImportant(entityToUpdate, newData);
                                // _.merge(entityToUpdate, newData);
                            }
                            if (tnp_core_1._.isFunction(afterMergeCallback)) {
                                afterMergeCallback(entityToUpdate);
                            }
                            BASE_ENTITY.__updatesInProgress[updateID] = false;
                            return [2 /*return*/];
                    }
                });
            }); };
        };
        if (this.isListeningToRealtimeChanges(property)) {
            console.warn("Alread listen to this " + (tnp_core_1._.isString(property) ? ('property: ' + property + ' of entity: ' + typescript_class_helpers_1.CLASS.getNameFromObject(this))
                : ('entity: ' + typescript_class_helpers_1.CLASS.getNameFromObject(this))) + " ", this);
            realtime_1.RealtimeBrowser.addDupicateRealtimeEntityListener(this, changesListener(this, "duplicate property(" + property + ")"), property);
            return;
        }
        if (tnp_core_1._.isString(property)) {
            this[IS_RELATIME_PROPERTY][property] = true;
            realtime_1.RealtimeBrowser.SubscribeEntityPropertyChanges(this, property, changesListener(this, "normal property(" + property + ")"));
        }
        else {
            this[IS_RELATIME] = true;
            realtime_1.RealtimeBrowser.SubscribeEntityChanges(this, changesListener(this, "model"));
        }
        if (tnp_core_1._.isString(bufforProperty)) {
            realtime_1.RealtimeBrowser.TriggerChange(this, property);
        }
    };
    BASE_ENTITY.__updatesInProgress = {};
    return BASE_ENTITY;
}());
exports.BASE_ENTITY = BASE_ENTITY;
function mergeWhatImportant(dest, source) {
    if (tnp_core_1._.isObject(source)) {
        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                var element = source[key];
                if (!tnp_core_1._.isUndefined(element)) {
                    dest[key] = source[key];
                }
            }
        }
    }
}
//# sourceMappingURL=framework-entity.js.map