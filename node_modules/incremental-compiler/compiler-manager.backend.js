"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
//#region imports
var tnp_core_1 = require("tnp-core");
var typescript_class_helpers_1 = require("typescript-class-helpers");
var helpers_backend_1 = require("./helpers.backend");
var change_of_file_backend_1 = require("./change-of-file.backend");
//#endregion
var CompilerManager = /** @class */ (function () {
    function CompilerManager() {
        this.lastAsyncFiles = [];
        this.currentObservedFolder = [];
        this.clients = [];
        this.inited = false;
    }
    Object.defineProperty(CompilerManager, "Instance", {
        get: function () {
            if (!this._instance) {
                this._instance = new CompilerManager();
            }
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    CompilerManager.prototype.syncInit = function (client) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var files;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        files = [];
                        if (tnp_core_1._.isArray(client.folderPath) && client.folderPath.length > 0) {
                            files = client.folderPath
                                .reduce(function (folderOrFileA, folderOrFileB) {
                                var filesFromB = [folderOrFileB];
                                if (tnp_core_1.fse.lstatSync(folderOrFileB).isDirectory()) {
                                    filesFromB = tnp_core_1.glob.sync(folderOrFileB + "/**/*.*", {
                                        symlinks: client.followSymlinks
                                    });
                                }
                                return folderOrFileA.concat(filesFromB);
                            }, [])
                                .filter(function (f) {
                                if (client.subscribeOnlyFor.length > 0) {
                                    return client.subscribeOnlyFor
                                        .includes(tnp_core_1.path.extname(f).replace('.', ''));
                                }
                                return true;
                            });
                        }
                        // console.log(`Files for client.folderPath: ${client.folderPath}  client.followSymlinks: ${client.followSymlinks}`)
                        return [4 /*yield*/, client.syncAction(files)];
                    case 1:
                        // console.log(`Files for client.folderPath: ${client.folderPath}  client.followSymlinks: ${client.followSymlinks}`)
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    CompilerManager.prototype.asyncInit = function (client) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var newFoldersOrFiles_1;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                // Helpers.log(`this.clients: ${this.clients.map(c => CLASS.getNameFromObject(c)).join(',')} `)
                // Helpers.log(`this.allFoldersToWatch: ${this.allFoldersToWatch}`);
                if (!this.watcher) {
                    this.currentObservedFolder = tnp_core_1._.cloneDeep(this.firstFoldersToWatch);
                    // console.info('FILEESS ADDED TO WATCHER INITT', this.allFoldersToWatch)
                    this.watcher = tnp_core_1.chokidar.watch(this.currentObservedFolder, {
                        ignoreInitial: true,
                        followSymlinks: client.followSymlinks,
                        ignorePermissionErrors: true,
                    }).on('all', function (event, f) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        var toNotify, change, clients, index, clientAsyncAction;
                        return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(event !== 'addDir' && event !== 'unlinkDir')) return [3 /*break*/, 7];
                                    if (this.lastAsyncFiles.includes(f)) {
                                        return [2 /*return*/];
                                    }
                                    else {
                                        this.lastAsyncFiles.push(f);
                                    }
                                    helpers_backend_1.Helpers.log("[ic] event " + event + ", path: " + f);
                                    toNotify = this.clients
                                        .filter(function (c) {
                                        return c.folderPath.find(function (p) {
                                            if (f.startsWith(p)) {
                                                if (c.watchDepth === Number.POSITIVE_INFINITY) {
                                                    return true;
                                                }
                                                var r = f.replace(p, '').replace(/^\//, '').split('/').length - 1;
                                                return r <= c.watchDepth;
                                            }
                                            return false;
                                        });
                                    });
                                    if (event === 'unlink') {
                                        toNotify = toNotify.filter(function (f) { return f.notifyOnFileUnlink; });
                                    }
                                    change = new change_of_file_backend_1.ChangeOfFile(toNotify, f, event);
                                    if (!this.asyncEventScenario) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.asyncEventScenario(change)];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    clients = change.clientsForChangeFilterExt;
                                    index = 0;
                                    _a.label = 3;
                                case 3:
                                    if (!(index < clients.length)) return [3 /*break*/, 6];
                                    clientAsyncAction = clients[index];
                                    if (!clientAsyncAction.executeOutsideScenario) return [3 /*break*/, 5];
                                    return [4 /*yield*/, clientAsyncAction.asyncAction(change)];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5:
                                    index++;
                                    return [3 /*break*/, 3];
                                case 6:
                                    this.lastAsyncFiles = this.lastAsyncFiles.filter(function (ef) { return ef !== f; });
                                    _a.label = 7;
                                case 7: return [2 /*return*/];
                            }
                        });
                    }); });
                }
                else {
                    if (tnp_core_1._.isString(client.folderPath)) {
                        client.folderPath = [client.folderPath];
                    }
                    newFoldersOrFiles_1 = [];
                    client.folderPath
                        .map(mapForWatching)
                        .filter(function (f) {
                        if (!_this.currentObservedFolder.includes(f)) {
                            // console.info('FILEESS ADDED TO WATCHER', f)
                            _this.watcher.add(f);
                            newFoldersOrFiles_1.push(f);
                        }
                    });
                    this.currentObservedFolder = this.currentObservedFolder.concat(newFoldersOrFiles_1);
                }
                return [2 /*return*/];
            });
        });
    };
    Object.defineProperty(CompilerManager.prototype, "allClients", {
        get: function () {
            var that = this;
            return {
                get: function (clientNameOrClass, condition) {
                    if (tnp_core_1._.isUndefined(clientNameOrClass) && tnp_core_1._.isUndefined(condition)) {
                        return that.clients;
                    }
                    return helpers_backend_1.clientsBy(clientNameOrClass, condition, that.clients);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    CompilerManager.prototype.addClient = function (client) {
        // console.log(`Cilent added "${CLASS.getNameFromObject(client)}" folders`, client.folderPath)
        var existed = this.clients.find(function (c) { return c === client; });
        if (existed) {
            helpers_backend_1.Helpers.warn("Client \"" + typescript_class_helpers_1.CLASS.getNameFromObject(client) + "\" alread added");
        }
        this.clients.push(client);
    };
    CompilerManager.prototype.initScenario = function (onAsyncFileChange) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.preventAlreadyInited();
                this.asyncEventScenario = onAsyncFileChange;
                this.inited = true;
                return [2 /*return*/];
            });
        });
    };
    CompilerManager.prototype.preventAlreadyInited = function () {
        if (this.inited) {
            helpers_backend_1.Helpers.error("Please init Compiler Manager only once:\n      CompilerManager.Instance.initScenario( ... async scenario ...  );\n      ", false, true);
        }
    };
    Object.defineProperty(CompilerManager.prototype, "firstFoldersToWatch", {
        get: function () {
            var folders = [];
            this.clients.forEach(function (c) {
                // console.log("c.folderPath", c.folderPath)
                c.folderPath.forEach(function (fp) {
                    // console.log(`fp`, fp)
                    if (tnp_core_1._.isString(fp) && !folders.includes(fp)) {
                        folders.push(fp);
                    }
                });
            });
            return folders.map(mapForWatching);
        },
        enumerable: true,
        configurable: true
    });
    return CompilerManager;
}());
exports.CompilerManager = CompilerManager;
function mapForWatching(c) {
    if (tnp_core_1.fse.lstatSync(c).isDirectory()) {
        return c + "/**/*.*";
    }
    return c;
}
//# sourceMappingURL=compiler-manager.backend.js.map