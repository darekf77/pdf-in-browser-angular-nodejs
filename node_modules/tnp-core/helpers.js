"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_imports_1 = require("./core-imports");
var index_1 = require("./index");
var helpers_messages_1 = require("./helpers-messages");
var encoding = 'utf8';
var HelpersCore = /** @class */ (function (_super) {
    tslib_1.__extends(HelpersCore, _super);
    function HelpersCore() {
        var _this = _super.call(this) || this;
        //#endregion
        _this.bigMaxBuffer = 2024 * 500;
        //#region @backend
        _this.processes = [];
        //#region @backend
        process.on('SIGINT', _this.cleanExit); // catch ctrl-c
        process.on('SIGTERM', _this.cleanExit); // catch kill
        return _this;
        //#endregion
    }
    Object.defineProperty(HelpersCore, "InstanceCore", {
        get: function () {
            if (!HelpersCore._instanceCore) {
                HelpersCore._instanceCore = new HelpersCore();
            }
            return HelpersCore._instanceCore;
        },
        enumerable: true,
        configurable: true
    });
    //#endregion
    //#region @backend
    HelpersCore.prototype.cleanExit = function () {
        index_1.Helpers.processes.forEach(function (p) {
            p.kill('SIGINT');
            p.kill('SIGTERM');
            index_1.Helpers.log("Killing child process on " + p.pid);
        });
        index_1.Helpers.log("Killing parent on " + process.pid);
        process.exit();
    };
    ;
    HelpersCore.prototype.removeSlashAtEnd = function (s) {
        s = (s === null || s === void 0 ? void 0 : s.endsWith("/")) ? s.slice(0, s.length - 1) : s;
        return s;
    };
    HelpersCore.prototype.stringify = function (inputObject) {
        // if (_.isString(inputObject)) {
        //   return inputObject;
        // }
        // if (_.isObject(inputObject)) {
        //   config.log(inputObject)
        //   Helpers.error(`[tnp-helpers] trying to stringify not a object`, false, true);
        // }
        return JSON.stringify(inputObject, null, 2);
    };
    HelpersCore.prototype.runSyncOrAsync = function (fn) {
        var firstArg = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            firstArg[_i - 1] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var promisOrValue;
            var _a;
            return tslib_1.__generator(this, function (_b) {
                if (core_imports_1._.isUndefined(fn)) {
                    return [2 /*return*/];
                }
                promisOrValue = core_imports_1._.isArray(fn) ? (_a = fn[1])[fn[0]].apply(_a, firstArg) : fn.apply(void 0, firstArg);
                if (promisOrValue instanceof Promise) {
                    // wasPromise = true;
                    promisOrValue = Promise.resolve(promisOrValue);
                }
                // console.log('was promis ', wasPromise)
                return [2 /*return*/, promisOrValue];
            });
        });
    };
    //#endregion
    //#region @backend
    HelpersCore.prototype.createSymLink = function (existedFileOrFolder, destinationPath, options) {
        existedFileOrFolder = core_imports_1.crossPlatformPath(existedFileOrFolder);
        destinationPath = core_imports_1.crossPlatformPath(destinationPath);
        index_1.Helpers.log("[tnp-helpers][create link] exited -> dest\n    " + existedFileOrFolder + " " + destinationPath);
        options = options ? options : {};
        if (core_imports_1._.isUndefined(options.continueWhenExistedFolderDoesntExists)) {
            options.continueWhenExistedFolderDoesntExists = false;
        }
        if (core_imports_1._.isUndefined(options.dontRenameWhenSlashAtEnd)) {
            options.dontRenameWhenSlashAtEnd = false;
        }
        if (core_imports_1._.isUndefined(options.windowsHardLink)) {
            options.windowsHardLink = false;
        }
        if (core_imports_1._.isUndefined(options.speedUpProcess)) {
            options.speedUpProcess = false;
        }
        var continueWhenExistedFolderDoesntExists = options.continueWhenExistedFolderDoesntExists, windowsHardLink = options.windowsHardLink, speedUpProcess = options.speedUpProcess;
        // console.log('Create link!')
        var target = existedFileOrFolder;
        var link = destinationPath;
        if (!core_imports_1.fse.existsSync(existedFileOrFolder)) {
            if (continueWhenExistedFolderDoesntExists) {
                // just continue and create link to not existed folder
            }
            else {
                index_1.Helpers.error("[helpers.createLink] target path doesn't exist: " + existedFileOrFolder);
            }
        }
        /**
         * support for
         * pwd -> /mysource
         * ln -s . /test/inside -> /test/inside/mysource
         * ln -s ./ /test/inside -> /test/inside/mysource
         */
        if (link === '.' || link === './') {
            link = core_imports_1.crossPlatformPath(process.cwd());
        }
        if (!core_imports_1.path.isAbsolute(link)) {
            link = core_imports_1.crossPlatformPath(core_imports_1.path.join(core_imports_1.crossPlatformPath(process.cwd()), link));
        }
        if (!core_imports_1.path.isAbsolute(target)) {
            target = core_imports_1.crossPlatformPath(core_imports_1.path.join(core_imports_1.crossPlatformPath(process.cwd()), target));
        }
        if (link.endsWith('/')) {
            link = core_imports_1.crossPlatformPath(core_imports_1.path.join(link, core_imports_1.path.basename(target)));
        }
        if (!core_imports_1.fse.existsSync(core_imports_1.path.dirname(link))) {
            index_1.Helpers.mkdirp(core_imports_1.path.dirname(link));
        }
        var resolvedLink = core_imports_1.crossPlatformPath(core_imports_1.path.resolve(link));
        var resolvedTarget = core_imports_1.crossPlatformPath(core_imports_1.path.resolve(target));
        var targetIsFile = index_1.Helpers.isFile(resolvedTarget);
        if (!speedUpProcess) {
            var exactSameLocations = (resolvedLink === resolvedTarget);
            // const tagetIsLink = Helpers.isLink(resolvedTarget);
            // const exactSameLinks = (tagetIsLink && (fse.readlinkSync(resolvedTarget) === resolvedLink));
            // const exactSameOverrideTargetLink = (tagetIsLink && (fse.readlinkSync(resolvedTarget) === resolvedTarget));
            var targetIsLink = index_1.Helpers.isLink(resolvedTarget);
            var exactSameOVerrideTarget = (!index_1.Helpers.isLink(resolvedLink)
                && index_1.Helpers.exists(resolvedLink)
                && !targetIsLink
                && index_1.Helpers.exists(resolvedTarget)
                && index_1.Helpers.isFile(resolvedLink)
                && targetIsFile // TODO refactor this
                && index_1.Helpers.readFile(resolvedLink) === index_1.Helpers.readFile(resolvedTarget));
            if (exactSameLocations) {
                index_1.Helpers.warn("[createSymLink] Trying to link same location");
                return;
            }
            // if (exactSameLinks) {
            //   Helpers.warn(`[createSymLink] Trying to link same link`);
            //   return;
            // }
            // if (exactSameOverrideTargetLink) {
            //   Helpers.warn(`[createSymLink] Trying to override same link with link to itself`);
            //   return;
            // }
            if (exactSameOVerrideTarget) {
                var linkContainerLink = index_1.Helpers.pathContainLink(resolvedLink);
                var targetContainerLink = index_1.Helpers.pathContainLink(resolvedTarget);
                if ((!linkContainerLink && targetContainerLink)
                    || (linkContainerLink && !targetContainerLink)) {
                    index_1.Helpers.warn("[createSymLink] Trying to override same file with link to itself:\n          " + resolvedLink + "\n          to\n          " + resolvedTarget + "\n          ");
                    return;
                }
            }
            core_imports_1.rimraf.sync(link);
        }
        if (process.platform === 'win32') {
            target = core_imports_1.path.win32.normalize(target).replace(/\\$/, '');
            link = core_imports_1.path.win32.normalize(link).replace(/\\$/, '');
            // const winLinkCommand = `cmd  /c "mklink /D ${link} ${target}"`;
            // const winLinkCommand = `export MSYS=winsymlinks:nativestrict && ln -s ${target} ${link}`;
            var winLinkCommand = "mklink " + (windowsHardLink ? '/D' : (targetIsFile ? '/H' : '/j')) + " \"" + link + "\" \"" + target + "\"";
            index_1.Helpers.log("windows link: lnk " + target + " " + link + "\n\n      \"" + winLinkCommand + "'\n      ");
            try {
                index_1.Helpers.run(winLinkCommand, { biggerBuffer: false }).sync();
            }
            catch (error) {
                index_1.Helpers.error(error, true, false);
                index_1.Helpers.error("\n        command: \"" + winLinkCommand + "\"\n        [tnp-helpers] windows link error\n        target: \"" + target + "\"\n        link: \"" + link + "\"\n        command: \"" + winLinkCommand + "\"\n        ", true, false);
            }
        }
        else {
            core_imports_1.fse.symlinkSync(target, link);
        }
    };
    //#endregion
    //#region @backend
    HelpersCore.prototype.mkdirp = function (folderPath) {
        if (core_imports_1._.isArray(folderPath)) {
            folderPath = core_imports_1.path.join.apply(core_imports_1.path, folderPath);
        }
        if (!core_imports_1.path.isAbsolute(folderPath)) {
            index_1.Helpers.warn("[helpers][mkdirp] Path is not absolute, abort " + folderPath, true);
            return;
        }
        if (core_imports_1._.isString(folderPath) && folderPath.startsWith('/tmp ') && core_imports_1.os.platform() === 'darwin') {
            index_1.Helpers.warn("[helpers][mkdirp] On mac osx /tmp is changed to /private/tmp", false);
            folderPath = folderPath.replace("/tmp/", '/private/tmp/');
        }
        if (core_imports_1.fse.existsSync(folderPath)) {
            index_1.Helpers.warn("[helpers][mkdirp] folder path already exists: " + folderPath, false);
        }
        else {
            core_imports_1.fse.mkdirpSync(folderPath);
        }
    };
    //#endregion
    //#region @backend
    /**
     * @param existedLink check if source of link exists
     */
    HelpersCore.prototype.isLink = function (filePath, existedLink) {
        if (existedLink === void 0) { existedLink = false; }
        if (!core_imports_1.fse.existsSync(filePath)) {
            return false;
        }
        filePath = index_1.Helpers.removeSlashAtEnd(filePath);
        var isLink = false;
        if (process.platform === 'win32') {
            filePath = core_imports_1.path.win32.normalize(filePath);
            // console.log('extename: ', path.extname(filePath))
            isLink = core_imports_1.fse.lstatSync(filePath).isSymbolicLink() || core_imports_1.path.extname(filePath) === '.lnk';
        }
        else {
            if (process.platform === 'darwin') {
                isLink = core_imports_1.fse.lstatSync(filePath).isSymbolicLink();
                // try { // TODO Why would I want that ?
                //   const command = `[[ -L "${filePath}" && -d "${filePath}" ]] && echo "symlink"`;
                //   // console.log(command)
                //   const res = Helpers.run(command, { output: false, biggerBuffer: false }).sync().toString()
                //   return res.trim() === 'symlink'
                // } catch (error) {
                //   return false;
                // }
            }
            else { // TODO QUICK FIX
                isLink = core_imports_1.fse.lstatSync(filePath).isSymbolicLink();
            }
            if (existedLink) {
                var realPath = core_imports_1.fse.realpathSync(filePath);
                return index_1.Helpers.exists(realPath);
            }
            return isLink;
        }
    };
    //#endregion
    //#region @backend
    HelpersCore.prototype.pathContainLink = function (p) {
        var previous;
        while (true) {
            p = core_imports_1.crossPlatformPath(core_imports_1.path.dirname(p));
            if (p === previous) {
                return false;
            }
            if (index_1.Helpers.isLink(p)) {
                return true;
            }
            if (!index_1.Helpers.exists(p)) {
                return false;
            }
            previous = p;
        }
    };
    //#endregion
    //#region @backend
    HelpersCore.prototype.exists = function (folderOrFilePath, allowUnexistedLinks) {
        if (allowUnexistedLinks === void 0) { allowUnexistedLinks = false; }
        if (core_imports_1._.isArray(folderOrFilePath)) {
            folderOrFilePath = core_imports_1.path.join.apply(core_imports_1.path, folderOrFilePath);
        }
        if (!folderOrFilePath) {
            index_1.Helpers.warn("[helpers][exists] Path is not a string, abort.. \"" + folderOrFilePath + "\"", true);
            return false;
        }
        if (!core_imports_1.path.isAbsolute(folderOrFilePath)) {
            index_1.Helpers.warn("[helpers][exists] Path is not absolute, abort.. " + folderOrFilePath, true);
            return false;
        }
        return core_imports_1.fse.existsSync(folderOrFilePath);
    };
    //#endregion
    HelpersCore.prototype.run = function (command, options) {
        //#region @backend
        if (!options)
            options = {};
        if (options.output === undefined)
            options.output = true;
        if (options.biggerBuffer === undefined)
            options.biggerBuffer = false;
        if (options.cwd === undefined)
            options.cwd = core_imports_1.crossPlatformPath(process.cwd());
        if (!core_imports_1._.isString(command)) {
            index_1.Helpers.error("[tnp-helper] command is not a string");
        }
        //#endregion
        return {
            //#region @backend
            sync: function () {
                if (core_imports_1._.isArray(options.extractFromLine)) {
                    index_1.Helpers.error("[tnp-helper] extractFromLine only for:\n          - asyncAsPromise\n          - async\n          - unitlOutputContains\n\n          ", false, true);
                }
                if (core_imports_1._.isNumber(options.tryAgainWhenFailAfter) && options.tryAgainWhenFailAfter > 0) {
                    // TODO try again when fail
                    // try {
                    var proc = index_1.Helpers.runSyncIn(command, options);
                    return proc;
                    // } catch (error) {
                    //  TODO: WAIT FUNCTION HERE
                    //   return Helpers.run(command, options).sync()
                    // }
                }
                return index_1.Helpers.runSyncIn(command, options);
                4;
            },
            async: function (detach) {
                if (detach === void 0) { detach = false; }
                options.detach = detach;
                return index_1.Helpers.runAsyncIn(command, options);
            },
            asyncAsPromise: function () {
                var isResolved = false;
                return new Promise(function (resolve, reject) {
                    var proc = index_1.Helpers.runAsyncIn(command, options);
                    proc.on('exit', function () {
                        if (!isResolved) {
                            isResolved = true;
                            resolve(void 0);
                        }
                    });
                    proc.on('error', function () {
                        if (!isResolved) {
                            isResolved = true;
                            reject();
                        }
                    });
                });
            },
            unitlOutputContains: function (stdoutMsg, stderMsg) {
                var isResolved = false;
                return new Promise(function (resolve, reject) {
                    if (core_imports_1._.isString(stdoutMsg)) {
                        stdoutMsg = [stdoutMsg];
                    }
                    if (core_imports_1._.isString(stderMsg)) {
                        stderMsg = [stderMsg];
                    }
                    if (!core_imports_1._.isArray(stdoutMsg)) {
                        reject("[unitlOutputContains] Message not a array");
                    }
                    var proc = index_1.Helpers.runAsyncIn(command, options);
                    proc.stderr.on('data', function (message) {
                        var data = message.toString().trim();
                        if (!isResolved) {
                            for (var index = 0; index < stderMsg.length; index++) {
                                var rejectm = stderMsg[index];
                                if ((data.search(rejectm) !== -1)) {
                                    index_1.Helpers.info("[unitlOutputContains] Rejected move to next step...");
                                    isResolved = true;
                                    reject();
                                    proc.kill('SIGINT');
                                    break;
                                }
                            }
                        }
                    });
                    proc.stdout.on('data', function (message) {
                        var data = message.toString().trim();
                        if (!isResolved) {
                            for (var index = 0; index < stdoutMsg.length; index++) {
                                var m = stdoutMsg[index];
                                if ((data.search(m) !== -1)) {
                                    index_1.Helpers.info("[unitlOutputContains] Move to next step...");
                                    isResolved = true;
                                    resolve(void 0);
                                    break;
                                }
                            }
                        }
                        if (!isResolved) {
                            for (var index = 0; index < stderMsg.length; index++) {
                                var rejectm = stderMsg[index];
                                if ((data.search(rejectm) !== -1)) {
                                    index_1.Helpers.info("[unitlOutputContains] Rejected move to next step...");
                                    isResolved = true;
                                    reject();
                                    proc.kill('SIGINT');
                                    break;
                                }
                            }
                        }
                    });
                });
            }
            //#endregion
        };
    };
    //#region @backend
    HelpersCore.prototype.getStdio = function (options) {
        var output = options.output, silence = options.silence;
        var stdio = output ? [0, 1, 2] : ((core_imports_1._.isBoolean(silence) && silence) ? 'ignore' : undefined);
        // if (pipeToParentProcerss) {
        //   stdio = ['pipe', 'pipe', 'pipe'] as any;
        // }
        // if (inheritFromParentProcerss) {
        //   stdio = ['inherit', 'inherit', 'inherit'] as any;
        // }
        return stdio;
    };
    //#endregion
    //#region @backend
    HelpersCore.prototype.runSyncIn = function (command, options) {
        var cwd = options.cwd, biggerBuffer = options.biggerBuffer;
        var maxBuffer = biggerBuffer ? index_1.Helpers.bigMaxBuffer : undefined;
        var stdio = index_1.Helpers.getStdio(options);
        index_1.Helpers.checkProcess(cwd, command);
        return core_imports_1.child_process.execSync(command, { stdio: stdio, cwd: cwd, maxBuffer: maxBuffer });
    };
    //#endregion
    //#region @backend
    HelpersCore.prototype.runAsyncIn = function (command, options) {
        var output = options.output, cwd = options.cwd, biggerBuffer = options.biggerBuffer, outputLineReplace = options.outputLineReplace, extractFromLine = options.extractFromLine, detach = options.detach;
        var maxBuffer = biggerBuffer ? index_1.Helpers.bigMaxBuffer : undefined;
        var stdio = index_1.Helpers.getStdio(options);
        index_1.Helpers.checkProcess(cwd, command);
        var proc;
        if (detach) {
            var cmd = core_imports_1._.first(command.split(' '));
            var argsForCmd = command.split(' ').slice(1);
            console.log("cmd: \"" + cmd + "\",  args: \"" + argsForCmd.join(' ') + "\"");
            if (process.platform === 'win32') {
                proc = core_imports_1.spawn(cmd, argsForCmd, { cwd: cwd, detached: true });
                // proc = child_process.spawn(cmd, argsForCmd, {
                //   cwd,
                //   detached: true,
                //   // windowsVerbatimArguments: true,
                //   shell: true,
                //   // env: {
                //     // NODE_ENV: 'production',
                //   //   PATH: process.env.PATH
                //   // }
                // });
            }
            else {
                proc = core_imports_1.child_process.spawn(cmd, argsForCmd, { cwd: cwd, detached: true });
            }
            console.log("\n\n      DETACHED PROCESS IS WORKING ON PID: " + proc.pid + "\n\n      ");
            // proc = child.exec(`${command} &`, { cwd, maxBuffer, });
        }
        else {
            proc = core_imports_1.child_process.exec(command, { cwd: cwd, maxBuffer: maxBuffer, });
        }
        return index_1.Helpers.logProc(proc, detach ? true : output, detach ? void 0 : stdio, outputLineReplace, options.prefix, extractFromLine);
    };
    //#endregion
    //#region @backend
    HelpersCore.prototype.logProc = function (proc, output, stdio, outputLineReplace, prefix, extractFromLine) {
        if (output === void 0) { output = true; }
        index_1.Helpers.processes.push(proc);
        if (stdio) {
            // @ts-ignore
            proc.stdio = stdio;
        }
        if (!prefix) {
            prefix = '';
        }
        if (output) {
            proc.stdout.on('data', function (data) {
                process.stdout.write(index_1.Helpers.modifyLineByLine(data, outputLineReplace, prefix, extractFromLine));
            });
            proc.stdout.on('error', function (data) {
                console.log(index_1.Helpers.modifyLineByLine(data, outputLineReplace, prefix, extractFromLine));
            });
            proc.stderr.on('data', function (data) {
                process.stderr.write(index_1.Helpers.modifyLineByLine(data, outputLineReplace, prefix, extractFromLine));
            });
            proc.stderr.on('error', function (data) {
                console.log(index_1.Helpers.modifyLineByLine(data, outputLineReplace, prefix, extractFromLine));
            });
        }
        return proc;
    };
    HelpersCore.prototype.logProc2 = function (proc, stdoutMsg, stderMsg) {
        // processes.push(proc);
        var isResolved = false;
        if (core_imports_1._.isString(stdoutMsg)) {
            stdoutMsg = [stdoutMsg];
        }
        if (core_imports_1._.isString(stderMsg)) {
            stderMsg = [stderMsg];
        }
        return new Promise(function (resolve, reject) {
            // let stdio = [0,1,2]
            proc.stdout.on('data', function (message) {
                process.stdout.write(message);
                var data = message.toString().trim();
                if (!isResolved && core_imports_1._.isArray(stdoutMsg)) {
                    for (var index = 0; index < stdoutMsg.length; index++) {
                        var m = stdoutMsg[index];
                        if ((data.search(m) !== -1)) {
                            // Helpers.info(`[unitlOutputContains] Move to next step...`)
                            isResolved = true;
                            resolve(void 0);
                            break;
                        }
                    }
                }
                if (!isResolved && core_imports_1._.isArray(stderMsg)) {
                    for (var index = 0; index < stderMsg.length; index++) {
                        var rejectm = stderMsg[index];
                        if ((data.search(rejectm) !== -1)) {
                            // Helpers.info(`[unitlOutputContains] Rejected move to next step...`);
                            isResolved = true;
                            reject();
                            proc.kill('SIGINT');
                            break;
                        }
                    }
                }
                // console.log(data.toString());
            });
            proc.stdout.on('error', function (data) {
                process.stdout.write(JSON.stringify(data));
                // console.log(data);
            });
            proc.stderr.on('data', function (message) {
                process.stderr.write(message);
                // console.log(data.toString());
                var data = message.toString().trim();
                if (!isResolved && core_imports_1._.isArray(stderMsg)) {
                    for (var index = 0; index < stderMsg.length; index++) {
                        var rejectm = stderMsg[index];
                        if ((data.search(rejectm) !== -1)) {
                            // Helpers.info(`[unitlOutputContains] Rejected move to next step...`);
                            isResolved = true;
                            reject();
                            proc.kill('SIGINT');
                            break;
                        }
                    }
                }
            });
            proc.stderr.on('error', function (data) {
                process.stderr.write(JSON.stringify(data));
                // console.log(data);
            });
        });
    };
    //#endregion
    //#region @backend
    HelpersCore.prototype.checkProcess = function (dirPath, command) {
        if (!core_imports_1.fse.existsSync(dirPath)) {
            index_1.Helpers.error("\nPath for process cwd doesn't exist: " + dirPath + "\ncommand: " + command + "\n");
        }
        if (!command) {
            index_1.Helpers.error("Bad command: " + command);
        }
    };
    //#endregion
    //#region @backend
    HelpersCore.prototype.modifyLineByLine = function (data, outputLineReplace, prefix, extractFromLine) {
        var checkExtract = (core_imports_1._.isArray(extractFromLine) && extractFromLine.length > 0);
        var modifyOutput = core_imports_1._.isFunction(outputLineReplace);
        if (modifyOutput && core_imports_1._.isString(data)) {
            data = data.split(/\r?\n/).map(function (line) { return outputLineReplace(line); }).join('\n');
        }
        if (prefix && core_imports_1._.isString(data)) {
            return data.split('\n').map(function (singleLine) {
                if (!singleLine || singleLine.trim().length === 0 || singleLine.trim() === '.') {
                    return singleLine;
                }
                if (checkExtract) {
                    var sFuncs = extractFromLine
                        .filter(function (f) { return core_imports_1._.isString(f); });
                    if (sFuncs.filter(function (f) { return (singleLine.search(f) !== -1); }).length === sFuncs.length) {
                        var fun = extractFromLine.find(function (f) { return core_imports_1._.isFunction(f); });
                        if (fun) {
                            var s_1 = singleLine;
                            sFuncs.forEach(function (f) { s_1 = s_1.replace(f, ''); });
                            fun(s_1.trim());
                        }
                    }
                }
                return prefix + " " + singleLine;
            }).join('\n');
        }
        return data;
    };
    //#endregion
    //#region @backend
    HelpersCore.prototype.isFolder = function (pathToFileOrMaybeFolder) {
        return pathToFileOrMaybeFolder && core_imports_1.fse.existsSync(pathToFileOrMaybeFolder) &&
            core_imports_1.fse.lstatSync(pathToFileOrMaybeFolder).isDirectory();
    };
    //#endregion
    //#region @backend
    HelpersCore.prototype.isFile = function (pathToFileOrMaybeFolder) {
        return pathToFileOrMaybeFolder && core_imports_1.fse.existsSync(pathToFileOrMaybeFolder) &&
            !core_imports_1.fse.lstatSync(pathToFileOrMaybeFolder).isDirectory();
    };
    //#endregion
    //#region @backend
    /**
      * wrapper for fs.readFileSync
      */
    HelpersCore.prototype.readFile = function (absoluteFilePath, defaultValueWhenNotExists) {
        if (defaultValueWhenNotExists === void 0) { defaultValueWhenNotExists = void 0; }
        if (!core_imports_1.fse.existsSync(absoluteFilePath)) {
            return defaultValueWhenNotExists;
        }
        if (core_imports_1.fse.lstatSync(absoluteFilePath).isDirectory()) {
            return defaultValueWhenNotExists;
        }
        return core_imports_1.fse.readFileSync(absoluteFilePath, {
            encoding: encoding
        }).toString().trim();
    };
    //#endregion
    //#region @backend
    HelpersCore.prototype.readJson = function (absoluteFilePath, defaultValue, useJson5) {
        if (defaultValue === void 0) { defaultValue = {}; }
        if (useJson5 === void 0) { useJson5 = false; }
        if (!core_imports_1.fse.existsSync(absoluteFilePath)) {
            return {};
        }
        try {
            var fileContent = index_1.Helpers.readFile(absoluteFilePath);
            var json = void 0;
            json = index_1.Helpers.parse(fileContent, useJson5 || absoluteFilePath.endsWith('.json5'));
            return json;
        }
        catch (error) {
            return defaultValue;
        }
    };
    //#endregion
    //#region @backend
    HelpersCore.prototype.parse = function (jsonInstring, useJson5) {
        if (useJson5 === void 0) { useJson5 = false; }
        if (!core_imports_1._.isString(jsonInstring)) {
            index_1.Helpers.log(jsonInstring);
            index_1.Helpers.warn("[tnp-helpers] Trying to parse no a string...");
            return jsonInstring;
        }
        return (useJson5 ? core_imports_1.json5.parse(jsonInstring) : JSON.parse(jsonInstring));
    };
    //#endregion
    //#region @backend
    HelpersCore.prototype.compilationWrapper = function (fn, taskName, executionType) {
        if (taskName === void 0) { taskName = 'Task'; }
        if (executionType === void 0) { executionType = 'Compilation of'; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            function currentDate() {
                return "[" + core_imports_1.dateformat(new Date(), 'HH:MM:ss') + "]";
            }
            var error_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!fn || !core_imports_1._.isFunction(fn)) {
                            index_1.Helpers.error(executionType + " wrapper: \"" + fn + "\" is not a function.");
                            process.exit(1);
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        index_1.Helpers.log(currentDate() + " " + executionType + " \"" + taskName + "\" Started..");
                        return [4 /*yield*/, index_1.Helpers.runSyncOrAsync(fn)];
                    case 2:
                        _a.sent();
                        index_1.Helpers.log(currentDate() + " " + executionType + " \"" + taskName + "\" Done\u2713");
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        index_1.Helpers.log(core_imports_1.chalk.red(error_1));
                        index_1.Helpers.log(currentDate() + " " + executionType + " " + taskName + " ERROR");
                        process.exit(1);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    //#endregion
    //#region @backend
    /**
     * wrapper for fs.writeFileSync
     */
    HelpersCore.prototype.writeFile = function (absoluteFilePath, input, dontWriteSameFile) {
        if (dontWriteSameFile === void 0) { dontWriteSameFile = true; }
        if (core_imports_1._.isArray(absoluteFilePath)) {
            absoluteFilePath = core_imports_1.path.join.apply(this, absoluteFilePath);
        }
        absoluteFilePath = absoluteFilePath;
        if (!core_imports_1.fse.existsSync(core_imports_1.path.dirname(absoluteFilePath))) {
            index_1.Helpers.mkdirp(core_imports_1.path.dirname(absoluteFilePath));
        }
        if (core_imports_1._.isObject(input)) {
            input = index_1.Helpers.stringify(input);
        }
        else if (!core_imports_1._.isString(input)) {
            input = '';
        }
        if (dontWriteSameFile) {
            if (core_imports_1.fse.existsSync(absoluteFilePath)) {
                var existedInput = index_1.Helpers.readFile(absoluteFilePath);
                if (input === existedInput) {
                    // Helpers.log(`[helpers][writeFile] not writing same file (good thing): ${absoluteFilePath}`);
                    return false;
                }
            }
        }
        core_imports_1.fse.writeFileSync(absoluteFilePath, input, {
            encoding: encoding
        });
        return true;
    };
    //#endregion
    //#region @backend
    /**
     * wrapper for fs.writeFileSync
     */
    HelpersCore.prototype.writeJson = function (absoluteFilePath, input) {
        if (core_imports_1._.isArray(absoluteFilePath)) {
            absoluteFilePath = core_imports_1.path.join.apply(this, absoluteFilePath);
        }
        absoluteFilePath = absoluteFilePath;
        if (!index_1.Helpers.exists(core_imports_1.path.dirname(absoluteFilePath))) {
            index_1.Helpers.mkdirp(core_imports_1.path.dirname(absoluteFilePath));
        }
        core_imports_1.fse.writeJSONSync(absoluteFilePath, input, {
            encoding: encoding,
            spaces: 2
        });
        return true;
    };
    //#endregion
    //#region @backend
    /**
     * return absolute paths for folders inside folders
     */
    HelpersCore.prototype.foldersFrom = function (pathToFolder) {
        if (core_imports_1._.isArray(pathToFolder)) {
            pathToFolder = core_imports_1.path.join.apply(core_imports_1.path, pathToFolder);
        }
        if (!index_1.Helpers.exists(pathToFolder)) {
            return [];
        }
        return core_imports_1.fse.readdirSync(pathToFolder)
            .map(function (f) { return core_imports_1.path.join(pathToFolder, f); })
            .filter(function (f) { return core_imports_1.fse.lstatSync(f).isDirectory(); });
    };
    HelpersCore.prototype.linksToFoldersFrom = function (pathToFolder) {
        if (core_imports_1._.isArray(pathToFolder)) {
            pathToFolder = core_imports_1.path.join.apply(core_imports_1.path, pathToFolder);
        }
        if (!index_1.Helpers.exists(pathToFolder)) {
            return [];
        }
        return core_imports_1.fse.readdirSync(pathToFolder)
            .map(function (f) { return core_imports_1.path.join(pathToFolder, f); })
            .filter(function (f) { return core_imports_1.fse.lstatSync(f).isSymbolicLink(); })
            .filter(function (f) {
            var realPath = core_imports_1.fse.realpathSync(f);
            return index_1.Helpers.isFolder(realPath);
        });
    };
    //#endregion
    //#region @backend
    /**
     * return absolute paths for folders inside folders
     */
    HelpersCore.prototype.linksFrom = function (pathToFolder, options) {
        options = (options || {});
        if (core_imports_1._.isUndefined(options.linksOnlyTo)) {
            options.linksOnlyTo = 'both';
        }
        if (core_imports_1._.isUndefined(options.onlyLinksToExistedFilesOrFolder)) {
            options.onlyLinksToExistedFilesOrFolder = true;
        }
        if (core_imports_1._.isArray(pathToFolder)) {
            pathToFolder = core_imports_1.path.join.apply(core_imports_1.path, pathToFolder);
        }
        if (!index_1.Helpers.exists(pathToFolder)) {
            return [];
        }
        return core_imports_1.fse.readdirSync(pathToFolder)
            .map(function (f) { return core_imports_1.path.join(pathToFolder, f); })
            .filter(function (f) {
            var res = false;
            if (index_1.Helpers.isLink(f)) {
                res = !options.onlyLinksToExistedFilesOrFolder;
                var realPath = core_imports_1.fse.realpathSync(f);
                if (index_1.Helpers.exists(realPath)) {
                    res = true;
                    if (options.linksOnlyTo === 'folders') {
                        res = index_1.Helpers.isFolder(realPath);
                    }
                    if (options.linksOnlyTo === 'files') {
                        res = index_1.Helpers.isFile(realPath);
                    }
                }
            }
            return res;
        });
    };
    //#endregion
    //#region @backend
    /**
     * return absolute paths for folders inside folders
     */
    HelpersCore.prototype.filesFrom = function (pathToFolder) {
        if (core_imports_1._.isArray(pathToFolder)) {
            pathToFolder = core_imports_1.path.join.apply(core_imports_1.path, pathToFolder);
        }
        if (!index_1.Helpers.exists(pathToFolder)) {
            return [];
        }
        return core_imports_1.fse.readdirSync(pathToFolder)
            .map(function (f) { return core_imports_1.path.join(pathToFolder, f); })
            .filter(function (f) { return !core_imports_1.fse.lstatSync(f).isDirectory(); });
    };
    //#endregion
    //#region @backend
    HelpersCore.prototype.openFolderInFileExploer = function (folderPath) {
        if (process.platform === 'win32') {
            folderPath = core_imports_1.win32Path(folderPath);
        }
        try {
            index_1.Helpers.info("Opening path in file explorer: \"" + folderPath + "\"");
            if (process.platform === 'win32') {
                index_1.Helpers.run("explorer " + folderPath).sync();
                return;
            }
            if (process.platform === 'darwin') {
                index_1.Helpers.run("open " + folderPath).sync();
                return;
            }
            index_1.Helpers.run("xdg-open " + folderPath).sync();
        }
        catch (error) {
            if (process.platform !== 'win32') { // TODO QUICK fix explorer with path is triggering errro
                index_1.Helpers.error("Not able to open in file explorer: \"" + folderPath + "\"", false, true);
            }
        }
    };
    return HelpersCore;
}(helpers_messages_1.HelpersMessages));
exports.HelpersCore = HelpersCore;
//# sourceMappingURL=helpers.js.map