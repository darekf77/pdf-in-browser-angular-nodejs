/// <reference types="node" />
import { child_process } from './core-imports';
import { HelpersMessages } from './helpers-messages';
import { RunOptions } from './core-models';
export declare class HelpersCore extends HelpersMessages {
    private static _instanceCore;
    static get InstanceCore(): HelpersCore;
    cleanExit(): void;
    readonly bigMaxBuffer: number;
    constructor();
    removeSlashAtEnd(s: string): string;
    stringify(inputObject: any): string;
    runSyncOrAsync(fn: Function | [string, object], ...firstArg: any[]): Promise<any>;
    readonly processes: child_process.ChildProcess[];
    createSymLink(existedFileOrFolder: string, destinationPath: string, options?: {
        continueWhenExistedFolderDoesntExists?: boolean;
        windowsHardLink?: boolean;
        dontRenameWhenSlashAtEnd?: boolean;
        /**
         * only if you know that symlink can be created
         */
        speedUpProcess?: boolean;
    }): void;
    mkdirp(folderPath: string | string[]): void;
    /**
     * @param existedLink check if source of link exists
     */
    isLink(filePath: string, existedLink?: boolean): boolean;
    pathContainLink(p: string): boolean;
    exists(folderOrFilePath: string | string[], allowUnexistedLinks?: boolean): boolean;
    run(command: string, options?: RunOptions): {
        sync(): any;
        async(detach?: boolean): child_process.ChildProcess;
        asyncAsPromise(): any;
        unitlOutputContains(stdoutMsg: string | string[], stderMsg?: string | string[]): Promise<any>;
    };
    getStdio(options?: RunOptions): string | number[];
    runSyncIn(command: string, options?: RunOptions): string;
    runAsyncIn(command: string, options?: RunOptions): child_process.ChildProcess;
    logProc(proc: child_process.ChildProcess, output: boolean, stdio: any, outputLineReplace: (outputLine: string) => string, prefix: string, extractFromLine?: (string | Function)[]): child_process.ChildProcess;
    logProc2(proc: child_process.ChildProcess, stdoutMsg?: string | string[], stderMsg?: string | string[]): Promise<unknown>;
    checkProcess(dirPath: string, command: string): void;
    modifyLineByLine(data: string | Buffer | Error, outputLineReplace: (outputLine: string) => string, prefix: string, extractFromLine?: (string | Function)[]): string;
    isFolder(pathToFileOrMaybeFolder: string): boolean;
    isFile(pathToFileOrMaybeFolder: string): boolean;
    /**
      * wrapper for fs.readFileSync
      */
    readFile(absoluteFilePath: string, defaultValueWhenNotExists?: string): string | undefined;
    readJson(absoluteFilePath: string, defaultValue?: {}, useJson5?: boolean): any;
    parse<T = any>(jsonInstring: string, useJson5?: boolean): T;
    compilationWrapper(fn: () => void, taskName?: string, executionType?: 'Compilation of' | 'Code execution of' | 'Event:'): Promise<void>;
    /**
     * wrapper for fs.writeFileSync
     */
    writeFile(absoluteFilePath: string | (string[]), input: string | object, dontWriteSameFile?: boolean): boolean;
    /**
     * wrapper for fs.writeFileSync
     */
    writeJson(absoluteFilePath: string | (string[]), input: object): boolean;
    /**
     * return absolute paths for folders inside folders
     */
    foldersFrom(pathToFolder: string | string[]): string[];
    linksToFoldersFrom(pathToFolder: string | string[]): string[];
    /**
     * return absolute paths for folders inside folders
     */
    linksFrom(pathToFolder: string | string[], options?: {
        onlyLinksToExistedFilesOrFolder?: boolean;
        linksOnlyTo: 'files' | 'folders' | 'both';
    }): string[];
    /**
     * return absolute paths for folders inside folders
     */
    filesFrom(pathToFolder: string | string[]): string[];
    openFolderInFileExploer(folderPath: string): void;
}
