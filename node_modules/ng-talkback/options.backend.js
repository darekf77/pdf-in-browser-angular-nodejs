"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var logger_backend_1 = require("./logger.backend");
exports.RecordMode = {
    NEW: "NEW",
    OVERWRITE: "OVERWRITE",
    DISABLED: "DISABLED",
    ALL: []
};
exports.RecordMode.ALL = [exports.RecordMode.NEW, exports.RecordMode.OVERWRITE, exports.RecordMode.DISABLED];
exports.FallbackMode = {
    NOT_FOUND: "NOT_FOUND",
    PROXY: "PROXY",
    ALL: []
};
exports.FallbackMode.ALL = [exports.FallbackMode.NOT_FOUND, exports.FallbackMode.PROXY];
exports.DefaultOptions = {
    host: "",
    port: 8080,
    path: "./tapes/",
    record: exports.RecordMode.NEW,
    fallbackMode: exports.FallbackMode.NOT_FOUND,
    name: "unnamed",
    tapeNameGenerator: undefined,
    https: {
        enabled: false,
        keyPath: undefined,
        certPath: undefined
    },
    ignoreHeaders: ["content-length", "host"],
    ignoreQueryParams: [],
    ignoreBody: false,
    bodyMatcher: undefined,
    urlMatcher: undefined,
    requestDecorator: undefined,
    responseDecorator: undefined,
    tapeDecorator: undefined,
    latency: 0,
    errorRate: 0,
    silent: false,
    summary: true,
    debug: false,
    logger: new logger_backend_1.default({})
};
var OptionsFactory = /** @class */ (function () {
    function OptionsFactory() {
    }
    OptionsFactory.prepare = function (usrOpts) {
        if (usrOpts === void 0) { usrOpts = {}; }
        var opts = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, exports.DefaultOptions), { name: usrOpts.host }), usrOpts), { ignoreHeaders: tslib_1.__spreadArrays(exports.DefaultOptions.ignoreHeaders, (usrOpts.ignoreHeaders || [])) });
        this.logger = new logger_backend_1.default(opts);
        opts.logger = this.logger;
        this.validateOptions(opts);
        return opts;
    };
    OptionsFactory.validateOptions = function (opts) {
        this.validateRecord(opts.record);
        this.validateFallbackMode(opts.fallbackMode);
        this.validateLatency(opts.latency);
        this.validateErrorRate(opts.errorRate);
    };
    OptionsFactory.validateRecord = function (record) {
        if (typeof (record) === "string" && !exports.RecordMode.ALL.includes(record)) {
            throw "INVALID OPTION: record has an invalid value of '" + record + "'";
        }
    };
    OptionsFactory.validateFallbackMode = function (fallbackMode) {
        if (typeof (fallbackMode) === "string" && !exports.FallbackMode.ALL.includes(fallbackMode)) {
            throw "INVALID OPTION: fallbackMode has an invalid value of '" + fallbackMode + "'";
        }
    };
    OptionsFactory.validateLatency = function (latency) {
        if (Array.isArray(latency) && latency.length !== 2) {
            throw "Invalid LATENCY option. If using a range, the array should only have 2 values [min, max]. Current=[" + latency + "]";
        }
    };
    OptionsFactory.validateErrorRate = function (errorRate) {
        if (typeof (errorRate) !== "function" && (errorRate < 0 || errorRate > 100)) {
            throw "Invalid ERRORRATE option. Value should be between 0 and 100. Current=[" + errorRate + "]";
        }
    };
    return OptionsFactory;
}());
exports.default = OptionsFactory;
//# sourceMappingURL=options.backend.js.map