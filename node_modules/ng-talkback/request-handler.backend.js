"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var uuid_1 = require("uuid");
var axios_1 = require("axios");
var tape_backend_1 = require("./tape.backend");
var options_backend_1 = require("./options.backend");
var error_rate_backend_1 = require("./features/error-rate.backend");
var latency_backend_1 = require("./features/latency.backend");
var RequestHandler = /** @class */ (function () {
    function RequestHandler(tapeStore, options) {
        this.tapeStore = tapeStore;
        this.options = options;
        this.errorRate = new error_rate_backend_1.default(this.options);
        this.latency = new latency_backend_1.default(this.options);
    }
    RequestHandler.prototype.handle = function (req) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var matchingContext, recordMode, newTape, matchingTape, resObj, responseTape, clonedTape, resTape;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        matchingContext = {
                            id: uuid_1.v4()
                        };
                        recordMode = typeof (this.options.record) === "string" ? this.options.record : this.options.record(req);
                        options_backend_1.default.validateRecord(recordMode);
                        if (this.options.requestDecorator) {
                            req = this.options.requestDecorator(req, matchingContext);
                            if (!req) {
                                throw new Error("requestDecorator didn't return a req object");
                            }
                        }
                        newTape = new tape_backend_1.default(req, this.options);
                        matchingTape = this.tapeStore.find(newTape);
                        if (!(recordMode !== options_backend_1.RecordMode.OVERWRITE && matchingTape)) return [3 /*break*/, 2];
                        responseTape = matchingTape;
                        if (this.errorRate.shouldSimulate(req, matchingTape)) {
                            return [2 /*return*/, this.errorRate.simulate(req)];
                        }
                        return [4 /*yield*/, this.latency.simulate(req, matchingTape)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 7];
                    case 2:
                        if (matchingTape) {
                            responseTape = matchingTape;
                        }
                        else {
                            responseTape = newTape;
                        }
                        if (!(recordMode === options_backend_1.RecordMode.NEW || recordMode === options_backend_1.RecordMode.OVERWRITE)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.makeRealRequest(req)];
                    case 3:
                        resObj = _a.sent();
                        responseTape.res = tslib_1.__assign({}, resObj);
                        if (this.options.tapeDecorator) {
                            responseTape = this.options.tapeDecorator(responseTape, matchingContext);
                            if (!responseTape) {
                                throw new Error("tapeDecorator didn't return a tape object");
                            }
                        }
                        return [4 /*yield*/, this.tapeStore.save(responseTape)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 7];
                    case 5: return [4 /*yield*/, this.onNoRecord(req)];
                    case 6:
                        resObj = _a.sent();
                        responseTape.res = tslib_1.__assign({}, resObj);
                        _a.label = 7;
                    case 7:
                        resObj = responseTape.res;
                        if (!this.options.responseDecorator) return [3 /*break*/, 9];
                        return [4 /*yield*/, responseTape.clone()];
                    case 8:
                        clonedTape = _a.sent();
                        resTape = this.options.responseDecorator(clonedTape, req, matchingContext);
                        if (!resTape) {
                            throw new Error("responseDecorator didn't return a tape object");
                        }
                        if (resTape.res.headers["content-length"]) {
                            resTape.res.headers["content-length"] = resTape.res.body.length;
                        }
                        resObj = resTape.res;
                        _a.label = 9;
                    case 9: return [2 /*return*/, resObj];
                }
            });
        });
    };
    RequestHandler.prototype.onNoRecord = function (req) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var fallbackMode;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fallbackMode = typeof (this.options.fallbackMode) === "string" ? this.options.fallbackMode : this.options.fallbackMode(req);
                        options_backend_1.default.validateFallbackMode(fallbackMode);
                        this.options.logger.log("Tape for " + req.url + " not found and recording is disabled (fallbackMode: " + fallbackMode + ")");
                        this.options.logger.log({
                            url: req.url,
                            headers: req.headers
                        });
                        if (!(fallbackMode === options_backend_1.FallbackMode.PROXY)) return [3 /*break*/, 3];
                        if (this.errorRate.shouldSimulate(req, undefined)) {
                            return [2 /*return*/, this.errorRate.simulate(req)];
                        }
                        return [4 /*yield*/, this.latency.simulate(req, undefined)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.makeRealRequest(req)];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3: return [2 /*return*/, {
                            status: 404,
                            headers: { "content-type": ["text/plain"] },
                            body: Buffer.from("talkback - tape not found")
                        }];
                }
            });
        });
    };
    RequestHandler.prototype.makeRealRequest = function (req) {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var method, url, body, headers, host, urlToGetData, fRes, r, err_1;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        method = req.method, url = req.url, body = req.body;
                        headers = tslib_1.__assign({}, req.headers);
                        delete headers.host;
                        host = this.options.host;
                        urlToGetData = "" + host + url;
                        fRes = {
                            status: 400,
                            headers: {},
                            body: new Buffer('')
                        };
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, axios_1.default({
                                url: urlToGetData,
                                method: method,
                                headers: headers,
                                data: body,
                                responseType: 'arraybuffer',
                            })];
                    case 2:
                        r = _d.sent();
                        fRes = {
                            status: r.status,
                            headers: r.headers,
                            body: r.data
                        };
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _d.sent();
                        fRes = {
                            status: (_a = err_1 === null || err_1 === void 0 ? void 0 : err_1.response) === null || _a === void 0 ? void 0 : _a.status,
                            headers: (_b = err_1 === null || err_1 === void 0 ? void 0 : err_1.response) === null || _b === void 0 ? void 0 : _b.headers,
                            body: (_c = err_1 === null || err_1 === void 0 ? void 0 : err_1.response) === null || _c === void 0 ? void 0 : _c.data
                        };
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, fRes];
                }
            });
        });
    };
    return RequestHandler;
}());
exports.default = RequestHandler;
//# sourceMappingURL=request-handler.backend.js.map