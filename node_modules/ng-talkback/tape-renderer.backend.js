"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var headers_backend_1 = require("./utils/headers.backend");
var media_type_backend_1 = require("./utils/media-type.backend");
var tape_backend_1 = require("./tape.backend");
var content_encoding_backend_1 = require("./utils/content-encoding.backend");
var bufferShim = require("buffer-shims");
// const bufferShim = require('buffer-shims')/
var TapeRenderer = /** @class */ (function () {
    function TapeRenderer(tape) {
        this.tape = tape;
    }
    TapeRenderer.fromStore = function (raw, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var req, _a, tape, baseRes, resBody;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        req = tslib_1.__assign({}, raw.req);
                        _a = req;
                        return [4 /*yield*/, this.prepareBody(raw, req, req.body, "req")];
                    case 1:
                        _a.body = _b.sent();
                        tape = new tape_backend_1.default(req, options);
                        tape.meta = tslib_1.__assign({}, raw.meta);
                        baseRes = tslib_1.__assign({}, raw.res);
                        return [4 /*yield*/, this.prepareBody(tape, baseRes, baseRes.body, "res")];
                    case 2:
                        resBody = _b.sent();
                        tape.res = tslib_1.__assign(tslib_1.__assign({}, baseRes), { body: resBody });
                        return [2 /*return*/, tape];
                }
            });
        });
    };
    TapeRenderer.prepareBody = function (tape, reqResObj, rawBody, metaPrefix) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var contentEncoding, isTapeUncompressed, isTapeHumanReadable, isTapeInPlainText, mediaType, bufferContent, isResAnObject;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        contentEncoding = new content_encoding_backend_1.default(reqResObj);
                        isTapeUncompressed = tape.meta[metaPrefix + "Uncompressed"];
                        isTapeHumanReadable = tape.meta[metaPrefix + "HumanReadable"];
                        isTapeInPlainText = isTapeUncompressed || contentEncoding.isUncompressed();
                        if (!(isTapeHumanReadable && isTapeInPlainText)) return [3 /*break*/, 3];
                        mediaType = new media_type_backend_1.default(reqResObj);
                        bufferContent = rawBody;
                        isResAnObject = typeof (bufferContent) === "object";
                        if (isResAnObject && mediaType.isJSON()) {
                            bufferContent = JSON.stringify(bufferContent, null, 2);
                        }
                        if (headers_backend_1.default.read(reqResObj.headers, "content-length")) {
                            headers_backend_1.default.write(reqResObj.headers, "content-length", Buffer.byteLength(bufferContent).toString(), metaPrefix);
                        }
                        if (!isTapeUncompressed) return [3 /*break*/, 2];
                        return [4 /*yield*/, contentEncoding.compressedBody(bufferContent)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [2 /*return*/, bufferShim.from(bufferContent)];
                    case 3: return [2 /*return*/, bufferShim.from(rawBody, "base64")];
                }
            });
        });
    };
    TapeRenderer.prototype.render = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var reqBody, resBody;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.bodyFor(this.tape.req, "req")];
                    case 1:
                        reqBody = _a.sent();
                        return [4 /*yield*/, this.bodyFor(this.tape.res, "res")];
                    case 2:
                        resBody = _a.sent();
                        return [2 /*return*/, {
                                meta: this.tape.meta,
                                req: tslib_1.__assign(tslib_1.__assign({}, this.tape.req), { body: reqBody }),
                                res: tslib_1.__assign(tslib_1.__assign({}, this.tape.res), { body: resBody })
                            }];
                }
            });
        });
    };
    TapeRenderer.prototype.bodyFor = function (reqResObj, metaPrefix) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var mediaType, contentEncoding, bodyLength, isUncompressed, contentEncodingSupported, body, rawBody, parsed;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mediaType = new media_type_backend_1.default(reqResObj);
                        contentEncoding = new content_encoding_backend_1.default(reqResObj);
                        bodyLength = reqResObj.body.length;
                        isUncompressed = contentEncoding.isUncompressed();
                        contentEncodingSupported = isUncompressed || contentEncoding.supportedAlgorithm();
                        if (!(mediaType.isHumanReadable() && contentEncodingSupported && bodyLength > 0)) return [3 /*break*/, 3];
                        this.tape.meta[metaPrefix + "HumanReadable"] = true;
                        body = reqResObj.body;
                        if (!!isUncompressed) return [3 /*break*/, 2];
                        this.tape.meta[metaPrefix + "Uncompressed"] = true;
                        return [4 /*yield*/, contentEncoding.uncompressedBody(body)];
                    case 1:
                        body = _a.sent();
                        _a.label = 2;
                    case 2:
                        rawBody = body.toString("utf8");
                        if (mediaType.isJSON()) {
                            try { // TODO handle this better in future not based on mediaType.isJSON
                                parsed = JSON.parse(rawBody);
                                return [2 /*return*/, parsed];
                            }
                            catch (error) {
                                return [2 /*return*/, rawBody];
                            }
                        }
                        else {
                            return [2 /*return*/, rawBody];
                        }
                        return [3 /*break*/, 4];
                    case 3: return [2 /*return*/, reqResObj.body.toString("base64")];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    return TapeRenderer;
}());
exports.default = TapeRenderer;
//# sourceMappingURL=tape-renderer.backend.js.map