"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var logger_1 = require("./logger");
var level_1 = require("./level");
var tnp_core_1 = require("tnp-core");
//#endregion
//#region @backend
var randomcolor = require("randomcolor");
var PROCESS_STDOUT_WRITE = 'process.stdout.write';
var PROCESS_STDER_WRITE = 'process.stder.write';
//#endregion
var Log = /** @class */ (function () {
    //#region singleton
    function Log() {
        this._logOnly = false;
        this._logModules = false;
        this.isDevelopmentMode = true;
        this.modeIsSet = false;
        this.fixedWidth = 0;
        this.instances = {};
        this.levels = [];
        this.modules = [];
    }
    Object.defineProperty(Log, "instance", {
        get: function () {
            if (!this._instance) {
                this._instance = new Log();
            }
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    Log.create = function (name) {
        var _a;
        var level = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            level[_i - 1] = arguments[_i];
        }
        return (_a = Log.instance).create.apply(_a, tslib_1.__spreadArrays([name], level));
    };
    Log.disableLogs = function (level) {
        var _this = this;
        if (level === void 0) { level = level_1.Level.__NOTHING; }
        //#region @backend
        // if (Helpers.isNode && (level === Level.__NOTHING)) {
        //   if (!this.consolelogfn[PROCESS_STDOUT_WRITE]) {
        //     this.consolelogfn[PROCESS_STDOUT_WRITE] = process.stdout.write; // TOOD not working
        //   }
        //   process.stdout.write = (() => { }) as any;
        // }
        //#endregion
        level_1.LevelOrder.reverse().find(function (a) {
            if (!_this.consolelogfn[a]) {
                _this.consolelogfn[a] = console[a];
            }
            console[a] = function () { };
            if (a === level_1.LevelKey[level]) {
                return true;
            }
        });
    };
    Log.enableLogs = function () {
        var _this = this;
        //#region @backend
        // if (Helpers.isNode) {
        //   process.stdout.write = this.consolelogfn[PROCESS_STDOUT_WRITE];
        // }
        //#endregion
        level_1.LevelOrder.forEach(function (a) {
            console[a] = _this.consolelogfn[a];
        });
    };
    //#region public api
    Log.prototype.setProductionMode = function () {
        var _this = this;
        if (this.modeIsSet) {
            this.modeIsSet = false;
            throw '[ng2-logger] Production mode is already set';
        }
        else {
            this.modeIsSet = true;
            setTimeout(function () {
                if (_this.modeIsSet && console !== void 0 && console.clear !== void 0) {
                    console.clear();
                    console.log = function () { };
                    console.error = function () { };
                    console.warn = function () { };
                    console.info = function () { };
                }
            });
            this.isDevelopmentMode = false;
        }
    };
    Log.prototype.onlyModules = function () {
        var modules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            modules[_i] = arguments[_i];
        }
        if (this._logModules) {
            throw '[ng2-logger] You should use funcion onlyModules only once';
        }
        if (!this._logModules) {
            this._logModules = true;
        }
        if (modules.length === 0)
            return;
        this.modules = modules;
        // console.log('only log this', Log.modules)
        this.muteAllOtherModules();
    };
    Log.prototype.onlyLevel = function () {
        var level = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            level[_i] = arguments[_i];
        }
        if (this._logOnly) {
            throw '[ng2-logger] You should use funcion onlyLevel only once';
        }
        if (!this._logOnly) {
            this._logOnly = true;
        }
        this.levels = Array.isArray(level) ? level : [level];
        for (var logName in this.instances) {
            if (this.instances.hasOwnProperty(logName)) {
                var element = this.instances[logName];
                element['allowed'] = this.levels;
            }
        }
    };
    //#endregion
    Log.prototype.create = function (name) {
        var level = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            level[_i - 1] = arguments[_i];
        }
        var i;
        if (Array.isArray(this.levels) && this.levels.length > 0) {
            level = this.levels;
        }
        if (this.instances[name] === void 0) {
            i = new (Log.Logger)(name, getRandomColor(), this.isDevelopmentMode, level, this.isMutedModule(name), this.levels.length > 0 ? this.fixedWidth : void 0);
            this.instances[name] = i;
        }
        else {
            i = this.instances[name];
        }
        return i;
    };
    Log.prototype.isMutedModule = function (moduleName) {
        if (this.modules.length == 0)
            return false;
        if (!tnp_core_1.Helpers.contain(this.modules, moduleName))
            return true;
        return false;
    };
    Log.prototype.muteAllOtherModules = function () {
        for (var moduleName in this.instances) {
            if (!tnp_core_1.Helpers.contain(this.modules, moduleName))
                this.instances[moduleName].mute();
        }
    };
    //#endregion
    Log.Logger = logger_1.Logger;
    Log.consolelogfn = {};
    return Log;
}());
exports.Log = Log;
function getRandomColor() {
    //#region @backend
    if (tnp_core_1.Helpers.isNode) {
        return randomcolor({ luminosity: 'light', count: 10 });
    }
    //#endregion
    var letters = '012345'.split('');
    var color = '#';
    color += letters[Math.round(Math.random() * 5)];
    letters = '0123456789ABCDEF'.split('');
    for (var i = 0; i < 5; i++) {
        color += letters[Math.round(Math.random() * 15)];
    }
    if (color === void 0) {
        return getRandomColor();
    }
    ;
    return color;
}
//# sourceMappingURL=log.js.map