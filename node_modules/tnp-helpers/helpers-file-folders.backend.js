"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var tnp_core_1 = require("tnp-core");
var underscore = require("underscore");
var glob = require("glob");
var crypto = require("crypto");
var index_1 = require("./index");
var tnp_config_1 = require("tnp-config");
var HelpersFileFolders = /** @class */ (function () {
    function HelpersFileFolders() {
    }
    /**
     * Calculate file or string checksum
     */
    HelpersFileFolders.prototype.checksum = function (absolutePathToFileOrContent, algorithm) {
        var fileContent = tnp_core_1.path.isAbsolute(absolutePathToFileOrContent)
            ? index_1.Helpers.readFile(absolutePathToFileOrContent)
            : absolutePathToFileOrContent;
        return crypto
            .createHash(algorithm || 'md5')
            .update(fileContent, 'utf8')
            .digest('hex');
    };
    HelpersFileFolders.prototype.getValueFromJSON = function (filepath, lodashGetPath, defaultValue) {
        if (defaultValue === void 0) { defaultValue = void 0; }
        if (!tnp_core_1.fse.existsSync(filepath)) {
            return defaultValue;
        }
        var json = index_1.Helpers.readJson(filepath);
        return tnp_core_1._.get(json, lodashGetPath, defaultValue);
    };
    HelpersFileFolders.prototype.readValueFromJson = function (filepath, lodashGetPath, defaultValue) {
        if (defaultValue === void 0) { defaultValue = void 0; }
        return index_1.Helpers.getValueFromJSON(filepath, lodashGetPath, defaultValue);
    };
    HelpersFileFolders.prototype.setValueToJSON = function (filepath, lodashGetPath, value) {
        if (!tnp_core_1.fse.existsSync(filepath)) {
            index_1.Helpers.error("Not able to set value in json: " + filepath, true, true);
            return;
        }
        var json = index_1.Helpers.readJson(filepath);
        tnp_core_1._.set(json, lodashGetPath, value);
        index_1.Helpers.writeFile(filepath, json);
    };
    /**
     * file size in bytes
     */
    HelpersFileFolders.prototype.size = function (filePath) {
        if (!index_1.Helpers.exists(filePath) || index_1.Helpers.isFolder(filePath)) {
            return null;
        }
        return tnp_core_1.fse.lstatSync(filePath).size;
    };
    HelpersFileFolders.prototype.pathFromLink = function (filePath) {
        return tnp_core_1.fse.readlinkSync(filePath);
    };
    HelpersFileFolders.prototype.renameFolder = function (from, to, cwd) {
        // const command = `mv  ${from}  ${to}`;
        var command = "renamer --find  " + from + "  --replace  " + to + " *";
        index_1.Helpers.run(command, { cwd: cwd }).sync();
    };
    HelpersFileFolders.prototype.getTempFolder = function () {
        var tmp = '/tmp';
        if (process.platform === 'darwin') {
            tmp = '/private/tmp';
        }
        if (process.platform === 'win32') {
            tmp = tnp_core_1.crossPlatformPath(tnp_core_1.path.join(tnp_core_1.crossPlatformPath(tnp_core_1.os.homedir()), '/AppData/Local/Temp'));
        }
        if (!index_1.Helpers.exists(tmp)) {
            index_1.Helpers.mkdirp(tmp);
        }
        return tmp;
    };
    // createMultiplatformLink(target: string, link: string) {
    //   if (this.isPlainFileOrFolder(link)) {
    //     link = path.join(process.cwd(), link);
    //   }
    //   let command: string;
    //   if (os.platform() === 'win32') {
    //     if (target.startsWith('./')) {
    //       target = path.win32.normalize(path.join(process.cwd(), path.basename(target)))
    //     } else {
    //       if (target === '.' || target === './') {
    //         target = path.win32.normalize(path.join(process.cwd(), path.basename(link)))
    //       } else {
    //         target = path.win32.normalize(path.join(target, path.basename(link)))
    //       }
    //     }
    //     if (fse.existsSync(target)) {
    //       fse.unlinkSync(target);
    //     }
    //     target = path.win32.normalize(target)
    //     if (link === '.' || link === './') {
    //       link = process.cwd()
    //     }
    //     link = path.win32.normalize(link);
    //     // if (path.resolve(target) === path.resolve(link)) { // TODO
    //     //   Helpers.warn(`[createMultiplatformLink][win32] Trying to link same location`);
    //     //   return;
    //     // }
    //     command = "mklink \/D "
    //       + target
    //       + " "
    //       + link
    //       + " >nul 2>&1 "
    //   } else {
    //     if (target.startsWith('./')) {
    //       target = target.replace(/^\.\//g, '');
    //     }
    //     if (link === '.' || link === './') {
    //       link = process.cwd()
    //     }
    //     if (path.resolve(target) === path.resolve(link)) {
    //       Helpers.warn(`[createMultiplatformLink] Trying to link same location`);
    //       return;
    //     }
    //     command = `ln -sf "${link}" "${target}"`;
    //   }
    //   child_process.execSync(command);
    // }
    HelpersFileFolders.prototype.isPlainFileOrFolder = function (filePath) {
        return /^([a-zA-Z]|\-|\_|\@|\#|\$|\!|\^|\&|\*|\(|\))+$/.test(filePath);
    };
    HelpersFileFolders.prototype.requireUncached = function (module) {
        delete require.cache[require.resolve(module)];
        return require(module);
    };
    /**
     * get default export object from  js file
     * @param jsFilePath
     */
    HelpersFileFolders.prototype.require = function (jsFilePath) {
        var orgPath = jsFilePath;
        if (!tnp_core_1.fse.existsSync(jsFilePath)) {
            jsFilePath = jsFilePath + ".js";
        }
        if (!tnp_core_1.fse.existsSync(jsFilePath)) {
            index_1.Helpers.error("Not able to find path: " + orgPath);
        }
        var fileContent = tnp_core_1.fse.readFileSync(jsFilePath).toLocaleString();
        (function () {
            var stringForRegex = "require\\((\"|')\\.\\/([a-zA-Z0-9]|\\/|\\-|\\_|\\+|\\.)*(\"|')\\)";
            index_1.Helpers.log("stringForRegex: " + stringForRegex, 1);
            fileContent = fileContent.split('\n').map(function (line) {
                var matches = line.match(new RegExp(stringForRegex));
                if (matches !== null) {
                    // console.log('matched', matches)
                    var rep = tnp_core_1._.first(matches);
                    if (rep) {
                        var newFilename = tnp_core_1.path.join(tnp_core_1.path.dirname(jsFilePath), rep.split('(')[1].replace(/("|'|\))/g, ''));
                        line = line.replace(rep, "require('" + newFilename + "')");
                    }
                    // console.log(line)
                }
                // console.log('matched', matches)
                return line;
            }).join('\n');
        })();
        (function () {
            var stringForRegex = "require\\((\"|')([a-zA-Z0-9]|\\/|\\-|\\_|\\+|\\.)*(\"|')\\)";
            index_1.Helpers.log("stringForRegex: " + stringForRegex);
            fileContent = fileContent.split('\n').map(function (line) {
                // console.log(`LINE: "${line}"`)
                var matches = line.match(new RegExp(stringForRegex));
                if (matches !== null) {
                    // console.log('matched', matches)
                    var rep = tnp_core_1._.first(matches);
                    if (rep) {
                        var relativePart = rep.split('(')[1].replace(/("|'|\))/g, '');
                        // console.log(`RELATIVE PART: "${relativePart}"`)
                        if (relativePart.search('/') !== -1 && !relativePart.startsWith('/')) {
                            var newFilename = tnp_core_1.path.join(tnp_core_1.path.dirname(jsFilePath), 'node_modules', relativePart);
                            line = line.replace(rep, "require('" + newFilename + "')");
                        }
                    }
                    // console.log(line)
                }
                // console.log('matched', matches)
                return line;
            }).join('\n');
        })();
        return eval(fileContent);
    };
    HelpersFileFolders.prototype.tryRecreateDir = function (dirpath) {
        try {
            index_1.Helpers.mkdirp(dirpath);
        }
        catch (error) {
            index_1.Helpers.log("Trying to recreate directory: " + dirpath);
            index_1.Helpers.sleep(1);
            index_1.Helpers.mkdirp(dirpath);
        }
    };
    HelpersFileFolders.prototype.tryCopyFrom = function (source, destination, options) {
        if (options === void 0) { options = {}; }
        index_1.Helpers.log("Trying to copy from: " + source + " to " + destination);
        if (tnp_core_1.fse.existsSync(source) && !tnp_core_1.fse.lstatSync(source).isDirectory()) {
            // Helpers.warn(`[tryCopyFrom] This source is not directory: ${source} to ${destination}`);
            index_1.Helpers.copyFile(source, destination);
            return;
        }
        if (tnp_core_1.fse.existsSync(destination.replace(/\/$/, ''))) {
            var destMaybe = destination.replace(/\/$/, '');
            var stats = tnp_core_1.fse.lstatSync(destMaybe);
            var isNotDirectory = !stats.isDirectory();
            var isSymbolicLink = stats.isSymbolicLink();
            if (isNotDirectory || isSymbolicLink) {
                tnp_core_1.rimraf.sync(destMaybe);
            }
        }
        options = tnp_core_1._.merge({
            overwrite: true,
            recursive: true,
        }, options);
        if (process.platform === 'win32') { // @LAST
            options['dereference'] = true;
        }
        try {
            tnp_core_1.fse.copySync(source, destination, options);
        }
        catch (error) {
            tnp_core_1.rimraf.sync(destination);
            tnp_core_1.fse.copySync(source, destination, options);
        }
    };
    HelpersFileFolders.prototype.removeIfExists = function (absoluteFileOrFolderPath) {
        if (process.platform === 'win32') {
            tnp_core_1.rimraf.sync(absoluteFileOrFolderPath);
            return;
        }
        try {
            tnp_core_1.fse.unlinkSync(absoluteFileOrFolderPath);
        }
        catch (error) { }
        if (tnp_core_1.fse.existsSync(absoluteFileOrFolderPath)) {
            if (tnp_core_1.fse.lstatSync(absoluteFileOrFolderPath).isDirectory()) {
                tnp_core_1.fse.removeSync(absoluteFileOrFolderPath);
            }
            else {
                tnp_core_1.fse.unlinkSync(absoluteFileOrFolderPath);
            }
        }
    };
    HelpersFileFolders.prototype.removeFileIfExists = function (absoluteFilePath, options) {
        if (process.platform === 'win32') {
            tnp_core_1.rimraf.sync(absoluteFilePath);
            return;
        }
        // console.log(`removeFileIfExists: ${absoluteFilePath}`)
        var modifiedFiles = (options || { modifiedFiles: { modifiedFiles: [] } }).modifiedFiles;
        if (tnp_core_1.fse.existsSync(absoluteFilePath)) {
            tnp_core_1.fse.unlinkSync(absoluteFilePath);
            modifiedFiles.modifiedFiles.push(absoluteFilePath);
        }
    };
    HelpersFileFolders.prototype.removeFolderIfExists = function (absoluteFolderPath, options) {
        index_1.Helpers.log("[helpers] Remove folder: " + absoluteFolderPath);
        if (process.platform === 'win32') {
            tnp_core_1.rimraf.sync(absoluteFolderPath);
            return;
        }
        var modifiedFiles = (options || { modifiedFiles: { modifiedFiles: [] } }).modifiedFiles;
        if (tnp_core_1.fse.existsSync(absoluteFolderPath)) {
            tnp_core_1.fse.removeSync(absoluteFolderPath);
            modifiedFiles.modifiedFiles.push(absoluteFolderPath);
        }
    };
    // private deleteFolderRecursive = (pathToFolder) => {
    //   if (fs.existsSync(pathToFolder)) {
    //     fs.readdirSync(pathToFolder).forEach((file, index) => {
    //       const curPath = path.join(pathToFolder, file);
    //       if (fs.lstatSync(curPath).isDirectory()) { // recurse
    //         this.deleteFolderRecursive(curPath);
    //       } else { // delete file
    //         fs.unlinkSync(curPath);
    //       }
    //     });
    //     fs.rmdirSync(pathToFolder);
    //   }
    // };
    HelpersFileFolders.prototype.tryRemoveDir = function (dirpath, contentOnly) {
        if (contentOnly === void 0) { contentOnly = false; }
        if (!tnp_core_1.fse.existsSync(dirpath)) {
            console.warn("Folder " + tnp_core_1.path.basename(dirpath) + " doesn't exist.");
            return;
        }
        index_1.Helpers.log("[tnp-helpers][tryRemoveDir]: " + dirpath);
        // if (dirpath == '/Users/dfilipiak/projects/npm/firedev-projects/container-v2/workspace-v2') {
        //   console.trace('aaaaaaaa')
        //   process.exit(0)
        // }
        try {
            if (contentOnly) {
                tnp_core_1.rimraf.sync(dirpath + "/*");
            }
            else {
                tnp_core_1.rimraf.sync(dirpath);
            }
            return;
        }
        catch (e) {
            index_1.Helpers.log("Trying to remove directory: " + dirpath);
            index_1.Helpers.sleep(1);
            index_1.Helpers.tryRemoveDir(dirpath, contentOnly);
        }
    };
    HelpersFileFolders.prototype.move = function (from, to) {
        if (!tnp_core_1.fse.existsSync(from)) {
            index_1.Helpers.warn("[move] File or folder doesnt not exists: " + from);
            return;
        }
        if (!tnp_core_1.path.isAbsolute(from)) {
            index_1.Helpers.warn("[move] Source path is not absolute: " + from);
            return;
        }
        if (!tnp_core_1.path.isAbsolute(to)) {
            index_1.Helpers.warn("[move] Destination path is not absolute: " + to);
            return;
        }
        tnp_core_1.fse.moveSync(from, to, {
            overwrite: true
        });
    };
    HelpersFileFolders.prototype.remove = function (fileOrFolderPathOrPatter, exactFolder) {
        if (exactFolder === void 0) { exactFolder = false; }
        index_1.Helpers.log("[tnp-helpers][remove]: " + fileOrFolderPathOrPatter);
        if (exactFolder) {
            tnp_core_1.rimraf.sync(fileOrFolderPathOrPatter, { glob: false, disableGlob: true, });
            return;
        }
        tnp_core_1.rimraf.sync(fileOrFolderPathOrPatter);
    };
    HelpersFileFolders.prototype.findChildren = function (location, createFn) {
        var notAllowed = tslib_1.__spreadArrays([
            '\.vscode', 'node\_modules'
        ], tnp_core_1._.values(tnp_config_1.config.folder), [
            'e2e', 'tmp.*', 'dist.*', 'tests', 'module', 'browser', 'bundle*',
            'components', '\.git', 'bin', 'custom'
        ]).map(function (s) { return new RegExp(s); });
        var isDirectory = function (source) { return tnp_core_1.fse.lstatSync(source).isDirectory(); };
        var getDirectories = function (source) {
            return tnp_core_1.fse.readdirSync(source).map(function (name) { return tnp_core_1.path.join(source, name); }).filter(isDirectory);
        };
        var subdirectories = getDirectories(location)
            .filter(function (f) {
            var folderNam = tnp_core_1.path.basename(f);
            return (notAllowed.filter(function (p) { return p.test(folderNam); }).length === 0);
        });
        return subdirectories
            .map(function (dir) {
            // console.log('child:', dir)
            return createFn(dir);
        })
            .filter(function (c) { return !!c; });
    };
    HelpersFileFolders.prototype.findChildrenNavi = function (location, createFn) {
        if (!tnp_core_1.fse.existsSync(location)) {
            return [];
        }
        var notAllowed = tslib_1.__spreadArrays([
            '\.vscode', 'node\_modules'
        ], tnp_core_1._.values(tnp_config_1.config.folder), [
            'e2e', 'tmp.*', 'dist.*', 'tests',
            'module', 'browser', 'bundle*',
            'components', '\.git', '\.build', 'bin', 'custom'
        ]).map(function (s) { return new RegExp(s); });
        var isDirectory = function (source) { return tnp_core_1.fse.lstatSync(source).isDirectory(); };
        var getDirectories = function (source) {
            return tnp_core_1.fse.readdirSync(source).map(function (name) { return tnp_core_1.path.join(source, name); }).filter(isDirectory);
        };
        var subdirectories = getDirectories(location)
            .filter(function (f) {
            var folderName = tnp_core_1.path.basename(f);
            if (/.*es\-.*/.test(folderName)) {
                return true;
            }
            return (notAllowed.filter(function (p) { return p.test(folderName); }).length === 0);
        });
        return subdirectories
            .map(function (dir) {
            return createFn(dir);
        })
            .filter(function (c) { return !!c; });
    };
    HelpersFileFolders.prototype.getRecrusiveFilesFrom = function (dir) {
        var files = [];
        var readed = tnp_core_1.fse.readdirSync(dir).map(function (f) {
            var fullPath = tnp_core_1.path.join(dir, f);
            // console.log(`is direcotry ${fse.lstatSync(fullPath).isDirectory()} `, fullPath)
            if (tnp_core_1.fse.lstatSync(fullPath).isDirectory()) {
                index_1.Helpers.getRecrusiveFilesFrom(fullPath).forEach(function (aa) { return files.push(aa); });
            }
            return fullPath;
        });
        if (Array.isArray(readed)) {
            readed.forEach(function (r) { return files.push(r); });
        }
        return files;
    };
    HelpersFileFolders.prototype.getLinesFromFiles = function (filename, lineCount) {
        return new Promise(function (resolve, reject) {
            var stream = tnp_core_1.fse.createReadStream(filename, {
                flags: 'r',
                encoding: 'utf-8',
                fd: null,
                mode: 438,
            });
            var data = '';
            var lines = [];
            stream.on('data', function (moreData) {
                data += moreData;
                lines = data.split('\n');
                // probably that last line is "corrupt" - halfway read - why > not >=
                if (lines.length > lineCount + 1) {
                    stream.destroy();
                    lines = lines.slice(0, lineCount); // junk as above
                    resolve(lines);
                }
            });
            stream.on('error', function () {
                reject("Error reading " + filename);
            });
            stream.on('end', function () {
                resolve(lines);
            });
        });
    };
    ;
    /**
     * Get the most recent changes file in direcory
     * @param dir absoulute path to file
     */
    HelpersFileFolders.prototype.getMostRecentFileName = function (dir) {
        var files = index_1.Helpers.getRecrusiveFilesFrom(dir);
        // use underscore for max()
        return underscore.max(files, function (f) {
            // console.log(f);
            // ctime = creation time is used
            // replace with mtime for modification time
            // console.log( `${fse.statSync(f).mtimeMs} for ${f}`   )
            return tnp_core_1.fse.statSync(f).mtimeMs;
        });
    };
    HelpersFileFolders.prototype.getMostRecentFilesNames = function (dir) {
        var allFiles = index_1.Helpers.getRecrusiveFilesFrom(dir);
        var mrf = index_1.Helpers.getMostRecentFileName(dir);
        var mfrMtime = tnp_core_1.fse.lstatSync(mrf).mtimeMs;
        return allFiles.filter(function (f) {
            var info = tnp_core_1.fse.lstatSync(f);
            return (info.mtimeMs === mfrMtime && !info.isDirectory());
        });
    };
    HelpersFileFolders.prototype.removeExcept = function (fromPath, exceptFolderAndFiles) {
        tnp_core_1.fse.readdirSync(fromPath)
            .filter(function (f) {
            return !exceptFolderAndFiles.includes(f);
        })
            .map(function (f) { return tnp_core_1.path.join(fromPath, f); })
            .forEach(function (af) { return index_1.Helpers.removeFolderIfExists(af); });
        (glob.sync(fromPath + "/*.*"))
            .filter(function (f) {
            return !exceptFolderAndFiles.includes(tnp_core_1.path.basename(f));
        })
            .forEach(function (af) { return index_1.Helpers.removeFileIfExists(af); });
    };
    HelpersFileFolders.prototype.copy = function (sourceDir, destinationDir, options) {
        // sourceDir = sourceDir ? (sourceDir.replace(/\/$/, '')) : sourceDir;
        // destinationDir = destinationDir ? (destinationDir.replace(/\/$/, '')) : destinationDir;
        if (!tnp_core_1.fse.existsSync(sourceDir)) {
            index_1.Helpers.warn("[helper][copy] Source dir doesnt exist: " + sourceDir + " for destination: " + destinationDir);
            return;
        }
        if (!tnp_core_1.fse.existsSync(tnp_core_1.path.dirname(destinationDir))) {
            index_1.Helpers.mkdirp(tnp_core_1.path.dirname(destinationDir));
        }
        if (!options) {
            options = {};
        }
        if (tnp_core_1._.isUndefined(options.overwrite)) {
            options.overwrite = true;
        }
        if (tnp_core_1._.isUndefined(options.recursive)) {
            options.recursive = true;
        }
        if (tnp_core_1._.isUndefined(options.useTempFolder)) {
            options.useTempFolder = false;
        }
        if (options.copySymlinksAsFiles) {
            options['dereference'] = true;
        }
        // const [srcStat, destStat] = [
        //   fse.existsSync(sourceDir) && fse.statSync(sourceDir),
        //   fse.existsSync(destinationDir) && fse.statSync(destinationDir),
        // ];
        // if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        //   Helpers.warn(`[helper][copy] Same location stats.. Trying to copy same source and destination:
        //   from: ${sourceDir}
        //   to: ${destinationDir}
        //   `);
        //   return;
        // }
        if (tnp_core_1._.isArray(options.omitFolders) && options.omitFolders.length >= 1
            && tnp_core_1._.isNil(options.filter) && tnp_core_1._.isString(options.omitFoldersBaseFolder)
            && tnp_core_1.path.isAbsolute(options.omitFoldersBaseFolder)) {
            options.filter = function (src) {
                // console.log('src',src)
                var baseFolder = tnp_core_1._.first(src.replace(options.omitFoldersBaseFolder, '')
                    .replace(/^\//, '').split('/'));
                if (!baseFolder || baseFolder.trim() === '') {
                    return true;
                }
                var isAllowed = tnp_core_1._.isUndefined(options.omitFolders.find(function (f) { return baseFolder.startsWith(f); }));
                return isAllowed;
            };
        }
        if (sourceDir === destinationDir || tnp_core_1.path.resolve(sourceDir) === tnp_core_1.path.resolve(destinationDir)) {
            index_1.Helpers.warn("[helper][copy] Trying to copy same source and destination\n      from: " + sourceDir + "\n      to: " + destinationDir + "\n      ");
        }
        else {
            // console.warn('filter', _.isFunction(options.filter));
            // console.warn('sourceDir', sourceDir);
            // console.warn('destinationDir', destinationDir);
            // console.log(JSON.stringify(options))
            // try {
            if (options.useTempFolder) {
                var tempDestination = (tnp_core_1.os.platform() === 'darwin' ? '/private/tmp' : '/tmp') + "/" + tnp_core_1._.camelCase(destinationDir);
                index_1.Helpers.removeFolderIfExists(tempDestination);
                tnp_core_1.fse.copySync(sourceDir, tempDestination, options);
                tnp_core_1.fse.copySync(tempDestination, destinationDir, options);
            }
            else {
                if ((sourceDir === tnp_core_1.path.resolve(sourceDir)) && index_1.Helpers.isLink(sourceDir) && !index_1.Helpers.exists(tnp_core_1.fse.readlinkSync(sourceDir))) {
                    index_1.Helpers.warn("[tnp-helpers] Not copying empty link from: " + sourceDir + "\n          ");
                }
                else {
                    tnp_core_1.fse.copySync(sourceDir, destinationDir, options);
                }
            }
            // } catch (error) {
            //   console.trace(error);
            //   process.exit(0)
            // }
        }
    };
    HelpersFileFolders.prototype.copyFile = function (sourcePath, destinationPath, options) {
        if (tnp_core_1._.isUndefined(options)) {
            options = {};
        }
        if (tnp_core_1._.isUndefined(options.debugMode)) {
            options.debugMode = false;
        }
        if (tnp_core_1._.isUndefined(options.debugMode)) {
            options.fast = true;
        }
        if (tnp_core_1._.isUndefined(options.dontCopySameContent)) {
            options.dontCopySameContent = true;
        }
        var debugMode = options.debugMode, fast = options.fast, transformTextFn = options.transformTextFn, dontCopySameContent = options.dontCopySameContent, modifiedFiles = options.modifiedFiles;
        if (tnp_core_1._.isFunction(transformTextFn) && fast) {
            index_1.Helpers.error("[copyFile] You cannot use  transformTextFn in fast mode");
        }
        if (!tnp_core_1.fse.existsSync(sourcePath)) {
            index_1.Helpers.warn("[copyFile] No able to find source of " + sourcePath, true);
            return false;
        }
        if (tnp_core_1.fse.lstatSync(sourcePath).isDirectory()) {
            index_1.Helpers.warn("[copyFile] Trying to copy directory as file: " + sourcePath, false);
            return false;
        }
        if (sourcePath === destinationPath) {
            index_1.Helpers.warn("[copyFile] Trying to copy same file " + sourcePath);
            return false;
        }
        var destDirPath = tnp_core_1.path.dirname(destinationPath);
        debugMode && index_1.Helpers.log("[copyFile] destDirPath: " + destDirPath);
        if (!tnp_core_1.fse.existsSync(destDirPath)) {
            index_1.Helpers.mkdirp(destDirPath);
        }
        if (dontCopySameContent && tnp_core_1.fse.existsSync(destinationPath)) {
            var destinationContent = index_1.Helpers.readFile(destinationPath);
            var sourceContent = index_1.Helpers.readFile(sourcePath).toString();
            if (destinationContent === sourceContent) {
                // @REMEMBER uncomment if any problem
                // Helpers.log(`Destination has the same content as source: ${path.basename(sourcePath)}`);
                return false;
            }
        }
        debugMode && index_1.Helpers.log("path.extname(sourcePath) " + tnp_core_1.path.extname(sourcePath));
        if (fast || !tnp_config_1.config.extensions.modificableByReplaceFn.includes(tnp_core_1.path.extname(sourcePath))) {
            tnp_core_1.fse.copyFileSync(sourcePath, destinationPath);
        }
        else {
            var sourceData = index_1.Helpers.readFile(sourcePath).toString();
            if (tnp_core_1._.isFunction(transformTextFn)) {
                sourceData = transformTextFn(sourceData);
            }
            debugMode && index_1.Helpers.log("\n[copyFile] Write to: " + destinationPath + " file:\n============================================================================================\n" + sourceData + "\n============================================================================================\n        ");
            index_1.Helpers.writeFile(destinationPath, sourceData);
        }
        if (modifiedFiles && tnp_core_1._.isArray(modifiedFiles.modifiedFiles)) {
            modifiedFiles.modifiedFiles.push(destinationPath);
        }
        return true;
    };
    /**
     * get real absolute path
     */
    HelpersFileFolders.prototype.resolve = function (fileOrFolderPath) {
        if (fileOrFolderPath.startsWith('~')) {
            fileOrFolderPath = tnp_core_1.path.join(tnp_core_1.os.homedir(), fileOrFolderPath.replace("~/", ''));
        }
        return tnp_core_1.path.resolve(fileOrFolderPath);
    };
    return HelpersFileFolders;
}());
exports.HelpersFileFolders = HelpersFileFolders;
//# sourceMappingURL=helpers-file-folders.backend.js.map