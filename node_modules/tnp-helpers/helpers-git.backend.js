"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
//#region imports
var tnp_core_1 = require("tnp-core");
var tnp_cli_1 = require("tnp-cli");
var index_1 = require("./index");
//#endregion
var HelpersGit = /** @class */ (function () {
    function HelpersGit() {
    }
    //#region get last commit hash
    HelpersGit.prototype.lastCommitHash = function (directoryPath) {
        try {
            var cwd = directoryPath;
            var hash = tnp_core_1.child_process.execSync("git rev-parse HEAD &> /dev/null && git log -1 --format=\"%H\"", { cwd: cwd }).toString().trim();
            return hash;
        }
        catch (e) {
            index_1.Helpers.log(e, 1);
            index_1.Helpers.log("[lastCommitHash] Not able to get last commit hash for repository in " + directoryPath, 1);
            return null;
        }
    };
    //#endregion
    //#region get penultimate commit hash
    HelpersGit.prototype.penultimageCommitHash = function (directoryPath) {
        try {
            var cwd = directoryPath;
            var hash = tnp_core_1.child_process.execSync("git rev-parse HEAD &> /dev/null && git log -2 --format=\"%H\"", { cwd: cwd }).toString().trim();
            return hash;
        }
        catch (e) {
            index_1.Helpers.log(e, 1);
            index_1.Helpers.log("[lastCommitHash] Not able to get last commit hash for repository in " + directoryPath, 1);
            return null;
        }
    };
    //#endregion
    //#region get last tag hash
    HelpersGit.prototype.lastTagHash = function (directoryPath) {
        try {
            var cwd = directoryPath;
            var tag = tnp_core_1.child_process.execSync("git describe --tags $(git rev-list --tags --max-count=1)", { cwd: cwd }).toString().trim();
            var hash = tnp_core_1.child_process.execSync("git log -1 --format=format:\"%H\" " + tag, { cwd: cwd }).toString().trim();
            return hash;
        }
        catch (e) {
            index_1.Helpers.log(e, 1);
            index_1.Helpers.log("[lastCommitHash] Not able to get last commit hash for repository in " + directoryPath, 1);
            return null;
        }
    };
    //#endregion
    //#region get last commit date
    HelpersGit.prototype.lastCommitDate = function (directoryPath) {
        try {
            var cwd = directoryPath;
            var unixTimestamp = tnp_core_1.child_process.execSync("git rev-parse HEAD &> /dev/null && git log -1 --pretty=format:%ct", { cwd: cwd }).toString().trim();
            return new Date(Number(unixTimestamp) * 1000);
        }
        catch (e) {
            index_1.Helpers.log(e, 1);
            index_1.Helpers.log("[lastCommitDate] Cannot counts commits in branch in: " + directoryPath, 1);
            return null;
        }
    };
    //#endregion
    //#region get number of commit in repository
    HelpersGit.prototype.countCommits = function (cwd) {
        try {
            // git rev-parse HEAD &> /dev/null check if any commits
            var currentLocalBranch = tnp_core_1.child_process.execSync("git branch | sed -n '/* /s///p'", { cwd: cwd }).toString().trim();
            var value = tnp_core_1.child_process.execSync("git rev-parse HEAD &> /dev/null && git rev-list --count " + currentLocalBranch, { cwd: cwd }).toString().trim();
            return Number(value);
        }
        catch (e) {
            index_1.Helpers.log(e, 1);
            index_1.Helpers.log("[countCommits] Cannot counts commits in branch in: " + cwd, 1);
            return 0;
        }
    };
    //#endregion
    //#region get current branch name
    HelpersGit.prototype.currentBranchName = function (cwd) {
        try {
            var branchName = tnp_core_1.child_process.execSync("git branch | sed -n '/* /s///p'", { cwd: cwd }).toString().trim();
            return branchName;
        }
        catch (e) {
            index_1.Helpers.error(e);
        }
    };
    //#endregion
    //#region commit "what is"
    HelpersGit.prototype.commitWhatIs = function (customMessage) {
        if (customMessage === void 0) { customMessage = 'changes'; }
        try {
            index_1.Helpers.run("git add --all . ").sync();
        }
        catch (error) {
            index_1.Helpers.warn("Failed to git add --all .");
        }
        try {
            index_1.Helpers.run("git commit -m \"" + customMessage + "\"").sync();
        }
        catch (error) {
            index_1.Helpers.warn("Failed to git commit -m \"" + customMessage + "\"");
        }
    };
    //#endregion
    //#region commit
    HelpersGit.prototype.commit = function (cwd, ProjectClass, args) {
        if (!tnp_core_1._.isString(args)) {
            args = 'update';
        }
        var gitRootProject = ProjectClass.nearestTo(cwd, { findGitRoot: true });
        try {
            index_1.Helpers.info("[git][commit] Adding current git changes in git root:\n        " + gitRootProject.location + "\n        ");
            gitRootProject.run("git add --all . ").sync();
        }
        catch (error) {
            index_1.Helpers.warn("Failed to 'git add --all .' in:\n        " + gitRootProject.location);
        }
        if (args.search('-m') === -1 && args.search('-msg') === -1) {
            var addBrackets = !((args.startsWith('\'') ||
                args.startsWith('"')) &&
                (args.endsWith('\'') ||
                    args.endsWith('"')));
            args = "-m " + (addBrackets ? "\"" + args + "\"" : args);
        }
        try {
            index_1.Helpers.info("[git][commit] trying to commit what it with argument:\n      \"" + args + "\"\n      location: " + cwd + "\n      ");
            index_1.Helpers.run("git commit --no-verify " + args, { cwd: cwd }).sync();
        }
        catch (error) {
            index_1.Helpers.warn("[git][commit] not able to commit what is");
        }
    };
    //#endregion
    //#region get remote origin
    HelpersGit.prototype.getOriginURL = function (cwd) {
        var url = '';
        try {
            // git config --get remote.origin.url
            url = index_1.Helpers.run("git config --get remote.origin.url", { output: false, cwd: cwd }).sync().toString().trim();
        }
        catch (error) {
        }
        return url;
    };
    //#endregion
    //#region is git root
    HelpersGit.prototype.isGitRoot = function (cwd) {
        return tnp_core_1.fse.existsSync(tnp_core_1.path.join(cwd, '.git'));
    };
    //#endregion
    //#region is git repo
    HelpersGit.prototype.isGitRepo = function (cwd) {
        try {
            var test = index_1.Helpers.run('git rev-parse --is-inside-work-tree', {
                biggerBuffer: false,
                cwd: cwd,
                output: false
            }).sync();
        }
        catch (e) {
            return false;
        }
        return !!test;
    };
    //#endregion
    HelpersGit.prototype.pull = function (branchName, cwd) {
        if (branchName === void 0) { branchName = 'master'; }
        if (cwd === void 0) { cwd = tnp_core_1.crossPlatformPath(process.cwd()); }
        tnp_core_1.child_process.execSync("git pull --ff-only origin " + branchName, { cwd: cwd });
    };
    //#region pull current branch
    HelpersGit.prototype.pullBranch = function (branchName, directoryPath, askToRetry) {
        if (askToRetry === void 0) { askToRetry = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cwd, e_1;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.getOriginURL(directoryPath) === '') {
                            index_1.Helpers.warn("Not pulling branch without "
                                + ("remote origin url.... in folder " + tnp_core_1.path.basename(directoryPath)));
                            return [2 /*return*/];
                        }
                        index_1.Helpers.info("Pulling git changes in \"" + directoryPath + "\" ");
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 2, , 5]);
                        cwd = directoryPath;
                        index_1.Helpers.git.pull(branchName, cwd);
                        index_1.Helpers.info("Branch \"" + branchName + "\" updated successfully in " + tnp_core_1.path.basename(directoryPath));
                        return [3 /*break*/, 5];
                    case 2:
                        e_1 = _a.sent();
                        // console.log(e)
                        index_1.Helpers.error("Cannot update current branch in: " + directoryPath, askToRetry, true);
                        if (!askToRetry) return [3 /*break*/, 4];
                        return [4 /*yield*/, index_1.Helpers.questionYesNo("Do you wanna try again ?", function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, index_1.Helpers.git.pullCurrentBranch(directoryPath, askToRetry)];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); }, function () {
                                process.exit(0);
                            })];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    //#endregion
    //#region pull current branch
    HelpersGit.prototype.pullCurrentBranch = function (directoryPath, askToRetry) {
        if (askToRetry === void 0) { askToRetry = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cwd, currentLocalBranch, e_2;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.getOriginURL(directoryPath) === '') {
                            index_1.Helpers.warn("Not pulling branch without "
                                + ("remote origin url.... in folder " + tnp_core_1.path.basename(directoryPath)));
                            return [2 /*return*/];
                        }
                        index_1.Helpers.info("Pulling git changes in \"" + directoryPath + "\" ");
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 2, , 5]);
                        cwd = directoryPath;
                        currentLocalBranch = tnp_core_1.child_process.execSync("git branch | sed -n '/* /s///p'", { cwd: cwd }).toString().trim();
                        index_1.Helpers.git.pull(currentLocalBranch, cwd);
                        index_1.Helpers.info("Branch \"" + currentLocalBranch + "\" updated successfully in " + tnp_core_1.path.basename(directoryPath));
                        return [3 /*break*/, 5];
                    case 2:
                        e_2 = _a.sent();
                        // console.log(e)
                        index_1.Helpers.error("Cannot update current branch in: " + directoryPath, askToRetry, true);
                        if (!askToRetry) return [3 /*break*/, 4];
                        return [4 /*yield*/, index_1.Helpers.questionYesNo("Do you wanna try again ?", function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, index_1.Helpers.git.pullCurrentBranch(directoryPath, askToRetry)];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); }, function () {
                                process.exit(0);
                            })];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    //#endregion
    //#region push current branch
    HelpersGit.prototype.pushCurrentBranch = function (cwd, force) {
        if (force === void 0) { force = false; }
        var currentBranchName = index_1.Helpers.git.currentBranchName(cwd);
        while (true) {
            try {
                index_1.Helpers.info("[git][push] " + (force ? 'force' : '') + " pushing current branch " + currentBranchName);
                index_1.Helpers.run("git push " + (force ? '-f' : '') + " origin " + currentBranchName, { cwd: cwd }).sync();
                break;
            }
            catch (err) {
                index_1.Helpers.error("Not able to push branch " + currentBranchName + " in:\n        " + cwd, false, true);
                index_1.Helpers.pressKeyAndContinue("Press any key to try again: ");
                continue;
            }
        }
    };
    //#endregion
    //#region get default branch for repo
    HelpersGit.prototype.defaultRepoBranch = function (cwd) {
        try {
            var defaultBranch = tnp_core_1.child_process
                .execSync("git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'", { cwd: cwd })
                .toString().trim();
            return defaultBranch;
        }
        catch (e) {
            console.log(e);
            index_1.Helpers.error("Cannot find default branch for repo in : " + cwd);
        }
    };
    //#endregion
    //#region checkout default branch
    HelpersGit.prototype.checkoutDefaultBranch = function (directoryPath) {
        var cwd = directoryPath;
        var defaultBranch = tnp_core_1.child_process
            .execSync("git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'", { cwd: cwd })
            .toString().trim();
        tnp_core_1.child_process.execSync("git checkout " + defaultBranch, { cwd: cwd });
    };
    //#endregion
    //#region clone
    HelpersGit.prototype.clone = function (_a) {
        var cwd = _a.cwd, url = _a.url, _b = _a.destinationFolderName, destinationFolderName = _b === void 0 ? '' : _b, throwErrors = _a.throwErrors, override = _a.override;
        var _c, _d;
        var ALWAYS_HTTPS = true;
        if (!url.endsWith('.git')) {
            url = (url + '.git');
        }
        if (ALWAYS_HTTPS) {
            if (!url.startsWith('https://')) {
                var _e = url.split(':'), serverPart = _e[0], pathPart = _e[1];
                var server = (serverPart || '').replace('git@', '');
                url = "https://" + server + "/" + pathPart;
            }
        }
        var cloneFolderName = tnp_core_1.path.join(cwd, (!!destinationFolderName && destinationFolderName.trim() !== '') ? destinationFolderName : tnp_core_1.path.basename(url));
        if (override) {
            index_1.Helpers.remove(cloneFolderName);
        }
        else if (index_1.Helpers.exists(cloneFolderName) && index_1.Helpers.exists(tnp_core_1.path.join(cloneFolderName, '.git'))) {
            index_1.Helpers.warn("Alread cloned " + tnp_core_1.path.basename(cloneFolderName) + "...");
            return;
        }
        var commnad = "git -c http.sslVerify=false clone " + url + " " + destinationFolderName;
        index_1.Helpers.info("\n\n    Cloning:\n    " + commnad + "\n\n    ");
        if (throwErrors) {
            index_1.Helpers.run(commnad, { cwd: cwd }).sync();
        }
        else {
            try {
                index_1.Helpers.run(commnad, { cwd: cwd, output: false }).sync();
            }
            catch (error) {
                if (((_d = (_c = error === null || error === void 0 ? void 0 : error.stderr) === null || _c === void 0 ? void 0 : _c.toString()) === null || _d === void 0 ? void 0 : _d.search('remote: Not Found')) !== -1) {
                    index_1.Helpers.warn("[tnp-helpers][git] Project not found :" + url);
                }
                else {
                    index_1.Helpers.error("Can't clone from url: " + tnp_cli_1.CLI.chalk.bold(url) + "..", false, true);
                }
            }
        }
    };
    //#endregion
    //#region check if there are some uncommited changes
    HelpersGit.prototype.checkIfthereAreSomeUncommitedChange = function (cwd) {
        try {
            return index_1.Helpers.run("git diff --name-only", { output: false, cwd: cwd }).sync().toString().trim() !== '';
        }
        catch (error) {
            return true;
        }
    };
    //#endregion
    //#region restore last version
    HelpersGit.prototype.restoreLastVersion = function (cwd, localFilePath) {
        try {
            index_1.Helpers.info("[git] restoring last verion of file " + tnp_core_1.path.basename(cwd) + "/" + localFilePath);
            index_1.Helpers.run("git checkout -- " + localFilePath, { cwd: cwd }).sync();
        }
        catch (error) {
            index_1.Helpers.warn("[tnp-git] Not able to resotre last version of file " + localFilePath);
        }
    };
    //#endregion
    //#region reset files
    HelpersGit.prototype.resetFiles = function (cwd) {
        var relativePathes = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            relativePathes[_i - 1] = arguments[_i];
        }
        relativePathes.forEach(function (p) {
            try {
                index_1.Helpers.run("git checkout HEAD -- " + p, { cwd: cwd }).sync();
            }
            catch (err) {
                index_1.Helpers.error("[project.git] Not able to reset files: " + p + " inside project " + tnp_core_1.path.basename(cwd) + ".", true, true);
            }
        });
    };
    return HelpersGit;
}());
exports.HelpersGit = HelpersGit;
//# sourceMappingURL=helpers-git.backend.js.map