"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var tnp_core_1 = require("tnp-core");
var project_1 = require("./project");
var helpers_1 = require("./helpers");
//#region @backend
var tnp_cli_1 = require("tnp-cli");
//#endregion
var Helpers = helpers_1.HelpersTnp.Instance;
var ProjectGit = /** @class */ (function () {
    function ProjectGit() {
    }
    //#region @backend
    ProjectGit.prototype.runCommandGetString = function (command) {
        return Helpers.commnadOutputAsString(command, this.location, false);
    };
    ProjectGit.prototype.run = function (command, options) {
        if (!options) {
            options = {};
        }
        if (tnp_core_1._.isUndefined(options.showCommand)) {
            options.showCommand = false;
        }
        if (!options.cwd) {
            options.cwd = this.location;
        }
        if (options.showCommand) {
            Helpers.info("[" + tnp_cli_1.CLI.chalk.underline('Executing shell command') + "]  \"" + command + "\" in [" + options.cwd + "]");
        }
        return Helpers.run(command, options);
    };
    Object.defineProperty(ProjectGit.prototype, "git", {
        //#endregion
        //#region @backend
        // @ts-ignore
        get: function () {
            var self = this;
            return {
                clone: function (url, destinationFolderName) {
                    if (destinationFolderName === void 0) { destinationFolderName = ''; }
                    return Helpers.git.clone({ cwd: self.location, url: url, destinationFolderName: destinationFolderName });
                },
                restoreLastVersion: function (localFilePath) {
                    return Helpers.git.restoreLastVersion(self.location, localFilePath);
                },
                resetFiles: function () {
                    var _a;
                    var relativePathes = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        relativePathes[_i] = arguments[_i];
                    }
                    return (_a = Helpers.git).resetFiles.apply(_a, tslib_1.__spreadArrays([self.location], relativePathes));
                },
                get isGitRepo() {
                    return Helpers.git.isGitRepo(self.location);
                },
                get isGitRoot() {
                    return Helpers.git.isGitRoot(self.location);
                },
                get originURL() {
                    return Helpers.git.getOriginURL(self.location);
                },
                updateOrigin: function (askToRetry) {
                    if (askToRetry === void 0) { askToRetry = false; }
                    return tslib_1.__awaiter(this, void 0, void 0, function () {
                        return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, Helpers.git.pullCurrentBranch(self.location, askToRetry)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                },
                commit: function (args) {
                    return Helpers.git.commit(self.location, project_1.Project, args);
                },
                pushCurrentBranch: function (force) {
                    if (force === void 0) { force = false; }
                    return Helpers.git.pushCurrentBranch(self.location, force);
                },
                get thereAreSomeUncommitedChange() {
                    return Helpers.git.checkIfthereAreSomeUncommitedChange(self.location);
                },
                pullCurrentBranch: function () {
                    return Helpers.git.pullCurrentBranch(self.location);
                },
                get currentBranchName() {
                    return Helpers.git.currentBranchName(self.location);
                },
                resetHard: function () {
                    self.run("git reset --hard").sync();
                },
                countComits: function () {
                    return Helpers.git.countCommits(self.location);
                },
                lastCommitDate: function () {
                    return Helpers.git.lastCommitDate(self.location);
                },
                lastCommitHash: function () {
                    return Helpers.git.lastCommitHash(self.location);
                },
                penultimageCommitHash: function () {
                    return Helpers.git.penultimageCommitHash(self.location);
                },
                lastTagHash: function () {
                    return Helpers.git.lastTagHash(self.location);
                },
                /**
                 * TODO does this make any sense
                 */
                renameOrigin: function (newNameOrUlr) {
                    if (!newNameOrUlr.endsWith('.git')) {
                        newNameOrUlr = (newNameOrUlr + '.git');
                    }
                    var oldOrigin = self.git.originURL;
                    if (!newNameOrUlr.startsWith('git@') && !newNameOrUlr.startsWith('https://')) {
                        newNameOrUlr = oldOrigin.replace(tnp_core_1.path.basename(oldOrigin), newNameOrUlr);
                    }
                    try {
                        self.run("git remote rm origin").sync();
                    }
                    catch (error) { }
                    try {
                        self.run("git remote add origin " + newNameOrUlr).sync();
                        Helpers.info("Origin changed:\n        from: " + oldOrigin + "\n          to: " + newNameOrUlr + "\n");
                    }
                    catch (e) {
                        Helpers.error("Not able to change origin.. reverting to old", true, true);
                        self.run("git remote add origin " + oldOrigin).sync();
                    }
                },
            };
        },
        enumerable: true,
        configurable: true
    });
    return ProjectGit;
}());
exports.ProjectGit = ProjectGit;
// export interface ProjectGit extends Partial<Project> { }
//# sourceMappingURL=git-project.js.map