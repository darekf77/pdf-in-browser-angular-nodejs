"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var tnp_core_1 = require("tnp-core");
var tnp_cli_1 = require("tnp-cli");
var index_1 = require("./index");
var HelpersDependencies = /** @class */ (function () {
    function HelpersDependencies() {
    }
    HelpersDependencies.prototype.sort = function (deps) {
        // return deps;
        var last_currentProjIndex;
        var last_indexToReplace;
        var _loop_1 = function () {
            var depsProjs = deps.map(function (p) { return p.project; });
            // Helpers.log('\n' + depsProjs.map((p, i) => `${i}. ${p.name}`).join('\n') + '\n', 1)
            var continueAgain = false;
            var _loop_2 = function (currentProjIndex) {
                // const proj = deps[currentProjIndex].project;
                // const copyto = deps[currentProjIndex].copyto;
                var copytoIndexes = deps[currentProjIndex].copyto
                    .filter(function (p) { return p.location !== deps[currentProjIndex].project.location; })
                    .map(function (p) { return depsProjs.indexOf(p); });
                var indexToReplace = copytoIndexes.filter(function (i) { return i !== currentProjIndex; }).find(function (i) {
                    var result = i < currentProjIndex;
                    index_1.Helpers.log(deps[i].project.name + " index is less than project " + deps[currentProjIndex].project.name, 1);
                    return result;
                });
                if (tnp_core_1._.isNumber(indexToReplace)) {
                    var v1 = deps[currentProjIndex];
                    var v2 = deps[indexToReplace];
                    if (v1.copyto.includes(v2.project) && (v2.copyto.includes(v1.project))) {
                        index_1.Helpers.warn("Circural copyto between " + tnp_cli_1.CLI.chalk.bold(v1.project.name) + "(" + currentProjIndex + ") "
                            + (" and " + tnp_cli_1.CLI.chalk.bold(v2.project.name) + "(" + indexToReplace + ")"));
                    }
                    else {
                        // if (last_currentProjIndex === currentProjIndex && last_indexToReplace === indexToReplace) {
                        //   Helpers.warn(`Weird circural copyto between ${chalk.bold(v1.project.name)}(${currentProjIndex}) `
                        //     + ` and ${chalk.bold(v2.project.name)}(${indexToReplace})`)
                        // } else {
                        continueAgain = true;
                        // Helpers.log(`${v1.project.name}(${currentProjIndex}) should be swapped with ${v2.project.name}(${indexToReplace})`, 1);
                        deps[currentProjIndex] = v2;
                        deps[indexToReplace] = v1;
                        last_currentProjIndex = currentProjIndex;
                        last_indexToReplace = indexToReplace;
                        return "break";
                        // }
                    }
                }
            };
            for (var currentProjIndex = 0; currentProjIndex < deps.length; currentProjIndex++) {
                var state_2 = _loop_2(currentProjIndex);
                if (state_2 === "break")
                    break;
            }
            if (continueAgain) {
                return "continue";
            }
            return "break";
        };
        while (true) {
            var state_1 = _loop_1();
            if (state_1 === "break")
                break;
        }
        var onlyWithZeros = deps.filter(function (c) { return c.copyto.length === 0; });
        var onlyNormal = deps.filter(function (c) { return c.copyto.length > 0; });
        onlyNormal.forEach(function (d) {
            onlyWithZeros.forEach(function (b) {
                if (!d.copyto.includes(b.project)) {
                    d.copyto.push(b.project);
                }
            });
        });
        deps = tslib_1.__spreadArrays(onlyNormal, onlyWithZeros);
        return deps;
    };
    HelpersDependencies.prototype.recrusiveFind = function (currentProj, allAvailableProjects, deps, orgProj) {
        if (deps === void 0) { deps = []; }
        if (!orgProj) {
            orgProj = currentProj;
        }
        var availableDeps = allAvailableProjects
            .filter(function (p) { return !deps.includes(p); });
        var depsToAppend = availableDeps.filter(function (p) {
            var res = p['packageJson'].hasDependency(currentProj.name, true);
            // if (res) {
            //   Helpers.log(`${chalk.bold(orgProj.name + '/' + currentProj.name)} ${p.name} has dependency ${currentProj.name}`);
            // }
            return res;
        });
        depsToAppend.forEach(function (p) { return deps.push(p); });
        // console.log(`after appending deps ${chalk.bold(orgProj.name + '/' + currentProj.name)}`
        //   , deps.map(d => chalk.gray(d.name)).join(','))
        depsToAppend.forEach(function (p) {
            index_1.Helpers.deps.recrusiveFind(p, allAvailableProjects, deps, orgProj);
        });
        return deps;
    };
    return HelpersDependencies;
}());
exports.HelpersDependencies = HelpersDependencies;
//# sourceMappingURL=helpers-dependencies.backend.js.map