"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//#region imports
var chalk_1 = require("chalk");
var path = require("path");
var fse = require("fs-extra");
var _ = require("lodash");
var abstract_1 = require("../../abstract");
var tnp_helpers_1 = require("tnp-helpers");
var tnp_models_1 = require("tnp-models");
var tnp_config_1 = require("tnp-config");
//#endregion
function resolvePacakgesFromArgs(args) {
    var installType = '--save';
    return args
        .map(function (p) { return p.trim(); })
        .filter(function (p) {
        if (tnp_models_1.Models.npm.InstalationTypeArr.includes(p)) {
            installType = p;
            return false;
        }
        if (p.endsWith('@')) {
            p = p + "latest";
        }
        var res = tnp_helpers_1.Helpers.npm.checkValidNpmPackageName(p);
        if (!res) {
            tnp_helpers_1.Helpers.error("Invalid package to install: \"" + p + "\"", true, true);
        }
        return res;
    })
        .map(function (p) {
        if (!~p.search('@')) {
            return { name: p, installType: installType };
        }
        if (p.endsWith('@')) {
            p = p + "latest";
        }
        var isOrg = p.startsWith('@');
        var _a = (isOrg ? p.slice(1) : p).split('@'), name = _a[0], version = _a[1];
        return { name: isOrg ? "@" + name : name, version: version, installType: installType };
    });
}
exports.resolvePacakgesFromArgs = resolvePacakgesFromArgs;
function executeCommand(command, project) {
    tnp_helpers_1.Helpers.info("\n\n   " + command + " in folder: <...>/" + project.location + "\n\n   ");
    project.run(command, { output: true, biggerBuffer: true }).sync();
}
exports.executeCommand = executeCommand;
function copyMainProjectDependencies(projects, tmpProject, project, pkg) {
    var mainProjectInTemp = projects.mainProjectInTemp, mainProjectExisted = projects.mainProjectExisted;
    // if (!mainProjectExisted) {
    //   debugger;
    // }
    var alreadyChecked = [];
    function copyOtherProcess(parent) {
        var otherDepsInTemp = parent
            .allPackageJsonDeps(tmpProject.location)
            .filter(function (f) { return !alreadyChecked.includes(f); });
        if (otherDepsInTemp.length === 0) {
            return;
        }
        otherDepsInTemp
            .filter(function (otherDependenyInTemp) {
            return fse.existsSync(path.join(tmpProject.node_modules.path, otherDependenyInTemp.name));
        })
            .forEach(function (otherDependenyInTemp) {
            var existedPkgPath = path.join(project.node_modules.path, otherDependenyInTemp.name);
            var existedOtherDependency = abstract_1.Project.From(existedPkgPath);
            if (existedOtherDependency) {
                if (existedOtherDependency.version === otherDependenyInTemp.version) {
                    tnp_helpers_1.Helpers.log("[smoothInstallPrepare] nothing to do for same dependency version " + otherDependenyInTemp.name);
                }
                else {
                    if (parent.packageJson.checDepenciesAreSatisfyBy(existedOtherDependency)) {
                        tnp_helpers_1.Helpers.log("[smoothInstallPrepare] nothing to do dependency is satisfy " + otherDependenyInTemp.name);
                    }
                    else {
                        var diff = existedOtherDependency.version + " != " + otherDependenyInTemp.version;
                        tnp_helpers_1.Helpers.warn("[smoothInstallPrepare] \"" + parent.name + "/" + chalk_1.default.bold(otherDependenyInTemp.name) + "\" version not satisfy " + diff);
                        var dest = path.join(project.node_modules.path, mainProjectExisted.name, tnp_config_1.config.folder.node_modules, otherDependenyInTemp.name);
                        if (fse.existsSync(dest)) {
                            tnp_helpers_1.Helpers.warn("[smoothInstallPrepare] \"" + parent.name + "/" + chalk_1.default.bold(otherDependenyInTemp.name) + "\" nested already exists in neste folder");
                        }
                        else {
                            tnp_helpers_1.Helpers.mkdirp(dest);
                            tnp_helpers_1.Helpers.warn("[smoothInstallPrepare] \"" + parent.name + "/" + chalk_1.default.bold(otherDependenyInTemp.name) + "\" please copy manualy to nested folder");
                            // tryCopyFrom(otherDependenyInTemp.location, dest); // @TODO
                        }
                    }
                }
            }
            else {
                tnp_helpers_1.Helpers.log("[smoothInstallPrepare] copy new package " + otherDependenyInTemp.name);
                tnp_helpers_1.Helpers.tryCopyFrom(otherDependenyInTemp.location, existedPkgPath);
            }
        });
        otherDepsInTemp.forEach(function (p) {
            alreadyChecked.push(p);
            copyOtherProcess(p);
        });
    }
    copyOtherProcess(mainProjectInTemp);
}
exports.copyMainProjectDependencies = copyMainProjectDependencies;
function copyMainProject(tmpProject, project, pkg) {
    var mainProjectInTemp = abstract_1.Project.From(path.join(tmpProject.node_modules.path, pkg.name));
    var mainProjectExistedPath = path.join(project.node_modules.path, pkg.name);
    tnp_helpers_1.Helpers.removeFolderIfExists(mainProjectExistedPath);
    tnp_helpers_1.Helpers.copy(mainProjectInTemp.location, mainProjectExistedPath);
    tnp_helpers_1.Helpers.log("[smoothInstallPrepare] main package copy " + mainProjectInTemp.name);
    var mainProjectExisted = abstract_1.Project.From(mainProjectExistedPath);
    return { mainProjectExisted: mainProjectExisted, mainProjectInTemp: mainProjectInTemp };
}
exports.copyMainProject = copyMainProject;
function prepareTempProject(project, pkg) {
    var pathPart = tnp_config_1.config.folder.tmp + "-" + tnp_config_1.config.folder.node_modules + "-installation-of";
    var tmpFolder = path.join(project.location, pathPart + "-" + pkg.name.replace('/', '-'));
    tnp_helpers_1.Helpers.remove(path.join(project.location, pathPart) + "*");
    tnp_helpers_1.Helpers.mkdirp(tmpFolder);
    project.packageJson.copyTo(tmpFolder);
    var tmpProject = abstract_1.Project.From(tmpFolder);
    tmpProject.packageJson.setNamFromContainingFolder();
    tmpProject.packageJson.hideDeps("smooth instalation");
    pkg.installType = '--save';
    var command = prepareCommand(pkg, false, false, project);
    try {
        executeCommand(command, tmpProject);
    }
    catch (error) {
        tnp_helpers_1.Helpers.error("[" + tnp_config_1.config.frameworkName + "] "
            + "not able to install package... try again with exact version or check package name.", false, true);
    }
    return tmpProject;
}
exports.prepareTempProject = prepareTempProject;
function prepareCommand(pkg, remove, useYarn, project) {
    var install = (remove ? 'uninstall' : 'install');
    var command = '';
    var noPackageLock = (project.isStandaloneProject) ? '--no-package-lock' : '';
    var argsForFasterInstall = "--force --ignore-engines --no-progress --prefer-offline --no-audit " + noPackageLock;
    if (useYarn) {
        // --ignore-scripts
        // yarn install --prefer-offline
        command = "yarn " + (pkg ? 'add' : install) + " " + argsForFasterInstall + " " + (pkg ? pkg.name : '') + " "
            + ("" + ((pkg && pkg.installType && pkg.installType === '--save-dev') ? '-dev' : ''));
    }
    else {
        command = "npm " + install + " " + (pkg ? pkg.name : '') + " " + ((pkg && pkg.installType) ? pkg.installType : '') + " " + argsForFasterInstall + " ";
    }
    return command;
}
exports.prepareCommand = prepareCommand;
function fixOptions(options) {
    if (_.isNil(options)) {
        options = {};
    }
    if (_.isUndefined(options.generatLockFiles)) {
        options.generatLockFiles = false;
    }
    if (_.isUndefined(options.useYarn)) {
        options.useYarn = false;
    }
    if (_.isUndefined(options.remove)) {
        options.remove = false;
    }
    if (_.isUndefined(options.smoothInstall)) {
        options.smoothInstall = false;
    }
    if (_.isUndefined(options.pkg)) {
        options.pkg = void 0;
    }
    if (_.isUndefined(options.reason)) {
        options.reason = "Reason not defined";
    }
    return options;
}
exports.fixOptions = fixOptions;
function fixOptionsNpmInstall(options, project) {
    if (_.isNil(options)) {
        options = {};
    }
    if (!_.isArray(options.npmPackages)) {
        options.npmPackages = [];
    }
    if (_.isUndefined(options.remove)) {
        options.remove = false;
    }
    if (_.isUndefined(options.smoothInstall)) {
        options.smoothInstall = false;
    }
    return options;
}
exports.fixOptionsNpmInstall = fixOptionsNpmInstall;
//# sourceMappingURL=npm-packages-helpers.backend.js.map