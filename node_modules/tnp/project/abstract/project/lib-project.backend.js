"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
//#region @backend
var features_1 = require("../../features");
var tnp_core_1 = require("tnp-core");
var tnp_core_2 = require("tnp-core");
var tnp_core_3 = require("tnp-core");
var chalk_1 = require("chalk");
var tnp_core_4 = require("tnp-core");
var tnp_helpers_1 = require("tnp-helpers");
var tnp_config_1 = require("tnp-config");
/**
 * Project ready to be build/publish as npm package.
 * Also ready to be linked as package in workspace.
 *  - isomorphic-lib
 *  - angular-lib
 */
var LibProject = /** @class */ (function () {
    function LibProject() {
    }
    Object.defineProperty(LibProject.prototype, "isGlobalSystemTool", {
        get: function () {
            if (tnp_helpers_1.Helpers.isBrowser) {
                return this.browser.isGlobalSystemTool;
            }
            //#region @backend
            return this.packageJson && this.packageJson.isGlobalSystemTool;
            //#endregion
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LibProject.prototype, "isCommandLineToolOnly", {
        get: function () {
            if (tnp_helpers_1.Helpers.isBrowser) {
                return this.browser.isCommandLineToolOnly;
            }
            //#region @backend
            return this.packageJson && this.packageJson.isCommandLineToolOnly;
            //#endregion
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LibProject.prototype, "isGeneratingControllerEntities", {
        get: function () {
            //#region @backendFunc
            return this.typeIs('isomorphic-lib') && this.useFramework;
            //#endregion
        },
        enumerable: true,
        configurable: true
    });
    //#region @backend
    LibProject.prototype.projectLinkedFiles = function () {
        var files = [];
        return files;
    };
    LibProject.prototype.recreateIfNotExists = function () {
        return [];
    };
    LibProject.prototype.projectSpecyficFiles = function () {
        var files = [
            'index.js',
            'index.d.ts',
            'index.js.map',
        ];
        return files;
    };
    LibProject.prototype.projectSpecyficFilesLinked = function () {
        var files = [];
        return files;
    };
    LibProject.prototype.buildLib = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                tnp_helpers_1.Helpers.log("[buildLib] callend buildLib not implemented");
                return [2 /*return*/];
            });
        });
    };
    LibProject.prototype.checkIfLogginInToNpm = function (noExitOnError) {
        // if (!this.canBePublishToNpmRegistry) {
        //   return;
        // }
        try {
            this.run('npm whoami').sync();
        }
        catch (e) {
            tnp_helpers_1.Helpers.error("Please login in to npm.", noExitOnError, true);
        }
    };
    LibProject.prototype.beforeLibBuild = function (outDir) {
        var _this = this;
        this.copyWhenExist('bin', outDir);
        this.linkWhenExist(tnp_config_1.config.file.package_json, outDir);
        tnp_config_1.config.packageJsonSplit.forEach(function (c) {
            _this.copyWhenExist(c, outDir);
        });
        this.copyWhenExist('.npmrc', outDir);
        this.copyWhenExist('.npmignore', outDir);
        this.copyWhenExist('.gitignore', outDir);
        if (this.typeIs('isomorphic-lib')) {
            this.copyWhenExist(tnp_config_1.config.file.tnpEnvironment_json, outDir);
        }
        if (outDir === 'bundle') {
            this.linkWhenExist(tnp_config_1.config.folder.node_modules, outDir);
            this.linkWhenExist('package.json', tnp_core_2.path.join(outDir, tnp_config_1.config.folder.client));
        }
    };
    LibProject.prototype.copyWhenExist = function (source, outDir) {
        //#region @backend
        var basename = source;
        source = tnp_core_2.path.join(this.location, source);
        var dest = tnp_core_2.path.join(this.location, outDir, basename);
        if (tnp_helpers_1.Helpers.exists(source)) {
            if (tnp_helpers_1.Helpers.isFolder(source)) {
                tnp_helpers_1.Helpers.tryCopyFrom(source, dest);
            }
            else {
                tnp_helpers_1.Helpers.copyFile(source, dest);
                if (tnp_core_2.path.basename(source) === tnp_config_1.config.file.tnpEnvironment_json) {
                    tnp_helpers_1.Helpers.setValueToJSON(dest, 'currentProjectLocation', void 0);
                }
            }
        }
        else {
            tnp_helpers_1.Helpers.log("[isomorphic-lib][copyWhenExist] not exists: " + source);
        }
        //#endregion
    };
    LibProject.prototype.linkWhenExist = function (source, outLInk) {
        //#region @backend
        var basename = source;
        source = tnp_core_2.path.join(this.location, source);
        outLInk = tnp_core_2.path.join(this.location, outLInk, basename);
        if (tnp_helpers_1.Helpers.exists(source)) {
            if (tnp_helpers_1.Helpers.isLink(source)) {
                source = tnp_helpers_1.Helpers.pathFromLink(source);
            }
            if (tnp_helpers_1.Helpers.exists(source)) {
                tnp_helpers_1.Helpers.createSymLink(source, outLInk);
            }
        }
        //#endregion
    };
    /**
     * Return how many projects has changed
     * @param bumbVersionIn
     * @param newVersion
     * @param onlyInThisProjectSubprojects
     */
    LibProject.prototype.bumpVersionInOtherProjects = function (newVersion, onlyInThisProjectSubprojects) {
        if (onlyInThisProjectSubprojects === void 0) { onlyInThisProjectSubprojects = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                if (onlyInThisProjectSubprojects) {
                    // console.log('UPDATE VERSION !!!!!!!!!!!!!')
                    updateChildrenVersion(this, newVersion, this.name);
                }
                else {
                    if (this.TnpProject.name === this.name) {
                        tnp_helpers_1.Helpers.info("Ommiting version bump " + this.name + " - for tnp itself");
                    }
                    else if (this.packageJson.hasDependency(this.TnpProject.name)) {
                        tnp_helpers_1.Helpers.info("Ommiting version bump " + this.name + " - has tnp as dependency");
                    }
                    else {
                        this.TnpProject.packageJson.setDependencyAndSave({
                            name: this.name,
                            version: newVersion,
                        }, "Bump new version \"" + newVersion + "\" of " + this.name);
                        // try { /// TODO FIX THIS broken getDependents
                        //   await (new Promise((resolve, reject) => {
                        //     try {
                        //       getDependents(this.name, (err, packages: any[]) => {
                        //         if (err) {
                        //           reject(`[${config.frameworkName}] Can't get depended packages..`)
                        //         } else {
                        //           packages.forEach(pkg => {
                        //             Helpers.info(`Please update "${pkg}" depended on this package...`)
                        //           })
                        //           resolve()
                        //         }
                        //       });
                        //     } catch (error) {
                        //       reject(`[${config.frameworkName}] Error while getting depended packages.. `)
                        //     }
                        //   }));
                        // } catch (error) {
                        //   Helpers.warn(`[${config.frameworkName}] `
                        //     + `Not able to show dependent packages for ${chalk.bold(this.name)}`)
                        // }
                    }
                }
                return [2 /*return*/];
            });
        });
    };
    LibProject.prototype.commit = function (newVer, message) {
        if (message === void 0) { message = 'new version'; }
        this.git.commit(message + " " + newVer);
    };
    LibProject.prototype.compileES5version = function () {
        // TODO fix this for angular-lib
        if (this.frameworkVersionEquals('v1') || this.typeIsNot('isomorphic-lib')) {
            return;
        }
        var pathBundle = tnp_core_2.path.join(this.location, tnp_config_1.config.folder.bundle);
        var cwdBrowser = tnp_core_2.path.join(pathBundle, tnp_config_1.config.folder.browser);
        var cwdClient = tnp_core_2.path.join(pathBundle, tnp_config_1.config.folder.client);
        var pathBabelRc = tnp_core_2.path.join(cwdBrowser, tnp_config_1.config.file._babelrc);
        var pathCompiled = tnp_core_2.path.join(cwdBrowser, 'es5');
        var pathCompiledClient = tnp_core_2.path.join(cwdClient, 'es5');
        tnp_helpers_1.Helpers.writeFile(pathBabelRc, '{ "presets": ["env"] }\n');
        try {
            tnp_helpers_1.Helpers.run("babel . -d es5", { cwd: cwdBrowser }).sync();
            tnp_helpers_1.Helpers.copy(pathCompiled, pathCompiledClient);
        }
        catch (err) {
            tnp_helpers_1.Helpers.removeFileIfExists(pathBabelRc);
            tnp_helpers_1.Helpers.error(err, true, true);
            tnp_helpers_1.Helpers.error("Not able to create es5 version of lib", false, true);
        }
        tnp_helpers_1.Helpers.removeFileIfExists(pathBabelRc);
    };
    LibProject.prototype.installLocaly = function (releaseOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var vsixPackageName;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.isVscodeExtension) return [3 /*break*/, 3];
                        vsixPackageName = this.extensionVsixName;
                        if (!this.containsFile(tnp_config_1.config.folder.out)) {
                            tnp_helpers_1.Helpers.error("Please build your project: " + tnp_config_1.config.frameworkName + " build:dist", false, true);
                        }
                        if (!!tnp_helpers_1.Helpers.exists(this.path(vsixPackageName).absolute.normal)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.createVscePackage(false)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        tnp_helpers_1.Helpers.info("Installing extension: " + vsixPackageName + " "
                            + ("with creation date: " + tnp_core_1.fse.lstatSync(this.path(vsixPackageName).absolute.normal).birthtime + "..."));
                        this.run("code --install-extension " + vsixPackageName).sync();
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    LibProject.prototype.createVscePackage = function (showInfo) {
        if (showInfo === void 0) { showInfo = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var vsixPackageName, commandInstall, error_1;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        vsixPackageName = this.extensionVsixName;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, tnp_helpers_1.Helpers.actionWrapper(function () {
                                _this.run("npm-run vsce package --yarn").sync();
                            }, "Building vsix package " + chalk_1.default.bold(vsixPackageName) + "... ")];
                    case 2:
                        _a.sent();
                        if (showInfo) {
                            commandInstall = chalk_1.default.bold(tnp_config_1.config.frameworkName + " install:locally");
                            tnp_helpers_1.Helpers.info("\n\n        Please use command: " + commandInstall + " # or " + tnp_config_1.config.frameworkName + " il\n        to install this package in local vscode instance.\n\n        ");
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        tnp_helpers_1.Helpers.error(error_1, true, true);
                        tnp_helpers_1.Helpers.error("Not able to build " + vsixPackageName + " package ");
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    LibProject.prototype.release = function (releaseOptions, automaticRelease) {
        if (automaticRelease === void 0) { automaticRelease = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            function removeTagAndCommit(tagOnly) {
                if (tagOnly === void 0) { tagOnly = false; }
                tnp_helpers_1.Helpers.error("PLEASE RUN: ", true, true);
                if (!tagOnly) {
                    tnp_helpers_1.Helpers.error("git reset --hard HEAD~1", true, true);
                }
                tnp_helpers_1.Helpers.error("git tag --delete v" + newVersion, automaticRelease, true);
                if (automaticRelease) {
                    throw 'release problem...';
                }
            }
            var baseFolder, absolutePathReleaseProject, generatedProject, vscodeFolder, _a, prod, obscure, uglify, nodts, newVersion;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (tnp_core_4._.isUndefined(releaseOptions.useTempFolder)) {
                            if (!this.checkIfReadyForNpm(true)) {
                                tnp_helpers_1.Helpers.warn("Project \"" + this.name + "\" is not ready for npm release");
                                return [2 /*return*/];
                            }
                            if (this.isPrivate) {
                                tnp_helpers_1.Helpers.warn("Cannot release private project " + chalk_1.default.bold(this.genericName));
                                return [2 /*return*/];
                            }
                            if (this.targetProjects.exists) {
                                if (global.tnpNonInteractive) {
                                    tnp_helpers_1.Helpers.warn("Ommiting relese for project with \"target projects\"");
                                    tnp_helpers_1.Helpers.sleep(3);
                                    return [2 /*return*/];
                                }
                                tnp_helpers_1.Helpers.error("You can't release project with target projects", false, true);
                            }
                            releaseOptions.useTempFolder = true;
                        }
                        baseFolder = tnp_core_2.path.join(this.location, 'tmp-bundle-release');
                        absolutePathReleaseProject = tnp_core_2.path.join(baseFolder, 'bundle', 'project', this.name);
                        if (!this.isStandaloneProject) return [3 /*break*/, 2];
                        if (!releaseOptions.useTempFolder) return [3 /*break*/, 2];
                        tnp_helpers_1.Helpers.removeFolderIfExists(baseFolder);
                        tnp_helpers_1.Helpers.removeFolderIfExists(absolutePathReleaseProject);
                        tnp_helpers_1.Helpers.mkdirp(absolutePathReleaseProject);
                        this.copyManager.generateSourceCopyIn(absolutePathReleaseProject, {
                            useTempLocation: true,
                            markAsGenerated: false,
                            forceCopyPackageJSON: true,
                        });
                        generatedProject = tnp_helpers_1.Project.From(absolutePathReleaseProject);
                        this.allResources.forEach(function (relPathResource) {
                            var source = tnp_core_2.path.join(_this.location, relPathResource);
                            var dest = tnp_core_2.path.join(absolutePathReleaseProject, relPathResource);
                            if (tnp_helpers_1.Helpers.exists(source)) {
                                if (tnp_helpers_1.Helpers.isFolder(source)) {
                                    tnp_helpers_1.Helpers.copy(source, dest);
                                }
                                else {
                                    tnp_helpers_1.Helpers.copyFile(source, dest);
                                }
                            }
                        });
                        this.packageJson.linkTo(absolutePathReleaseProject);
                        this.node_modules.linkToProject(generatedProject);
                        releaseOptions.useTempFolder = false;
                        vscodeFolder = tnp_core_2.path.join(generatedProject.location, tnp_config_1.config.folder._vscode);
                        tnp_helpers_1.Helpers.removeFolderIfExists(vscodeFolder);
                        return [4 /*yield*/, generatedProject.release(releaseOptions, automaticRelease)];
                    case 1:
                        _b.sent();
                        return [2 /*return*/];
                    case 2:
                        this.checkIfLogginInToNpm(automaticRelease);
                        _a = releaseOptions.prod, prod = _a === void 0 ? false : _a, obscure = releaseOptions.obscure, uglify = releaseOptions.uglify, nodts = releaseOptions.nodts;
                        this.checkIfReadyForNpm();
                        newVersion = this.versionPatchedPlusOne;
                        return [4 /*yield*/, tnp_helpers_1.Helpers.questionYesNo("Release new version: " + newVersion + " ?", function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                var _this = this;
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.bumpVersionInOtherProjects(newVersion, true)];
                                        case 1:
                                            _a.sent();
                                            this.commit(newVersion);
                                            if (!!this.node_modules.exist) return [3 /*break*/, 3];
                                            return [4 /*yield*/, this.npmPackages.installProcess("release procedure")];
                                        case 2:
                                            _a.sent();
                                            _a.label = 3;
                                        case 3:
                                            this.packageJson.data.version = newVersion;
                                            this.packageJson.save('show for release');
                                            this.run("tnp init").sync();
                                            tnp_helpers_1.Helpers.info("BUILD OPTION (" + this.name + "):\n      prod=" + !!prod + ",\n      obscure=" + !!obscure + ",\n      nodts=" + !!nodts + ",\n      uglify=" + !!uglify + "\n      ");
                                            return [4 /*yield*/, this.build(features_1.BuildProcess.prepareOptionsBuildProcess({
                                                    prod: prod,
                                                    obscure: obscure,
                                                    nodts: nodts,
                                                    uglify: uglify,
                                                    outDir: tnp_config_1.config.folder.bundle,
                                                    args: releaseOptions.args
                                                }, this))];
                                        case 4:
                                            _a.sent();
                                            if (!this.isCommandLineToolOnly) {
                                                this.createClientVersionAsCopyOfBrowser();
                                            }
                                            if (this.typeIs('angular-lib')) {
                                                // copy all dts from browser to backend angular-lib files
                                                tnp_core_3.glob.sync(tnp_core_2.path.join(this.location, tnp_config_1.config.folder.bundle, tnp_config_1.config.folder.browser) + "/**/*.d.ts")
                                                    .forEach(function (f) {
                                                    var newDest = f.replace(tnp_core_2.path.join(_this.location, tnp_config_1.config.folder.bundle, tnp_config_1.config.folder.browser) + "/", tnp_core_2.path.join(_this.location, tnp_config_1.config.folder.bundle) + "/");
                                                    tnp_helpers_1.Helpers.copyFile(f, newDest);
                                                });
                                            }
                                            this.compileES5version();
                                            this.bundleResources();
                                            this.commit(newVersion);
                                            return [2 /*return*/];
                                    }
                                });
                            }); }, function () {
                                process.exit(0);
                            })];
                    case 3:
                        _b.sent();
                        // this.packageJson.data.version = newVersion;
                        // this.packageJson.save(`[release tnp]`);
                        tnp_config_1.config.packageJsonSplit.forEach(function (c) {
                            var property = c
                                .replace(tnp_config_1.config.file.package_json + "_", '')
                                .replace(".json", '');
                            tnp_helpers_1.Helpers.setValueToJSON(tnp_core_2.path.join(_this.location, tnp_config_1.config.folder.bundle, tnp_config_1.config.file.package_json), property, void 0);
                        });
                        [
                            // config.folder.browser, /// TODO FIX for typescript
                            tnp_config_1.config.folder.client,
                            '',
                        ].forEach(function (c) {
                            var pjPath = tnp_core_2.path.join(_this.location, tnp_config_1.config.folder.bundle, c, tnp_config_1.config.file.package_json);
                            var content = tnp_helpers_1.Helpers.readJson(pjPath);
                            tnp_helpers_1.Helpers.remove(pjPath);
                            tnp_helpers_1.Helpers.writeFile(pjPath, content);
                        });
                        this.packageJson.showDeps("after release show when ok");
                        if (!global.tnpNonInteractive) {
                            this.run("code .").sync();
                            tnp_helpers_1.Helpers.pressKeyAndContinue("Check your bundle and press any key...");
                        }
                        return [4 /*yield*/, tnp_helpers_1.Helpers.questionYesNo("Publish on npm version: " + newVersion + " ?", function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                var successPublis, names, index, c, existedBundle, additionBase, pathPackageJsonRelease, packageJsonAdd;
                                var _this = this;
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            successPublis = false;
                                            try {
                                                this.run('npm publish', {
                                                    cwd: tnp_core_2.path.join(this.location, tnp_config_1.config.folder.bundle),
                                                    output: true
                                                }).sync();
                                                successPublis = true;
                                            }
                                            catch (e) {
                                                removeTagAndCommit();
                                            }
                                            if (!successPublis) return [3 /*break*/, 4];
                                            names = this.packageJson.additionalNpmNames;
                                            for (index = 0; index < names.length; index++) {
                                                c = names[index];
                                                existedBundle = tnp_core_2.path.join(this.location, 'bundle');
                                                additionBase = tnp_core_2.path.resolve(tnp_core_2.path.join(this.location, "../../../additional-bundle-" + c));
                                                tnp_helpers_1.Helpers.mkdirp(additionBase);
                                                tnp_helpers_1.Helpers.copy(existedBundle, additionBase, {
                                                    copySymlinksAsFiles: true,
                                                    omitFolders: [tnp_config_1.config.folder.node_modules],
                                                    omitFoldersBaseFolder: existedBundle
                                                });
                                                pathPackageJsonRelease = tnp_core_2.path.join(additionBase, tnp_config_1.config.file.package_json);
                                                packageJsonAdd = tnp_helpers_1.Helpers.readJson(tnp_core_2.path.join(additionBase, tnp_config_1.config.file.package_json));
                                                packageJsonAdd.name = c;
                                                // const keys = Object.keys(packageJsonAdd.bin || {});
                                                // keys.forEach(k => {
                                                //   const v = packageJsonAdd.bin[k] as string;
                                                //   packageJsonAdd.bin[k.replace(this.name, c)] = v.replace(this.name, c);
                                                //   delete packageJsonAdd.bin[k];
                                                // });
                                                tnp_helpers_1.Helpers.writeFile(pathPackageJsonRelease, packageJsonAdd);
                                                tnp_helpers_1.Helpers.info('log addtional bundle created');
                                                try {
                                                    if (!global.tnpNonInteractive) {
                                                        tnp_helpers_1.Helpers.run("code " + additionBase).sync();
                                                        tnp_helpers_1.Helpers.info("Check you additional bundle for " + chalk_1.default.bold(c) + " and press any key to publish...");
                                                        tnp_helpers_1.Helpers.pressKeyAndContinue();
                                                    }
                                                    tnp_helpers_1.Helpers.run('npm publish', { cwd: additionBase }).sync();
                                                }
                                                catch (error) {
                                                    tnp_helpers_1.Helpers.warn("No able to push additional bundle for name: " + c);
                                                }
                                            }
                                            //#endregion
                                            return [4 /*yield*/, this.bumpVersionInOtherProjects(newVersion)];
                                        case 1:
                                            //#endregion
                                            _a.sent();
                                            if (!(this.typeIs('angular-lib') && !global.tnpNonInteractive)) return [3 /*break*/, 3];
                                            return [4 /*yield*/, tnp_helpers_1.Helpers.questionYesNo("Do you wanna build docs for github preview", function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                                    var appBuildOptions;
                                                    return tslib_1.__generator(this, function (_a) {
                                                        switch (_a.label) {
                                                            case 0:
                                                                appBuildOptions = { docsAppInProdMode: prod };
                                                                return [4 /*yield*/, tnp_helpers_1.Helpers.questionYesNo("Do you wanna build in production mode", function () {
                                                                        appBuildOptions.docsAppInProdMode = true;
                                                                    }, function () {
                                                                        appBuildOptions.docsAppInProdMode = false;
                                                                    })];
                                                            case 1:
                                                                _a.sent();
                                                                tnp_helpers_1.Helpers.log("\n\n          Building docs prevew - start\n\n          ");
                                                                return [4 /*yield*/, this.run("tnp build:app" + (appBuildOptions.docsAppInProdMode ? 'prod' : '')).sync()];
                                                            case 2:
                                                                _a.sent();
                                                                tnp_helpers_1.Helpers.log("\n\n          Building docs prevew - done\n\n          ");
                                                                this.pushToGitRepo(newVersion);
                                                                return [2 /*return*/];
                                                        }
                                                    });
                                                }); }, function () {
                                                    _this.pushToGitRepo(newVersion);
                                                })];
                                        case 2:
                                            _a.sent();
                                            return [3 /*break*/, 4];
                                        case 3:
                                            this.pushToGitRepo(newVersion);
                                            _a.label = 4;
                                        case 4: return [2 /*return*/];
                                    }
                                });
                            }); }, function () {
                                removeTagAndCommit();
                            })];
                    case 4:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    LibProject.prototype.tagVersion = function (newVersion) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var error_2, ver;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 1, , 3]);
                        this.run("git tag -a v" + newVersion + " -m \"version v" + newVersion + "\"", { output: false }).sync();
                        return [3 /*break*/, 3];
                    case 1:
                        error_2 = _a.sent();
                        tnp_helpers_1.Helpers.warn("NOT ABLE TO CREATE A TAG \"" + newVersion + "\"");
                        ver = newVersion.split('.');
                        if (ver.length > 0) {
                            ver[ver.length - 1] = (parseInt(ver[ver.length - 1]) + 1).toString();
                        }
                        newVersion = ver.join('.');
                        return [4 /*yield*/, tnp_helpers_1.Helpers.questionYesNo("Do you wanna try to create tag v" + newVersion + " ?", function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.tagVersion(newVersion)];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); })];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    LibProject.prototype.pushToGitRepo = function (newVersion) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var branchName;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.tagVersion(newVersion)];
                    case 1:
                        _a.sent();
                        this.packageJson.setBuildHash(this.git.lastCommitHash());
                        this.packageJson.save('updating hash');
                        this.commit(newVersion, "build hash update");
                        console.log('Pushing to git repository... ');
                        branchName = this.run('git symbolic-ref --short HEAD', { output: false }).sync().toString();
                        console.log("Git branch: " + branchName);
                        try {
                            this.run("git push origin " + branchName, { output: false }).sync();
                        }
                        catch (error) {
                            tnp_helpers_1.Helpers.warn("NOT ABLE TO PUSH CHANGES TO MASTER");
                        }
                        tnp_helpers_1.Helpers.info('Pushing to git repository done.');
                        return [2 /*return*/];
                }
            });
        });
    };
    LibProject.prototype.createClientVersionAsCopyOfBrowser = function () {
        var bundleFolder = tnp_core_2.path.join(this.location, tnp_config_1.config.folder.bundle);
        var browser = tnp_core_2.path.join(bundleFolder, tnp_config_1.config.folder.browser);
        var client = tnp_core_2.path.join(bundleFolder, tnp_config_1.config.folder.client);
        if (tnp_core_1.fse.existsSync(browser)) {
            tnp_helpers_1.Helpers.tryCopyFrom(browser, client);
        }
        else {
            tnp_helpers_1.Helpers.warn("Browser forlder not generated.. replacing with dummy files: browser.js, client.js", false);
            var msg = "console.log('" + this.genericName + " only for backend') ";
            tnp_helpers_1.Helpers.writeFile(browser + ".js", msg);
            tnp_helpers_1.Helpers.writeFile(client + ".js", msg);
        }
    };
    LibProject.prototype.bundleResources = function () {
        var _this = this;
        this.checkIfReadyForNpm();
        var bundleFolder = tnp_core_2.path.join(this.location, tnp_config_1.config.folder.bundle);
        if (!tnp_core_1.fse.existsSync(bundleFolder)) {
            tnp_core_1.fse.mkdirSync(bundleFolder);
        }
        [].concat(this.resources).forEach(function (res) {
            var file = tnp_core_2.path.join(_this.location, res);
            var dest = tnp_core_2.path.join(bundleFolder, res);
            if (!tnp_core_1.fse.existsSync(file)) {
                tnp_helpers_1.Helpers.error("[" + tnp_config_1.config.frameworkName + "][lib-project] Resource file: " + chalk_1.default.bold(tnp_core_2.path.basename(file)) + " does not "
                    + ("exist in \"" + _this.genericName + "\"  (package.json > tnp.resources[])\n        "), false, true);
            }
            if (tnp_core_1.fse.lstatSync(file).isDirectory()) {
                // console.log('IS DIRECTORY', file)
                // console.log('IS DIRECTORY DEST', dest)
                var filter = function (src) {
                    return !/.*node_modules.*/g.test(src);
                };
                tnp_helpers_1.Helpers.copy(file, dest, { filter: filter });
            }
            else {
                // console.log('IS FILE', file)
                tnp_core_1.fse.copyFileSync(file, dest);
            }
        });
        tnp_helpers_1.Helpers.info("Resources copied to release folder: " + tnp_config_1.config.folder.bundle);
    };
    return LibProject;
}());
exports.LibProject = LibProject;
// export interface LibProject extends Partial<Project> { }
//#region @backend
function updateChildrenVersion(project, newVersion, name, updatedProjectw) {
    if (updatedProjectw === void 0) { updatedProjectw = []; }
    if (updatedProjectw.filter(function (p) { return p.location === project.location; }).length > 0) {
        tnp_helpers_1.Helpers.log("[release - " + name + "][lib-proj] Alredy update " + project.genericName);
        return;
    }
    if (project.name !== name) {
        project.packageJson.setDependencyAndSave({
            name: name,
            version: newVersion
        }, "Bump versoin of library " + name);
    }
    else {
        project.packageJson.data.version = newVersion;
        project.packageJson.save("[lib-proj] set version");
    }
    updatedProjectw.push(project);
    tnp_helpers_1.Helpers.log("[release - " + name + "][lib-proj] children of " + project.genericName + ": \n" + project.children.map(function (c) { return c.location; }) + "\n");
    project.children.forEach(function (childProject) { return updateChildrenVersion(childProject, newVersion, name, updatedProjectw); });
}
exports.updateChildrenVersion = updateChildrenVersion;
//#endregion
//# sourceMappingURL=lib-project.backend.js.map