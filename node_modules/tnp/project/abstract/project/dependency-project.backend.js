"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
//#region imports
var tnp_core_1 = require("tnp-core");
var tnp_core_2 = require("tnp-core");
var tnp_core_3 = require("tnp-core");
var tnp_helpers_1 = require("tnp-helpers");
var project_1 = require("./project");
//#endregion
var DependencyProject = /** @class */ (function () {
    function DependencyProject() {
    }
    DependencyProject.prototype.projectsInOrderForChainBuild = function (targets) {
        var _this = this;
        if (targets === void 0) { targets = []; }
        if (this.isContainer) {
            if (targets.length > 0) {
                var allToConsider_1 = [];
                targets.forEach(function (t) {
                    allToConsider_1 = tslib_1.__spreadArrays([
                        t
                    ], t.projectsInOrderForChainBuild(), allToConsider_1);
                });
                allToConsider_1 = tnp_helpers_1.Helpers.arrays.uniqArray(allToConsider_1, 'location');
                var reordered = reorderResult(allToConsider_1);
                return reordered;
            }
            else {
                var children = (this.children)
                    .filter(function (f) { return f.frameworkVersionAtLeast('v2'); })
                    .map(function (proj) {
                    return { proj: proj, deps: proj.projectsInOrderForChainBuild() };
                });
                var allDeps = children.map(function (d) { return d.proj; });
                var reordered = reorderResult(allDeps);
                return reordered;
            }
        }
        if (!this.isWorkspaceChildProject && !this.isStandaloneProject) {
            return [];
        }
        var deps = this.sortedRequiredWorkspaceDependencies;
        if (this.isWorkspaceChildProject && this.typeIs('angular-lib') && this.workspaceDependenciesServers.length > 0) {
            deps = deps.concat(this.workspaceDependenciesServers);
            // TODO handle deps of project.workspaceDependenciesServers
        }
        if (this.isStandaloneProject) {
            deps = deps.filter(function (d) { return d.name !== _this.name; });
        }
        return deps;
    };
    /**
     * Only for continaer
     */
    DependencyProject.prototype.projectsFromArgs = function (args, argsChangeFn) {
        var _this = this;
        if (!this.isContainer) {
            return [];
        }
        var indexexToCut = [];
        var projects = tnp_helpers_1.Helpers.arrays.uniqArray(args
            .split(' ')
            .map(function (arg, i) {
            var possibleProj = tnp_core_2.path.join(_this.location, arg);
            var proj = project_1.Project.From(possibleProj);
            if (proj) {
                indexexToCut.push(i);
                return proj;
            }
        })
            .filter(function (p) { return !!p; }), 'location');
        var newArgs = args.split(' ');
        indexexToCut.forEach(function (i) { return newArgs[i] = ''; });
        argsChangeFn(newArgs.join(' ').trim());
        var allProjectToConsider = tnp_helpers_1.Helpers.arrays.uniqArray(this.children.concat(projects), 'location');
        allProjectToConsider.forEach(function (p) {
            p.packageJson.showDeps("updating dependencies chain container build");
        });
        // console.log('allProjectToConsider', allProjectToConsider.map(c => c.genericName).join('\n'))
        var result = projects.map(function (proj) {
            var copyto = tnp_helpers_1.Helpers.deps.recrusiveFind(proj, allProjectToConsider);
            // proj.name.startsWith('tnp') && Helpers.log(`copyto for ${proj.genericName}
            // ${copyto.sort().map(c => c.name).join('\n')}
            // `);
            // process.stdin.resume()
            copyto = copyto.filter(function (c) { return !tnp_core_1._.isUndefined(projects.find(function (a) { return a.name === c.name; })); });
            copyto = tnp_helpers_1.Helpers.arrays.uniqArray(copyto, 'location');
            return { project: proj, copyto: copyto };
        });
        // process.exit(0)
        return tnp_helpers_1.Helpers.deps.sort(result);
    };
    DependencyProject.prototype.projectsInOrderForBuild = function (buildAppsForProjects) {
        var _this = this;
        if (!tnp_core_3.fse.existsSync(this.location)) {
            return [];
        }
        var targetClients = (this.children.filter(function (p) {
            return _this.env && _this.env.config && !!_this.env.config.workspace.projects.find(function (wp) { return wp.name === p.name; });
        }))
            .filter(function (c) { return c.typeIs('angular-lib'); })
            .map(function (c) {
            return { project: c, appBuild: true };
        });
        tnp_helpers_1.Helpers.log("targetClients: " + targetClients.map(function (c) { return c.project.genericName; }).join('\n'));
        var libsForTargets = libs(targetClients, true);
        targetClients.forEach(function (t) {
            if (tnp_core_1._.isNil(libsForTargets.find(function (p) { return p.project.location === t.project.location; }))) {
                libsForTargets.push({ project: t, appBuild: false });
            }
        });
        tnp_helpers_1.Helpers.log("libs: " + libsForTargets.map(function (c) { return c.project.genericName; }).join('\n'));
        var aloneServers = this.children
            .filter(function (p) {
            return _this.env && _this.env.config && !!_this.env.config.workspace.projects.find(function (wp) { return wp.name === p.name; });
        })
            .filter(function (c) { return c.typeIs('isomorphic-lib'); })
            .filter(function (c) { return tnp_core_1._.isUndefined(libsForTargets.find(function (l) { return l.project === c; })); })
            .map(function (c) {
            return { project: c, appBuild: false };
        });
        return tslib_1.__spreadArrays(libsForTargets, (this.isGenerated ? aloneServers : []), (buildAppsForProjects ? targetClients : []));
    };
    Object.defineProperty(DependencyProject.prototype, "sortedRequiredWorkspaceDependencies", {
        get: function () {
            if (!this.isWorkspaceChildProject && !this.isStandaloneProject) {
                return [];
            }
            return this.libsForTraget(this).concat([this]);
        },
        enumerable: true,
        configurable: true
    });
    DependencyProject.prototype.libsForTraget = function (project) {
        if (!this.isWorkspaceChildProject && !this.isStandaloneProject) {
            return [];
        }
        return libs([{ project: project, appBuild: false }]).map(function (c) { return c.project; });
    };
    return DependencyProject;
}());
exports.DependencyProject = DependencyProject;
function libs(targetClients, targetAsLibAlso) {
    if (targetAsLibAlso === void 0) { targetAsLibAlso = false; }
    var existed = {};
    var targetLibs = targetClients
        .map(function (t) { return t.project.workspaceDependencies; })
        .reduce(function (a, b) { return a.concat(b); }, [])
        .map(function (d) {
        if (!existed[d.name]) {
            existed[d.name] = d;
        }
        return d;
    })
        .filter(function (c) {
        if (existed[c.name]) {
            existed[c.name] = void 0;
            return true;
        }
        return false;
    })
        .sort(function (a, b) {
        return a.workspaceDependencies.filter(function (c) { return c === b; }).length;
    });
    var result = [];
    function recrusiveSearchForDependencies(lib) {
        if (tnp_core_1._.isUndefined(result.find(function (r) { return r.name === lib.name; }))) {
            result.push(lib);
        }
        if (lib.workspaceDependencies.length === 0) {
            return;
        }
        lib.workspaceDependencies
            .filter(function (f) {
            return tnp_core_1._.isUndefined(result.find(function (r) { return r.name === f.name; }));
        })
            .forEach(function (d) {
            if (tnp_core_1._.isUndefined(result.find(function (r) { return r.name === d.name; }))) {
                result.unshift(d);
            }
            recrusiveSearchForDependencies(d);
        });
    }
    targetLibs.forEach(function (lib) { return recrusiveSearchForDependencies(lib); });
    var count = 0;
    var lastArr = [];
    result = reorderResult(result);
    // while (reorderResult(result, r => { result = r; })) {
    //   Helpers.log(`Sort(${++count})\n${result.map(c => c.genericName).join('\n')}\n `, 1);
    //   if (_.isEqual(lastArr, result.map(c => c.name))) {
    //     console.log(`EQUAL ARRAY:\n` + lastArr.map(a => '-' + a).join('\n'))
    //     break;
    //   }
    //   lastArr = result.map(c => c.name);
    // }
    if (targetAsLibAlso) {
        targetClients
            .filter(function (f) { return tnp_core_1._.isUndefined(result.find(function (p) { return p.location === f.project.location; })); })
            .forEach(function (f) { return result.push(f.project); });
    }
    return result.map(function (c) {
        return { project: c, appBuild: false };
    });
}
function reorderResult(result) {
    if (result === void 0) { result = []; }
    var i = 0;
    var maxNoup = 0;
    var MAX_NO_UPDATE_IN_ROW = (result.length + 1);
    var count = 1;
    var _loop_1 = function () {
        var res = result[i];
        var updateTriggered = !tnp_core_1._.isUndefined(result.slice(i + 1).find(function (res2) {
            if (res.name === res2.name) {
                return false;
            }
            if (!tnp_core_1._.isUndefined(res.workspaceDependencies.find(function (wd) { return wd.name === res2.name; }))) {
                tnp_helpers_1.Helpers.log("+ " + res.name + " has no dependency " + res2.name, 1);
                result = tnp_helpers_1.Helpers.arrays.arrayMoveElementBefore(result, res2, res, 'location');
                return true;
            }
            return false;
        }));
        if (i === (result.length - 1)) {
            i = 0;
        }
        else {
            i++;
        }
        if (updateTriggered) {
            tnp_helpers_1.Helpers.log("Sort(" + ++count + ")\n" + result.map(function (c) { return c.genericName; }).join('\n') + "\n ", 1);
            maxNoup = 0;
            return "continue";
        }
        else {
            maxNoup++;
            tnp_helpers_1.Helpers.log("SORT NO UPDATE..");
        }
        if (maxNoup === MAX_NO_UPDATE_IN_ROW) {
            return "break";
        }
    };
    while (true) {
        var state_1 = _loop_1();
        if (state_1 === "break")
            break;
    }
    return result;
}
//# sourceMappingURL=dependency-project.backend.js.map