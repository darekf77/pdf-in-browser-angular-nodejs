"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var tnp_core_1 = require("tnp-core");
var tnp_core_2 = require("tnp-core");
var tnp_core_3 = require("tnp-core");
var tnp_config_1 = require("tnp-config");
var tnp_helpers_1 = require("tnp-helpers");
var incremental_compiler_1 = require("incremental-compiler");
var source_mod_for_site_backend_1 = require("./source-mod-for-site.backend");
//#endregion
function optionsSourceModifier(project) {
    // console.log('PROJECT', project.name)
    var folderPath = void 0;
    if (project.isWorkspaceChildProject || project.isStandaloneProject) {
        folderPath = [
            tnp_core_2.path.join(project.location, tnp_config_1.config.folder.src),
        ];
        if (project.typeIs('angular-lib')) {
            folderPath.push(tnp_core_2.path.join(project.location, tnp_config_1.config.folder.components));
        }
        if (project.isSiteInStrictMode) {
            folderPath.push(tnp_core_2.path.join(project.location, tnp_config_1.config.folder.custom));
        }
    }
    var options = {
        folderPath: folderPath,
    };
    // if (project.isStandaloneProject) {
    //   console.log(`${project.genericName}: optionsSourceModifier`, options)
    // }
    // if (project.name === 'simple-lib') {
    //   console.log('optionsSourceModifier', options)
    // }
    return options;
}
exports.optionsSourceModifier = optionsSourceModifier;
var SourceModifier = /** @class */ (function (_super) {
    tslib_1.__extends(SourceModifier, _super);
    function SourceModifier() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SourceModifier.prototype.preAsyncAction = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var pathToWatch, prefixTmpFolder, isStandalone, childrenNames;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                if (!(this.project.isWorkspaceChildProject || this.project.isStandaloneProject)) {
                    return [2 /*return*/];
                }
                prefixTmpFolder = "tmp-src-dist-browser-for-";
                if (this.project.typeIs('angular-lib')) {
                    pathToWatch = tnp_config_1.config.folder.components;
                }
                if (this.project.typeIs('isomorphic-lib', 'vscode-ext')) { // TODO all projects with src ?
                    pathToWatch = tnp_config_1.config.folder.src;
                }
                isStandalone = this.project.isStandaloneProject;
                if (isStandalone) {
                    if (this.project.typeIs('angular-lib')) {
                        prefixTmpFolder = "tmp-src-dist";
                    }
                    if (this.project.typeIs('isomorphic-lib')) {
                        prefixTmpFolder = "tmp-src-dist-browser";
                    }
                }
                childrenNames = this.project.isStandaloneProject ? [] : this.project.parent.childrenThatAreClients.map(function (p) { return p.name; });
                tnp_core_3.chokidar.watch([pathToWatch], {
                    ignoreInitial: true,
                    followSymlinks: false,
                    ignorePermissionErrors: true,
                    cwd: this.project.location
                })
                    .on('unlinkDir', function (relativeDir) {
                    // console.log('UNLINK', relativeDir)
                    relativeDir = relativeDir.split('/').slice(1).join('/');
                    if (isStandalone) {
                        var checkDelete = tnp_core_2.path.join(_this.project.location, prefixTmpFolder, relativeDir);
                        tnp_helpers_1.Helpers.removeFolderIfExists(checkDelete);
                    }
                    else {
                        for (var index = 0; index < childrenNames.length; index++) {
                            var checkDelete = tnp_core_2.path.join(_this.project.location, "" + prefixTmpFolder + childrenNames[index], relativeDir);
                            tnp_helpers_1.Helpers.removeFolderIfExists(checkDelete);
                        }
                    }
                })
                    .on('addDir', function (relativeDir) {
                    // console.log('ADD DIR', relativeDir)
                    var folderAdded = tnp_core_2.path.join(_this.project.location, relativeDir);
                    _this.reSaveAllFilesIn(folderAdded);
                });
                return [2 /*return*/];
            });
        });
    };
    SourceModifier.prototype.reSaveAllFilesIn = function (folderPath) {
        var files = tnp_core_1.fse.readdirSync(folderPath);
        for (var index = 0; index < files.length; index++) {
            var f = tnp_core_2.path.join(folderPath, files[index]);
            if (tnp_core_1.fse.lstatSync(f).isDirectory()) {
                this.reSaveAllFilesIn(f);
            }
            else {
                tnp_helpers_1.Helpers.writeFile(f, tnp_helpers_1.Helpers.readFile(f), false);
            }
        }
    };
    SourceModifier.prototype.asyncAction = function (event) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var relativePathToProject, modifiedFiles;
            return tslib_1.__generator(this, function (_a) {
                relativePathToProject = event.fileAbsolutePath
                    .replace(this.project.location, '')
                    .replace(/^\//, '');
                modifiedFiles = { modifiedFiles: [] };
                // Helpers.log(`Source modifer async action for ${relativePathToProject}`)
                this.processFile(relativePathToProject, modifiedFiles);
                if (tnp_core_1.fse.existsSync(event.fileAbsolutePath)) {
                    this.replikatorAction(relativePathToProject, modifiedFiles);
                }
                // console.log(modifiedFiles)
                return [2 /*return*/, modifiedFiles];
            });
        });
    };
    SourceModifier.prototype.syncAction = function (absoluteFilePathes) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var modifiedFiles, relativePathesToProject;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                tnp_helpers_1.Helpers.log("[sourceModifer][sync] files to check: \n\n" + absoluteFilePathes.map(function (f) { return f + "\n"; }) + "\n\n", 1);
                modifiedFiles = { modifiedFiles: [] };
                relativePathesToProject = absoluteFilePathes.map(function (absoluteFilePath) {
                    return absoluteFilePath
                        .replace(_this.project.location, '')
                        .replace(/^\//, '');
                });
                relativePathesToProject.forEach(function (relativePathToProject) {
                    tnp_helpers_1.Helpers.log("[sourceModifier][syn] " + relativePathToProject, 1);
                    _this.processFile(relativePathToProject, modifiedFiles);
                });
                // console.log(relativePathesToProject)
                // process.exit(0)
                if (!this.project.isStandaloneProject ||
                    (this.project.isStandaloneProject && this.project.typeIs('angular-lib'))) {
                    tnp_helpers_1.Helpers.tryRemoveDir(tnp_core_2.path.join(this.project.location, tnp_config_1.config.folder.tempSrc));
                    // console.log('for app replikator', relativePathesToProject)
                    relativePathesToProject.forEach(function (relativePathToProject) {
                        _this.replikatorAction(relativePathToProject, modifiedFiles);
                    });
                }
                return [2 /*return*/, modifiedFiles];
            });
        });
    };
    SourceModifier.prototype.replikatorAction = function (relativePathToProject, modifiedFiles) {
        if (relativePathToProject.startsWith(tnp_config_1.config.folder.src)) {
            tnp_helpers_1.Helpers.log("[replikatorAction] OK " + relativePathToProject, 1);
            var orgAbsolutePath = tnp_core_2.path.join(this.project.location, relativePathToProject);
            var relativePathToTempSrc = relativePathToProject.replace(/^src/, tnp_config_1.config.folder.tempSrc);
            var destinationPath = tnp_core_2.path.join(this.project.location, relativePathToTempSrc);
            // console.log('destinationPath', destinationPath)
            if (tnp_helpers_1.Helpers.copyFile(orgAbsolutePath, destinationPath, { modifiedFiles: modifiedFiles })) {
                // console.log('process tmp file', destinationPath)
                if (tnp_core_1.fse.existsSync(destinationPath)) {
                    this.processFile(relativePathToTempSrc, modifiedFiles);
                }
            }
            else {
                // console.log('WRONG process tmp file', destinationPath)
            }
        }
        else {
            tnp_helpers_1.Helpers.log("[replikatorAction] not start with src " + relativePathToProject, 1);
        }
    };
    SourceModifier.prototype.process = function (input, relativePath) {
        var modType = this.getModType(this.project, relativePath);
        // Helpers.log(`[sourceModifier][process] modType: ${modType}, relative path: ${relativePath}`);
        // if (modType === 'tmp-src-for') {
        //   console.log(relativePath);
        //   // return input;
        // }
        // console.log(`modType: ${modType}, relatiePath: ${relativePath}`)
        input = tnp_helpers_1.Helpers.tsCodeModifier.fixApostrphes(input);
        // input = Helpers.tsCodeModifier.fixRegexes(input);
        input = _super.prototype.process.call(this, input, relativePath);
        if (this.project.isWorkspaceChildProject) {
            input = this.modWorkspaceChildrenLibsBetweenItself(input, modType, relativePath);
            input = this.modSiteChildrenLibsInClient(input, modType, relativePath);
        }
        return input;
    };
    SourceModifier.prototype.start = function (taskName, afterInitCallBack) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.project.isSite) return [3 /*break*/, 2];
                        // if(!this.project || !this.project.baseline) {
                        //   console.trace('HERE')
                        // }
                        return [4 /*yield*/, this.project.baseline.sourceModifier.start(taskName)];
                    case 1:
                        // if(!this.project || !this.project.baseline) {
                        //   console.trace('HERE')
                        // }
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, _super.prototype.start.call(this, taskName, afterInitCallBack)];
                }
            });
        });
    };
    SourceModifier.prototype.startAndWatch = function (taskName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var watchOnly;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        watchOnly = (options || {}).watchOnly;
                        tnp_helpers_1.Helpers.log("Start source modifer for " + this.project.genericName);
                        if (!this.project.isSite) return [3 /*break*/, 2];
                        // if(!this.project || !this.project.baseline) {
                        //   console.trace('HERE')
                        // }
                        return [4 /*yield*/, this.project.baseline.sourceModifier.startAndWatch(taskName, { watchOnly: watchOnly })];
                    case 1:
                        // if(!this.project || !this.project.baseline) {
                        //   console.trace('HERE')
                        // }
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, _super.prototype.startAndWatch.call(this, taskName, options)];
                }
            });
        });
    };
    tslib_1.__decorate([
        incremental_compiler_1.IncCompiler.methods.AsyncAction(),
        tslib_1.__metadata("design:type", Function),
        tslib_1.__metadata("design:paramtypes", [incremental_compiler_1.IncCompiler.Change]),
        tslib_1.__metadata("design:returntype", Promise)
    ], SourceModifier.prototype, "asyncAction", null);
    SourceModifier = tslib_1.__decorate([
        incremental_compiler_1.IncCompiler.Class({ className: 'SourceModifier' })
    ], SourceModifier);
    return SourceModifier;
}(source_mod_for_site_backend_1.SourceModForSite));
exports.SourceModifier = SourceModifier;
//# sourceMappingURL=source-modifier.backend.js.map