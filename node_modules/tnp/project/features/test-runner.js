"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
//#region @backend
var tnp_core_1 = require("tnp-core");
var tnp_core_2 = require("tnp-core");
var abstract_1 = require("../abstract");
var tnp_core_3 = require("tnp-core");
var tnp_core_4 = require("tnp-core");
//#endregion
var tnp_config_1 = require("tnp-config");
var tnp_helpers_1 = require("tnp-helpers");
var TestRunner = /** @class */ (function (_super) {
    tslib_1.__extends(TestRunner
    //#region @backend
    , _super);
    function TestRunner() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    //#region @backend
    TestRunner.prototype.fileCommand = function (files) {
        files = files.map(function (f) { return tnp_core_2.path.basename(f); });
        // console.log('files',files)
        var useFiles = (tnp_core_1._.isArray(files) && files.length > 0);
        var ext = (files.length > 1 || (!tnp_core_1._.first(files).endsWith('.spec.ts'))) ? '*.spec.ts' : '';
        var res = "" + (useFiles ? "src/**/*" + (files.length === 1 ? "" + tnp_core_1._.first(files) : "(" + files.join('|') + ")") + ext : 'src/**/*.spec.ts');
        return res;
    };
    TestRunner.prototype.start = function (files, watchMode, debugMode) {
        if (watchMode === void 0) { watchMode = false; }
        if (debugMode === void 0) { debugMode = false; }
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var command, result, errorMessage, errorMessage2, first;
            return tslib_1.__generator(this, function (_c) {
                if (this.project.typeIs('isomorphic-lib')) {
                    command = "npm-run mocha " + (debugMode ? '--debug --inspect' : '') + " -r ts-node/register " + this.fileCommand(files)
                        + (" --timeout " + tnp_config_1.config.CONST.UNIT_TEST_TIMEOUT);
                }
                if (!command) {
                    tnp_helpers_1.Helpers.error("Tests not impolemented for " + this.project._type, false, true);
                }
                try {
                    if (watchMode) {
                        tnp_helpers_1.Helpers.clearConsole();
                        tnp_helpers_1.Helpers.info("Start of testing... for watch mode");
                        result = tnp_core_4.child_process.execSync(command, {
                            stdio: ['pipe', 'pipe', 'pipe'],
                            env: tslib_1.__assign(tslib_1.__assign({}, process.env), { FORCE_COLOR: '1' }),
                            cwd: this.project.location
                        });
                        console.log(result.toString());
                    }
                    else {
                        console.info("Start of testing...");
                        this.project.run(command, { output: true }).sync();
                        console.info("End of testing...");
                    }
                }
                catch (err) {
                    errorMessage = (_a = err === null || err === void 0 ? void 0 : err.output[2]) === null || _a === void 0 ? void 0 : _a.toString();
                    errorMessage2 = (_b = err === null || err === void 0 ? void 0 : err.output[1]) === null || _b === void 0 ? void 0 : _b.toString();
                    errorMessage = (errorMessage || '');
                    errorMessage = errorMessage.replace(tnp_core_1._.first(errorMessage.split('TSError:')), '');
                    if (!errorMessage && !errorMessage2 && err.message) {
                        first = tnp_core_1._.first(err.message.split('\n'));
                        tnp_helpers_1.Helpers.error(first, true, true);
                    }
                    else {
                        tnp_helpers_1.Helpers.error(remoteAtFromCallStack(errorMessage), true, true);
                        tnp_helpers_1.Helpers.error(remoteAtFromCallStack(errorMessage2), true, true);
                    }
                    tnp_helpers_1.Helpers.error("Error during testing files *" + this.fileCommand(files) + "*", true, true);
                    //       Helpers.pressKeyAndContinue(`
                    // Fix your code and press any key...
                    //       `)
                }
                return [2 /*return*/];
            });
        });
    };
    TestRunner.prototype.startAndWatch = function (files, debug) {
        if (debug === void 0) { debug = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var execture, pathToWatch;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                if (this.project.typeIsNot('isomorphic-lib')) {
                    tnp_helpers_1.Helpers.error("Tests not impolemented for " + this.project._type, false, true);
                }
                execture = tnp_core_1._.debounce(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.start(files, true, debug)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); }, 500, {
                // leading: true
                });
                pathToWatch = this.project.path('src').absolute.normal + "/**/*.ts";
                tnp_core_3.chokidar.watch([
                    pathToWatch,
                ]).on('all', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        // console.log('EVENT!')
                        // await this.start(files, true);
                        execture();
                        return [2 /*return*/];
                    });
                }); });
                process.stdin.resume();
                return [2 /*return*/];
            });
        });
    };
    return TestRunner;
}(abstract_1.FeatureForProject
//#endregion
));
exports.TestRunner = TestRunner;
//#region @backend
function remoteAtFromCallStack(s) {
    // let oneExPass = false;
    return s.split('\n').map(function (l) {
        // if (l.trim().startsWith('at ')) { // TODO hmmm i think I don't need this.. long call stack ok when no fail
        //   if (oneExPass) {
        //     return void 0;
        //   } else {
        //     oneExPass = true;
        //   }
        // }
        return l;
    }).filter(function (l) { return !tnp_core_1._.isUndefined(l); }).join('\n').trim();
}
//#endregion
//# sourceMappingURL=test-runner.js.map