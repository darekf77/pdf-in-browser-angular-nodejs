"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//#region imports
var tnp_core_1 = require("tnp-core");
var JSON5 = require("json5");
var chalk_1 = require("chalk");
var semver = require("semver");
var abstract_1 = require("../../abstract");
var tnp_models_1 = require("tnp-models");
var tnp_helpers_1 = require("tnp-helpers");
var tnp_config_1 = require("tnp-config");
//#endregion
//#region find npm version range
function findVersionRange(rootProject, dependency) {
    var result;
    var name = tnp_core_1._.isString(dependency) ? dependency : dependency.name;
    tnp_models_1.Models.npm.ArrNpmDependencyType.find(function (depType) {
        if (tnp_core_1._.isObject(rootProject.packageJson.data[depType])) {
            var deps = rootProject.packageJson.data[depType];
            var versionRange = deps[name];
            if (tnp_core_1._.isString(versionRange) && semver.validRange(versionRange)) {
                tnp_helpers_1.Helpers.log("[findVersionRange] valid range founded \"" + name + "\":" + versionRange);
                result = versionRange;
                return true;
            }
        }
        return false;
    });
    return result;
}
exports.findVersionRange = findVersionRange;
//#endregion
function resovleNewDepsAndOverrideForProject(project) {
    var toOverrideDependencies = (project.packageJson.data.tnp.overrided &&
        project.packageJson.data.tnp.overrided.dependencies) ?
        project.packageJson.data.tnp.overrided.dependencies : {};
    if (project.isWorkspaceChildProject) {
        toOverrideDependencies = {};
    }
    var parentOverride = {};
    var orgNewDeps = tnp_core_1._.cloneDeep(abstract_1.Project.Tnp.packageJson.data.dependencies);
    var newDepsForProject = {};
    // if ((Project.Tnp as Project).packageJson.data.tnp.overrided.dependencies) { // TODO QUICK_FIX
    tnp_core_1._.cloneDeep(abstract_1.Project.Tnp.packageJson.data.tnp.overrided.dependencies);
    // }
    if (project.isStandaloneProject && !project.isTnp) {
        newDepsForProject = getAndTravelCoreDeps({ type: project._type });
    }
    else if ((project.isWorkspace && project.isContainerChild) || project.isWorkspaceChildProject) {
        newDepsForProject = tnp_core_1._.cloneDeep(project.parent.packageJson.data.dependencies);
        parentOverride = tnp_core_1._.cloneDeep(project.parent.packageJson.data.tnp.overrided.dependencies);
    }
    else {
        newDepsForProject = getAndTravelCoreDeps();
    }
    // console.log(JSON10.stringify(toOverrideDependencies))
    // try {
    tnp_core_1._.merge(newDepsForProject, toOverrideDependencies);
    // } catch (error) {
    //   console.log(JSON10.stringify(toOverrideDependencies))
    //   process.exit(0)
    // }
    Object.keys(newDepsForProject).forEach(function (key) {
        if (tnp_core_1._.isNull(newDepsForProject[key])) {
            newDepsForProject[key] = void 0;
        }
    });
    return {
        orgNewDeps: orgNewDeps,
        newDepsForProject: newDepsForProject,
        toOverrideDependencies: toOverrideDependencies,
        parentOverride: parentOverride
    };
}
//#region resolve and save deps for project
function reolveAndSaveDeps(project, action, reasonToHidePackages, reasonToShowPackages) {
    var orginalDependencies = !project.packageJson.data.dependencies ? {}
        : tnp_core_1._.cloneDeep(project.packageJson.data.dependencies);
    var orginalDevDependencies = !project.packageJson.data.devDependencies ? {}
        : tnp_core_1._.cloneDeep(project.packageJson.data.devDependencies);
    var _a = resovleNewDepsAndOverrideForProject(project), newDepsForProject = _a.newDepsForProject, toOverrideDependencies = _a.toOverrideDependencies;
    overrideInfo({ orginalDependencies: orginalDependencies, orginalDevDependencies: orginalDevDependencies }, toOverrideDependencies, newDepsForProject);
    beforeSaveAction(project, {
        newDeps: newDepsForProject,
        toOverride: toOverrideDependencies,
        action: action,
        reasonToHidePackages: reasonToHidePackages,
        reasonToShowPackages: reasonToShowPackages,
    });
}
exports.reolveAndSaveDeps = reolveAndSaveDeps;
//#endregion
//#region override info
function overrideInfo(deps, toOverrideDependencies, newDepsForProject) {
    var orginalDependencies = deps.orginalDependencies, orginalDevDependencies = deps.orginalDevDependencies;
    function check(orgDeps, checkinDev) {
        Object.keys(orgDeps).forEach(function (oldDepName) {
            if (orgDeps[oldDepName] !== newDepsForProject[oldDepName]) {
                //#region variables
                var oppositeOrgDeps = (checkinDev ? orginalDependencies : orginalDependencies);
                var overrideMsg = void 0;
                var foundedInOposite = false;
                var versionFrom = orgDeps[oldDepName];
                if (!versionFrom && oppositeOrgDeps[oldDepName]) {
                    versionFrom = oppositeOrgDeps[oldDepName];
                    foundedInOposite = true;
                }
                var versionTo = newDepsForProject[oldDepName];
                //#endregion
                if (toOverrideDependencies && !tnp_core_1._.isUndefined(toOverrideDependencies[oldDepName])) {
                    if (tnp_core_1._.isNull(toOverrideDependencies[oldDepName])) {
                        if (versionFrom) {
                            overrideMsg = "Overrided/Remoed " + oldDepName;
                        }
                        else {
                            overrideMsg = "Overrided without any sense " + oldDepName;
                        }
                    }
                    else {
                        if (versionFrom) {
                            if (versionFrom === versionTo) {
                                overrideMsg = "Overrided not necessary \"" + oldDepName + "@" + versionFrom + "\"";
                            }
                            else {
                                overrideMsg = "Overrided \"" + oldDepName + "\" " + versionFrom + "=>" + versionTo;
                            }
                        }
                        else {
                            overrideMsg = "Overrided/Added new packge " + oldDepName + "@" + versionTo;
                        }
                    }
                }
                else {
                    if (tnp_core_1._.isString(versionFrom) && tnp_core_1._.isString(versionTo)) {
                        if (versionFrom !== versionFrom) {
                            overrideMsg = "Version change \"" + oldDepName + "\" " + versionFrom + "=>" + versionTo;
                        }
                    }
                    if (!versionFrom && tnp_core_1._.isString(versionTo)) {
                        // if (!(Project.Tnp as Project).packageJson.data.tnp.core.dependencies.asDevDependencies.includes(oldDepName)) {
                        overrideMsg = "Added new package \"" + oldDepName + "@" + versionTo + "\"";
                        // }
                    }
                    if (tnp_core_1._.isString(versionFrom) && !versionTo) {
                        overrideMsg = "Removed package \"" + oldDepName + "@" + versionTo + "\"";
                    }
                }
                if (overrideMsg) {
                    // Helpers.log(`[override-info] ${overrideMsg}`);
                }
                else {
                    // warn(`No override info `);
                }
            }
        });
    }
    check(orginalDependencies, false);
    check(orginalDevDependencies, true);
}
//#endregion
function removeDepsByType(deps, libType) {
    var depsByType = abstract_1.Project.Tnp.packageJson.data.tnp.core.dependencies.onlyFor[libType];
    var names = depsByType ? Object.keys(depsByType) : [];
    names.forEach(function (key) {
        delete deps[key];
    });
    return deps;
}
//#region before save action
function beforeSaveAction(project, options) {
    var newDeps = options.newDeps, toOverride = options.toOverride, action = options.action, reasonToHidePackages = options.reasonToHidePackages, reasonToShowPackages = options.reasonToShowPackages;
    var engines = abstract_1.Project.Tnp.packageJson.data.engines;
    var license = project.isStandaloneProject ? 'MIT' : 'UNLICENSED';
    var prv = (project.isStandaloneProject || project.isUnknowNpmProject) ? false : true;
    var recrateInPackageJson = (action === 'save' || action === 'show');
    if (project.isTnp) {
        recrateInPackageJson = true;
    }
    if (recrateInPackageJson && action === 'save' && (project.isWorkspaceChildProject || (project.isContainerChild && project.isWorkspace))) {
        recrateInPackageJson = false;
    }
    if (project.frameworkVersionAtLeast('v2') && !global.actionShowingDepsForContainer) {
        var projForVer = abstract_1.Project.by('container', project._frameworkVersion);
        if (projForVer) { // QUICK_FIX?
            global.actionShowingDepsForContainer = true;
            projForVer.packageJson.showDeps("update deps for project " + project.genericName + " in version " + project._frameworkVersion);
            global.actionShowingDepsForContainer = false;
            var depsForVer_1 = projForVer.packageJson.data;
            Object.keys(depsForVer_1.dependencies).forEach(function (pkgNameInNewVer) {
                // Helpers.log(`Change "${chalk.bold(pkgNameInNewVer)}": ${newDeps[pkgNameInNewVer]} => ${depsForVer.dependencies[pkgNameInNewVer]}`)
                newDeps[pkgNameInNewVer] = depsForVer_1.dependencies[pkgNameInNewVer];
            });
        }
    }
    else {
        cleanForIncludeOnly(project, newDeps, toOverride);
    }
    var devDependencies = {};
    var dependencies = {};
    if (project.frameworkVersionEquals('v1')) {
        devDependencies = project.isStandaloneProject ?
            tnp_helpers_1.Helpers.arrays.sortKeys(filterDevDepOnly(project, tnp_core_1._.cloneDeep(newDeps)))
            : {};
        dependencies = project.isStandaloneProject ?
            tnp_helpers_1.Helpers.arrays.sortKeys(filterDepOnly(project, tnp_core_1._.cloneDeep(newDeps)))
            : tnp_helpers_1.Helpers.arrays.sortKeys(newDeps);
    }
    else {
        devDependencies = project.isStandaloneProject ?
            tnp_helpers_1.Helpers.arrays.sortKeys(tnp_core_1._.cloneDeep(newDeps))
            : {};
        dependencies = project.isStandaloneProject ?
            tnp_helpers_1.Helpers.arrays.sortKeys(tnp_core_1._.cloneDeep(newDeps))
            : tnp_helpers_1.Helpers.arrays.sortKeys(newDeps);
    }
    if (!project.isTnp && !project.isContainerCoreProject) {
        var specyficPacakges = [
            'electron-client',
            'vscode-ext',
            'chrome-ext',
        ];
        specyficPacakges.forEach(function (s) {
            if (project.typeIsNot(s)) {
                devDependencies = removeDepsByType(devDependencies, s);
                dependencies = removeDepsByType(dependencies, s);
            }
        });
    }
    if (project.packageJson.data.tnp.overrided.includeAsDev === '*') {
        devDependencies = tnp_core_1._.merge(devDependencies, dependencies);
        dependencies = {};
        // console.log('inlcude as dev', devDependencies)
    }
    var onlyAllowedInDependencies = project.packageJson.data.tnp.overrided.includeOnly || [];
    if (project.frameworkVersionAtLeast('v2') && onlyAllowedInDependencies.length > 0) {
        // Helpers.info(`Inlcude only: \n${onlyAllowedInDependencies.join('\n')}`);
        var keyToDeleteDevDeps_1 = [];
        Object.keys(devDependencies)
            .filter(function (key) { return !!devDependencies[key]; })
            .forEach(function (key) {
            // Helpers.info(`key devDependencies: ${key}@${devDependencies[key]}`)
            if (onlyAllowedInDependencies.includes(key)) {
                // Helpers.log(`Fix in devDependencies: ${key}@${devDependencies[key]}`);
                dependencies[key] = devDependencies[key];
                keyToDeleteDevDeps_1.push(key);
            }
        });
        var keyToDeleteDeps_1 = [];
        Object.keys(dependencies)
            .filter(function (key) { return !!dependencies[key]; })
            .forEach(function (key) {
            // Helpers.info(`key dependencies: ${key}@${dependencies[key]}`)
            if (!onlyAllowedInDependencies.includes(key)) {
                // Helpers.log(`Fix in dependencies: ${key}@${dependencies[key]}`);
                devDependencies[key] = dependencies[key];
                keyToDeleteDeps_1.push(key);
            }
        });
        keyToDeleteDeps_1.forEach(function (key) {
            delete dependencies[key];
        });
        keyToDeleteDevDeps_1.forEach(function (key) {
            delete devDependencies[key];
        });
        // Helpers.log(`${chalk.bold('dependencies')}: \n${JSON.stringify(dependencies, null, 2)}`);
        // Helpers.log(`${chalk.bold('devDependencies')}: \n${JSON.stringify(devDependencies, null, 2)}`);
    }
    if (recrateInPackageJson) {
        tnp_helpers_1.Helpers.log("[package.json] save for install - " + project._type + " project: \"" + project.name + "\" , [" + reasonToShowPackages + "]");
        if (project.isTnp) {
            project.packageJson.data.devDependencies = {};
            project.packageJson.data.dependencies = tnp_helpers_1.Helpers.arrays.sortKeys(newDeps);
        }
        else {
            project.packageJson.data.devDependencies = devDependencies;
            project.packageJson.data.dependencies = dependencies;
        }
        //#region  install latest version of package
        var isomorphicPackages_1 = abstract_1.Project.Tnp.availableIsomorphicPackagesInNodeModules;
        // TODO firedev should be handled here
        Object.keys(project.packageJson.data.devDependencies)
            .filter(function (key) { return isomorphicPackages_1.includes(key); })
            .forEach(function (packageIsomorphicName) {
            var v = project.packageJson.data.devDependencies[packageIsomorphicName];
            if (!(v === null || v === void 0 ? void 0 : v.startsWith('~')) && !(v === null || v === void 0 ? void 0 : v.startsWith('^'))) {
                project.packageJson.data.devDependencies[packageIsomorphicName] = "~" + v;
            }
        });
        Object.keys(project.packageJson.data.dependencies)
            .filter(function (key) { return isomorphicPackages_1.includes(key); })
            .forEach(function (packageIsomorphicName) {
            var v = project.packageJson.data.dependencies[packageIsomorphicName];
            if (!(v === null || v === void 0 ? void 0 : v.startsWith('~')) && !(v === null || v === void 0 ? void 0 : v.startsWith('^'))) {
                project.packageJson.data.dependencies[packageIsomorphicName] = "~" + v;
            }
        });
        //#endregion
        if (!project.isCoreProject && !project.isVscodeExtension) {
            project.packageJson.data.engines = engines;
        }
    }
    else {
        tnp_helpers_1.Helpers.log("[package.json] save for clean - " + project._type + " project: \"" + project.name + "\" , [" + reasonToHidePackages + "]");
        project.packageJson.data.devDependencies = {};
        project.packageJson.data.dependencies = {};
        if (!project.isCoreProject && !project.isVscodeExtension) {
            project.packageJson.data.engines = void 0;
        }
    }
    tnp_helpers_1.Helpers.log("Project: " + chalk_1.default.bold(project.genericName) + ", framework verison: " + project._frameworkVersion);
    project.packageJson.data.license = license;
    project.packageJson.data.private = prv;
    if (project.isTnp) {
        tnp_helpers_1.Helpers.info("Execute " + tnp_config_1.config.frameworkName + " action");
        var keysToDelete_1 = [];
        Object.keys(project.packageJson.data.tnp.overrided.dependencies).forEach(function (pkgName) {
            var version = project.packageJson.data.tnp.overrided.dependencies[pkgName];
            if (!version && !devDependencies[pkgName] && !dependencies[pkgName]) {
                keysToDelete_1.push(pkgName);
            }
        });
        keysToDelete_1.forEach(function (key) {
            delete project.packageJson.data.tnp.overrided.dependencies[key];
        });
    }
    if (project.frameworkVersionAtLeast('v2')) {
        if (tnp_core_1._.isEqual(project.packageJson.data.dependencies, project.packageJson.data.devDependencies)) {
            // TODO QUICK_FIX
            var includeAsDev = (project.packageJson.data.tnp.overrided.includeAsDev);
            var includeOnly = (project.packageJson.data.tnp.overrided.includeOnly);
            if (tnp_core_1._.isArray(includeAsDev) && includeAsDev.length === 0 &&
                tnp_core_1._.isArray(includeOnly) && includeOnly.length === 0) {
                project.packageJson.data.devDependencies = {};
            }
            if (project.isVscodeExtension) {
                project.packageJson.data.devDependencies['vscode'] = project.packageJson.data.dependencies['vscode'];
                delete project.packageJson.data.dependencies['vscode'];
            }
        }
    }
}
//#endregion
//#region get deps by
function getAndTravelCoreDeps(options) {
    var project = abstract_1.Project.Tnp;
    if (tnp_core_1._.isUndefined(options)) {
        options = {};
    }
    var updateFn = options.updateFn, type = options.type;
    var constantTnpDeps = {};
    // if (project?.packageJson?.data?.tnp?.core?.dependencies) { // TODO QUICK FIX
    var core = project.packageJson.data.tnp.core.dependencies;
    travelObject(core.common, constantTnpDeps, void 0, updateFn);
    if (tnp_core_1._.isString(type)) {
        travelObject(core.onlyFor[type], constantTnpDeps, core.onlyFor, updateFn);
    }
    else {
        Object.keys(core.onlyFor).forEach(function (libType) {
            travelObject(core.onlyFor[libType], constantTnpDeps, void 0, updateFn);
        });
    }
    // }
    return constantTnpDeps;
}
exports.getAndTravelCoreDeps = getAndTravelCoreDeps;
//#endregion
//#region deps filters
function filterDevDepOnly(project, deps) {
    var devDeps = abstract_1.Project.Tnp.packageJson.data.tnp.core.dependencies.asDevDependencies;
    var onlyAsDevAllowed = (project.packageJson.data.tnp &&
        project.packageJson.data.tnp.overrided &&
        project.packageJson.data.tnp.overrided.includeAsDev) || [];
    var allDeps = getAndTravelCoreDeps();
    // log('d1evDeps', devDeps)
    Object.keys(deps).forEach(function (name) {
        if (!devDeps.includes(name)) {
            deps[name] = undefined;
        }
    });
    if (!tnp_core_1._.isArray(onlyAsDevAllowed)) {
        onlyAsDevAllowed = [];
    }
    Object.keys(allDeps).forEach(function (name) {
        if (onlyAsDevAllowed.includes(name) || onlyAsDevAllowed.filter(function (d) { return (new RegExp(d)).test(name); }).length > 0) {
            deps[name] = allDeps[name];
        }
    });
    return deps;
}
function filterDepOnly(project, deps) {
    var devDeps = abstract_1.Project.Tnp.packageJson.data.tnp.core.dependencies.asDevDependencies;
    var onlyAsDevAllowed = (project.packageJson.data.tnp
        && project.packageJson.data.tnp.overrided
        && project.packageJson.data.tnp.overrided.includeAsDev) || [];
    // log('d2evDeps', devDeps)
    if (!tnp_core_1._.isArray(onlyAsDevAllowed)) {
        onlyAsDevAllowed = [];
    }
    Object.keys(deps).forEach(function (name) {
        if (devDeps.includes(name) || onlyAsDevAllowed.includes(name) ||
            onlyAsDevAllowed.filter(function (f) { return (new RegExp(f)).test(name); }).length > 0) {
            deps[name] = undefined;
        }
    });
    return deps;
}
//#endregion
//#region clean for include only
function cleanForIncludeOnly(project, deps, overrided) {
    // log('overrided', overrided)
    deps[project.name] = undefined;
    if (project.packageJson.data.tnp &&
        project.packageJson.data.tnp.overrided &&
        tnp_core_1._.isArray(project.packageJson.data.tnp.overrided.includeOnly) &&
        project.packageJson.data.tnp.overrided.includeOnly.length > 0) {
        var onlyAllowed_1 = project.packageJson.data.tnp.overrided.includeOnly;
        onlyAllowed_1 = onlyAllowed_1.concat(abstract_1.Project.Tnp.packageJson.data.tnp.core.dependencies.always);
        Object.keys(deps).forEach(function (depName) {
            if (!onlyAllowed_1.includes(depName)) {
                deps[depName] = undefined;
            }
        });
        return;
    }
    if (project.packageJson.data.tnp &&
        project.packageJson.data.tnp.overrided &&
        tnp_core_1._.isArray(project.packageJson.data.tnp.overrided.ignoreDepsPattern)) {
        var patterns = project.packageJson.data.tnp.overrided.ignoreDepsPattern;
        patterns.forEach(function (p) {
            Object.keys(deps).forEach(function (depName) {
                tnp_helpers_1.Helpers.log("check patter: " + p + " agains " + depName);
                var patternRegex = (new RegExp(tnp_helpers_1.Helpers.escapeStringForRegEx(p)));
                if (patternRegex.test(depName) && !overrided[depName]) {
                    deps[depName] = undefined;
                }
            });
        });
    }
}
//#endregion
//#region travel object
function travelObject(obj, out, parent, updateFn) {
    if (!tnp_core_1._.isObject(obj)) {
        return;
    }
    Object.keys(obj).forEach(function (key) {
        var extendable = new RegExp("^@[0-9]$");
        if (!extendable.test(key)) {
            if (!tnp_core_1._.isArray(obj[key])) {
                if (tnp_core_1._.isObject(obj[key])) {
                    travelObject(obj[key], out, obj[key], updateFn);
                }
                else {
                    if (tnp_core_1._.isString(out[key])) {
                        tnp_helpers_1.Helpers.error("Duplicate key in workspace package.json tnp.core packages configuration:\n            \"" + key + "\": \"" + out[key] + "\"\n          ");
                    }
                    if (tnp_core_1._.isFunction(updateFn)) {
                        out[key] = updateFn(obj, key);
                    }
                    else {
                        out[key] = obj[key];
                    }
                }
            }
        }
        else if (!!parent) {
            // console.log('parent!11')
            // console.log(`parent[${key}]`, parent[key])
            travelObject(parent[obj[key]], out, parent, updateFn);
        }
    });
}
//#endregion
//#region set dependency and save
function setDependencyAndSave(p, reason, project) {
    // console.log('set DEPS', p)
    // process.exit(0)
    if (!p || !p.name) {
        tnp_helpers_1.Helpers.error("Cannot set invalid dependency for project " + project.genericName + ": " + JSON5.stringify(p), false, true);
    }
    project = (project.isWorkspaceChildProject ? project.parent : project);
    if (project.isTnp && !tnp_core_1._.isString(p.version)) {
        try {
            p.version = tnp_helpers_1.Helpers.run("npm show " + p.name + " version", { output: false }).sync().toString().trim();
        }
        catch (e) {
            tnp_helpers_1.Helpers.error("No able to find package with name " + p.name, false, true);
        }
    }
    if (project.isTnp) {
        var updated_1 = false;
        getAndTravelCoreDeps({
            updateFn: function (obj, pkgName) {
                if (pkgName === p.name) {
                    obj[pkgName] = p.version;
                    updated_1 = true;
                }
                return obj[pkgName];
            }
        });
        if (!updated_1) {
            project.packageJson.data.tnp.overrided.dependencies[p.name] = p.version;
        }
    }
    else if (project.isUnknowNpmProject) {
        if (p.installType === '--save') {
            if (!project.packageJson.data.dependencies) {
                project.packageJson.data.dependencies = {};
            }
            project.packageJson.data.dependencies[p.name] = p.version;
        }
        else if (p.installType === '--save-dev') {
            if (!project.packageJson.data.devDependencies) {
                project.packageJson.data.devDependencies = {};
            }
            project.packageJson.data.devDependencies[p.name] = p.version;
        }
    }
    else if (project.isStandaloneProject || project.isWorkspace || project.isContainer) {
        if (p.version) {
            project.packageJson.data.tnp.overrided.dependencies[p.name] = p.version;
        }
        else {
            var _a = resovleNewDepsAndOverrideForProject(project), parentOverride = _a.parentOverride, orgNewDeps = _a.orgNewDeps;
            if (tnp_core_1._.isNull(parentOverride[p.name])) {
                project.packageJson.data.tnp.overrided.dependencies[p.name] = orgNewDeps[p.name];
            }
            else {
                delete project.packageJson.data.tnp.overrided.dependencies[p.name];
                tnp_helpers_1.Helpers.log("Parent package version reverted");
            }
        }
    }
    project.packageJson.save("[" + reason + "] [setDependency] name:" + (p && p.name) + ", ver:" + (p && p.version) + " in project " + (project && project.genericName));
}
exports.setDependencyAndSave = setDependencyAndSave;
//#endregion
//#region remove dependency and save
function removeDependencyAndSave(p, reason, project) {
    if (!p || !p.name) {
        tnp_helpers_1.Helpers.error("Cannot remove invalid dependency for project " + project.genericName + ": " + JSON5.stringify(p), false, true);
    }
    project = (project.isWorkspaceChildProject ? project.parent : project);
    if (project.isTnp) {
        getAndTravelCoreDeps({
            updateFn: function (obj, pkgName) {
                if (pkgName === p.name) {
                    obj[pkgName] = void 0;
                }
                return obj[pkgName];
            }
        });
    }
    if (project.isUnknowNpmProject) {
        project.packageJson.data.dependencies[p.name] = void 0;
        project.packageJson.data.devDependencies[p.name] = void 0;
    }
    else {
        if (project.isTnp) {
            var existedOverrideVer = project.packageJson.data.tnp.overrided.dependencies[p.name];
            if (tnp_core_1._.isString(existedOverrideVer) || tnp_core_1._.isNull(existedOverrideVer)) {
                project.packageJson.data.tnp.overrided.dependencies[p.name] = null;
            }
        }
        else {
            var newDepsForProject = resovleNewDepsAndOverrideForProject(project).newDepsForProject;
            var parentPkg = newDepsForProject[p.name];
            if (tnp_core_1._.isString(parentPkg)) {
                project.packageJson.data.tnp.overrided.dependencies[p.name] = null;
            }
            if (tnp_core_1._.isNull(parentPkg) || tnp_core_1._.isUndefined(parentPkg)) {
                project.packageJson.data.tnp.overrided.dependencies[p.name] = void 0;
            }
        }
    }
    project.packageJson.save("[" + reason + "] [removeDependency] name:" + (p && p.name) + " in project " + (project && project.genericName));
}
exports.removeDependencyAndSave = removeDependencyAndSave;
//#endregion
//# sourceMappingURL=package-json-helpers.backend.js.map