"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var tnp_core_1 = require("tnp-core");
var JSON5 = require("json5");
var inquirer = require("inquirer");
var abstract_1 = require("../../abstract");
var tnp_helpers_1 = require("tnp-helpers");
var tnp_config_1 = require("tnp-config");
var PackageJsonDepsCoreCategories = /** @class */ (function (_super) {
    tslib_1.__extends(PackageJsonDepsCoreCategories, _super);
    function PackageJsonDepsCoreCategories() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.s_onlyFor = 'onlyFor';
        _this.s_common = 'common';
        return _this;
    }
    Object.defineProperty(PackageJsonDepsCoreCategories.prototype, "all", {
        get: function () {
            return abstract_1.Project.Tnp.packageJson.data.tnp.core.dependencies;
        },
        enumerable: true,
        configurable: true
    });
    PackageJsonDepsCoreCategories.prototype.for = function (libType) {
        var _this = this;
        var result = this.all[this.s_onlyFor][libType];
        tnp_core_1._.keys(result).find(function (key) {
            if (key === '@') {
                result = _this.for(result[key]);
                return true;
            }
            return false;
        });
        return result;
    };
    Object.defineProperty(PackageJsonDepsCoreCategories.prototype, "commonForAllLibTypes", {
        // private forAsFlat(libType: LibType) {
        //   const result = {};
        //   Object.keys(this.for(libType)).forEach(categoryKey => {
        //     if (_.isObject(this.for(libType)[categoryKey])) {
        //       _.merge(result, this.for(libType)[categoryKey])
        //     } else {
        //       result[categoryKey] = this.for(libType)[categoryKey];
        //     }
        //   });
        //   return result;
        // }
        get: function () {
            return this.all[this.s_common];
        },
        enumerable: true,
        configurable: true
    });
    // private get commonForAllLibTypesAsFlat() {
    //   const result = {};
    //   Object.keys(this.commonForAllLibTypes).forEach(categoryKey => {
    //     if (_.isObject(this.commonForAllLibTypes[categoryKey])) {
    //       _.merge(result, this.commonForAllLibTypes[categoryKey]);
    //     } else {
    //       result[categoryKey] = this.commonForAllLibTypes[categoryKey];
    //     }
    //   });
    //   return result;
    // }
    PackageJsonDepsCoreCategories.prototype.removeAllWithName = function (name) {
        var _this = this;
        function rem(deps) {
            if (tnp_core_1._.isString(deps[name])) {
                delete deps[name];
            }
            tnp_core_1._.keys(deps).forEach(function (category) {
                if (tnp_core_1._.isString(deps[category][name])) {
                    delete deps[category][name];
                }
                else if (tnp_core_1._.isObject(deps[category][name])) {
                    rem(deps[category][name]);
                }
            });
        }
        rem(this.commonForAllLibTypes);
        tnp_config_1.CoreLibCategoryArr.forEach(function (type) {
            var deps = _this.for(type);
            if (deps) {
                rem(deps);
            }
        });
    };
    PackageJsonDepsCoreCategories.prototype.getBy = function (name) {
        var _this = this;
        function cattt(deps, cat) {
            if (tnp_core_1._.isString(deps[name])) {
                return { category: cat, version: deps[name] };
            }
            var result;
            tnp_core_1._.keys(deps).find(function (c) {
                if (tnp_core_1._.isString(deps[c][name])) {
                    result = { category: cat + "." + c, version: deps[c][name] };
                    return true;
                }
                else if (tnp_core_1._.isObject(deps[c][name])) {
                    result = cattt(deps[c][name], cat + "." + c);
                    return tnp_core_1._.isObject(result);
                }
            });
            return result;
        }
        var fromCommon = cattt(this.commonForAllLibTypes, 'common');
        if (tnp_core_1._.isObject(fromCommon)) {
            return fromCommon;
        }
        var result;
        tnp_config_1.CoreLibCategoryArr.find(function (type) {
            var deps = _this.for(type);
            if (deps) {
                result = cattt(deps, type);
                return tnp_core_1._.isObject(result);
            }
            return false;
        });
        return result;
    };
    PackageJsonDepsCoreCategories.prototype.setWizard = function (pkg) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var type;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tnp_helpers_1.Helpers.info('Please select at lease one client..');
                        return [4 /*yield*/, inquirer
                                .prompt([
                                {
                                    type: 'list',
                                    name: 'type',
                                    message: 'Select lib type ',
                                    choices: tnp_config_1.CoreLibCategoryArr.reverse()
                                        .map(function (c) {
                                        var name = tnp_core_1._.startCase(c);
                                        if (c === 'common') {
                                            name = "<< Common for all libs >>";
                                        }
                                        return { value: c, name: name };
                                    })
                                }
                            ])];
                    case 1:
                        type = (_a.sent()).type;
                        // TODO finish it later
                        process.exit(0);
                        return [2 /*return*/];
                }
            });
        });
    };
    PackageJsonDepsCoreCategories.prototype.set = function (pkg, type) {
        if (!tnp_config_1.CoreLibCategoryArr.includes(type)) {
            tnp_helpers_1.Helpers.error("[depscorecategories][set] Incrorrect type " + type, false, true);
        }
        if (!pkg || !pkg.name || !pkg.version) {
            tnp_helpers_1.Helpers.error("[depscorecategories][set] Incrorrect package " + JSON5.stringify(pkg), false, true);
        }
        this.removeAllWithName(pkg.name);
        if (type === 'common') {
            this.all.common[pkg.name] = pkg.version;
        }
        else {
            if (!this.all.onlyFor[type]) {
                this.all.onlyFor[type] = {};
            }
            this.all.onlyFor[type][pkg.name] = pkg.version;
        }
    };
    return PackageJsonDepsCoreCategories;
}(abstract_1.FeatureForProject));
exports.PackageJsonDepsCoreCategories = PackageJsonDepsCoreCategories;
//# sourceMappingURL=package-json-deps-categories.backend.js.map