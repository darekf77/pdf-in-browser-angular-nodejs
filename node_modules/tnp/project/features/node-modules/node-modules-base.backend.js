"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
//#region imports
var tnp_core_1 = require("tnp-core");
var tnp_core_2 = require("tnp-core");
var tnp_core_3 = require("tnp-core");
var tnp_cli_1 = require("tnp-cli");
var TerminalProgressBar = require("progress");
var tnp_config_1 = require("tnp-config");
var abstract_1 = require("../../abstract");
var tnp_models_1 = require("tnp-models");
var tnp_helpers_1 = require("tnp-helpers");
var node_modules_helpers_backend_1 = require("./node-modules-helpers.backend");
var node_modules_core_backend_1 = require("./node-modules-core.backend");
//#endregion
var NodeModulesBase = /** @class */ (function (_super) {
    tslib_1.__extends(NodeModulesBase, _super);
    function NodeModulesBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Copy (just linke npm install) all package from
     * source project node_modules to itself
     * @param source project - source of node_modules
     * @param triggerMsg reason to copy packages
     */
    NodeModulesBase.prototype.copyFrom = function (source, triggerMsg) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var index, depName, deppp, index2, dep;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tnp_helpers_1.Helpers.log("[node_modules] Copy instalation of npm packages from " +
                            (tnp_cli_1.CLI.chalk.bold(source.genericName) + " to " + tnp_cli_1.CLI.chalk.bold(this.project.genericName) + " " + triggerMsg));
                        if (source.smartNodeModules.exists) {
                            this.project.node_modules.remove();
                            tnp_helpers_1.Helpers.mkdirp(this.project.node_modules.path);
                            tnp_helpers_1.Helpers.foldersFrom(source.smartNodeModules.path)
                                .filter(function (f) { return tnp_core_1.path.basename(f) !== _this.project.name; }) // TODO check this fix for weird things with /browser
                                .forEach(function (f) {
                                var dest = tnp_core_1.path.join(_this.project.node_modules.path, tnp_core_1.path.basename(f));
                                if (tnp_core_1.path.basename(f) === '.bin') {
                                    tnp_helpers_1.Helpers.copy(f, dest);
                                }
                                else {
                                    tnp_helpers_1.Helpers.createSymLink(f, dest, { speedUpProcess: true });
                                }
                            });
                            return [2 /*return*/];
                        }
                        source.packageJson.save("instalation of packages from " + this.project.genericName + " " + triggerMsg);
                        index = 0;
                        _a.label = 1;
                    case 1:
                        if (!(index < tnp_models_1.Models.npm.ArrNpmDependencyType.length)) return [3 /*break*/, 6];
                        depName = tnp_models_1.Models.npm.ArrNpmDependencyType[index];
                        deppp = source.getDepsAsProject(depName);
                        index2 = 0;
                        _a.label = 2;
                    case 2:
                        if (!(index2 < deppp.length)) return [3 /*break*/, 5];
                        dep = deppp[index2];
                        return [4 /*yield*/, source.node_modules.copy(dep.name).to(this.project)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        index2++;
                        return [3 /*break*/, 2];
                    case 5:
                        index++;
                        return [3 /*break*/, 1];
                    case 6:
                        source.node_modules.copyBin.to(this.project);
                        // global.spinner.start()
                        // const overridedDeps = this.project.getDepsAsPackage('tnp_overrided_dependencies');
                        // for (let indexOverridedDeps = 0; indexOverridedDeps < overridedDeps.length; indexOverridedDeps++) {
                        //   const d = overridedDeps[indexOverridedDeps];
                        //   await this.project.npmPackages.install(triggerMsg, d);
                        // }
                        this.project.node_modules.dedupe();
                        return [2 /*return*/];
                }
            });
        });
    };
    Object.defineProperty(NodeModulesBase.prototype, "copyBin", {
        get: function () {
            var self = this;
            return {
                to: function (destinationProject, linkOnly) {
                    if (linkOnly === void 0) { linkOnly = false; }
                    var source = tnp_core_1.path.join(self.project.location, tnp_config_1.config.folder.node_modules, tnp_config_1.config.folder._bin);
                    var dest = tnp_core_1.path.join(destinationProject.location, tnp_config_1.config.folder.node_modules, tnp_config_1.config.folder._bin);
                    if (tnp_core_2.fse.existsSync(source)) {
                        if (linkOnly) {
                            tnp_helpers_1.Helpers.createSymLink(source, dest);
                        }
                        else {
                            tnp_helpers_1.Helpers.copy(source, dest);
                        }
                        ;
                    }
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     *  copy package to project
     * @param pkg
     * @param options
     */
    NodeModulesBase.prototype.copy = function (pkg, options) {
        var self = this;
        return {
            to: function (destination) {
                return tslib_1.__awaiter(this, void 0, void 0, function () {
                    var _a, _b, override, _c, linkOnly, packageName, projToCopy, nodeModeulesPath, pDestPath, addedSuccess, orghideInfos, orghideWarnings, orghideLog, depsNames, prog;
                    return tslib_1.__generator(this, function (_d) {
                        _a = options || {}, _b = _a.override, override = _b === void 0 ? false : _b, _c = _a.linkOnly, linkOnly = _c === void 0 ? false : _c;
                        packageName = (tnp_core_3._.isObject(pkg) ? pkg.name : pkg);
                        projToCopy = abstract_1.Project.From(tnp_core_1.path.join(self.project.location, tnp_config_1.config.folder.node_modules, packageName));
                        nodeModeulesPath = tnp_core_1.path.join(destination.location, tnp_config_1.config.folder.node_modules);
                        if (!tnp_core_2.fse.existsSync(nodeModeulesPath)) {
                            tnp_helpers_1.Helpers.mkdirp(nodeModeulesPath);
                        }
                        pDestPath = tnp_core_1.path.join(nodeModeulesPath, projToCopy.name);
                        if (linkOnly) {
                            projToCopy.linkTo(pDestPath);
                        }
                        else {
                            addedSuccess = projToCopy.copyManager.generateSourceCopyIn(pDestPath, { override: override, filterForBundle: false, showInfo: false });
                            if (!addedSuccess) {
                                return [2 /*return*/];
                            }
                        }
                        orghideInfos = global.hideInfos;
                        global.hideInfos = true;
                        orghideWarnings = global.hideWarnings;
                        global.hideWarnings = true;
                        orghideLog = global.hideLog;
                        global.hideLog = true;
                        depsNames = node_modules_helpers_backend_1.addDependenceis(self.project, self.project.location);
                        global.hideInfos = orghideInfos;
                        global.hideWarnings = orghideWarnings;
                        global.hideLog = orghideLog;
                        prog = new TerminalProgressBar('Please wait: :current / :total', depsNames.length);
                        depsNames
                            // .filter(dep => dep !== self.project.name)
                            .forEach(function (pkgName) {
                            var pDestPathPackage = tnp_core_1.path.join(nodeModeulesPath, pkgName);
                            projToCopy = abstract_1.Project.From(tnp_core_1.path.join(self.project.location, tnp_config_1.config.folder.node_modules, pkgName));
                            if (projToCopy) {
                                if (linkOnly) {
                                    projToCopy.linkTo(pDestPathPackage);
                                }
                                else {
                                    projToCopy.copyManager.generateSourceCopyIn(pDestPathPackage, { override: override, filterForBundle: false, showInfo: false });
                                }
                            }
                            else {
                                tnp_helpers_1.Helpers.warn("This is not a npm package: '" + pkgName + "' inside \"" + self.project.location + "\"");
                            }
                            prog.tick();
                        });
                        prog.terminate();
                        return [2 /*return*/];
                    });
                });
            }
        };
    };
    return NodeModulesBase;
}(node_modules_core_backend_1.NodeModulesCore));
exports.NodeModulesBase = NodeModulesBase;
//# sourceMappingURL=node-modules-base.backend.js.map