"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var tnp_core_1 = require("tnp-core");
var tnp_core_2 = require("tnp-core");
var chalk_1 = require("chalk");
var abstract_1 = require("../abstract");
var tnp_config_1 = require("tnp-config");
var tnp_helpers_1 = require("tnp-helpers");
var tnp_cli_1 = require("tnp-cli");
var SmartNodeModules = /** @class */ (function (_super) {
    tslib_1.__extends(SmartNodeModules, _super);
    function SmartNodeModules() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    //#region getters/private methods
    //#region project from smart node_modules package
    SmartNodeModules.prototype.getAndCreateTempProjForPackage = function (p) {
        var _a;
        var dest = this.project.smartNodeModules.pathFor(p.name);
        var pj = tnp_core_2.path.join(tnp_core_2.path.dirname(this.project.smartNodeModules.pathFor(p.name)), tnp_config_1.config.file.package_json);
        tnp_helpers_1.Helpers.removeIfExists(tnp_core_2.path.dirname(dest));
        tnp_helpers_1.Helpers.mkdirp(tnp_core_2.path.dirname(dest));
        tnp_helpers_1.Helpers.writeFile(pj, {
            name: tnp_core_2.path.basename(tnp_core_2.path.dirname(dest)),
            dependencies: (_a = {}, _a[p.name] = p.version, _a)
        });
        return abstract_1.Project.From(tnp_core_2.path.dirname(this.project.smartNodeModules.pathFor(p.name)));
    };
    Object.defineProperty(SmartNodeModules.prototype, "containerCore", {
        //#endregion
        //#region container core project for this project
        get: function () {
            tnp_helpers_1.Helpers.info('Preparing cointainer core ...');
            var frameworkVersion = this.project._frameworkVersion;
            var container = abstract_1.Project.by('container', frameworkVersion);
            if (this.project.location === (container === null || container === void 0 ? void 0 : container.location)) {
                tnp_helpers_1.Helpers.log("Smart node modules instalation for container core..");
            }
            if (!SmartNodeModules._prepared[container.location]) {
                prepare(container, this.project);
            }
            SmartNodeModules._prepared[container.location] = container;
            tnp_helpers_1.Helpers.info('Preparing cointainer core ... done');
            return container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SmartNodeModules.prototype, "path", {
        //#endregion
        //#region path
        /**
         * path for smart node_modules for whole project
         */
        get: function () {
            return this.pathFor(this.project.name);
        },
        enumerable: true,
        configurable: true
    });
    //#endregion
    //#region resolve smart node_module path
    SmartNodeModules.prototype.pathFor = function (packageName) {
        if (!packageName) {
            packageName = this.project.name;
        }
        return tnp_core_2.path.join(this.project.location, tnp_config_1.config.folder.tmp + "-smart-" + tnp_config_1.config.folder.node_modules, "for", packageName, tnp_config_1.config.folder.node_modules);
    };
    Object.defineProperty(SmartNodeModules.prototype, "exists", {
        //#endregion
        //#region smart node_modules exists for whole project
        get: function () {
            return tnp_helpers_1.Helpers.exists(this.path);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SmartNodeModules.prototype, "toOverride", {
        //#endregion
        //#region packages to override after smart node_modules instalation
        get: function () {
            var _a, _b, _c;
            return ((_c = (_b = (_a = this.project.packageJson.data) === null || _a === void 0 ? void 0 : _a.tnp) === null || _b === void 0 ? void 0 : _b.overrided) === null || _c === void 0 ? void 0 : _c.dependencies) || {};
        },
        enumerable: true,
        configurable: true
    });
    SmartNodeModules.prototype.handlePackagesOverride = function () {
        var _this = this;
        var toOverride = this.toOverride;
        var mainSmartNodeModulesFolder = tnp_core_2.path.dirname(tnp_core_2.path.dirname(this.project.smartNodeModules.path));
        tnp_helpers_1.Helpers.foldersFrom(mainSmartNodeModulesFolder)
            .filter(function (f) { return tnp_core_2.path.basename(f) !== _this.project.name; })
            .forEach(function (f) {
            var additonalFolderToRemove = tnp_core_2.path.join(_this.project.smartNodeModules.pathFor(tnp_core_2.path.basename(f)));
            tnp_helpers_1.Helpers.removeFolderIfExists(additonalFolderToRemove);
        });
        // Helpers.log('OVERRRIDE', _.keys(toOverride).join('/'))
        tnp_core_1._.keys(toOverride).map(function (packageName) {
            var packageVersion = toOverride[packageName];
            if (packageVersion === null) {
                _this.project.node_modules.remove(packageName);
            }
            else {
                //#region dedupe from temp before adding to actual node_modules
                var tempProj_1 = _this.project.smartNodeModules.getAndCreateTempProjForPackage({
                    name: packageName,
                    version: packageVersion
                });
                tempProj_1.npmPackages.installFromArgs('');
                var Tnp = abstract_1.Project.Tnp;
                var toDedupe = Tnp.packageJson.data.tnp.core.dependencies.dedupe;
                toDedupe
                    .filter(function (dedupePkgName) {
                    // Helpers.log(`dedupePkgName: ${dedupePkgName}`)
                    return tnp_core_1._.isString(dedupePkgName) && !tnp_core_1._.keys(toOverride).includes(dedupePkgName);
                })
                    .forEach(function (dedupePkgName) {
                    var existedVersionInMainNodeModules = _this.project.npmPackages.package(dedupePkgName).version;
                    if (tempProj_1.npmPackages.package(dedupePkgName).exists &&
                        tempProj_1.npmPackages.package(dedupePkgName).isNotSatisfyBy(existedVersionInMainNodeModules)) {
                        var verrrr = tempProj_1.npmPackages.package(dedupePkgName);
                        tnp_helpers_1.Helpers.warn("[override package][dedupe \"" + packageName + "\"] " + chalk_1.default.bold(dedupePkgName) + "@" + (verrrr === null || verrrr === void 0 ? void 0 : verrrr.version) + " won't be satisfy"
                            + (" in this repository by version \"" + existedVersionInMainNodeModules + "\""));
                    }
                });
                tempProj_1.node_modules.dedupe(toDedupe);
                //#endregion
                //#region link to main repo
                var overrideFrom = tempProj_1.npmPackages.package(packageName).location;
                var overrideDest = _this.project.npmPackages.package(packageName).location;
                // console.log(`overrideFrom: ${overrideFrom}`)
                // console.log(`overrideDest: ${overrideDest}`)
                tnp_helpers_1.Helpers.removeIfExists(overrideDest);
                tnp_helpers_1.Helpers.createSymLink(overrideFrom, overrideDest);
                tnp_helpers_1.Helpers.foldersFrom(tempProj_1.node_modules.path)
                    .filter(function (depName) { return tnp_core_2.path.basename(depName) !== packageName; })
                    .forEach(function (depName) {
                    depName = tnp_core_2.path.basename(depName);
                    var verrr = tempProj_1.npmPackages.package(depName).version;
                    var fromProj = tempProj_1.npmPackages.package(depName);
                    var destProj = _this.project.npmPackages.package(depName);
                    if (tnp_helpers_1.Helpers.exists(destProj.location)) {
                        if (fromProj.isNotSatisfyBy(destProj.version)) {
                            tnp_helpers_1.Helpers.warn("[override package][link \"" + packageName + "\"] " + chalk_1.default.bold(depName) + "@" + verrr + " won't be satisfy"
                                + (" in this repository by version \"" + destProj.version + "\""));
                        }
                        else {
                            tnp_helpers_1.Helpers.log("[override package][link \"" + packageName + "\"] copying new package " + chalk_1.default.bold(depName) + " to main node_modules");
                        }
                    }
                    else {
                        tnp_helpers_1.Helpers.createSymLink(fromProj.location, destProj.location);
                    }
                });
                //#endregion
            }
        });
    };
    //#endregion
    //#endregion
    //#region public api
    //#region install/reinstall all packages
    SmartNodeModules.prototype.install = function (action) {
        var _this = this;
        if (action === void 0) { action = 'install'; }
        var packages = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            packages[_i - 1] = arguments[_i];
        }
        tnp_helpers_1.Helpers.info("START SMART INSTALL...  for " + this.project.genericName);
        if (packages.length > 0) {
            packages.forEach(function (p) {
                _this.project.packageJson.data.tnp.overrided.dependencies[p.name] = (action === 'uninstall')
                    ? void 0 : p.version;
            });
            this.project.packageJson.save("save afte smart " + action + " of package(s):\n  " + packages.map(function (p) {
                return "- " + p.name + " @" + p.version;
            }).join('\n') + "\n      ");
        }
        var containerCore = this.containerCore;
        if (containerCore.location !== this.project.location) {
            this.project.node_modules.remove();
            this.project.node_modules.copyFrom(containerCore, 'smart node_modules instalation');
            this.handlePackagesOverride();
        }
        tnp_helpers_1.Helpers.info("DONE SMART INSTALL  for " + this.project.genericName);
    };
    SmartNodeModules._prepared = {};
    return SmartNodeModules;
}(abstract_1.FeatureForProject));
exports.SmartNodeModules = SmartNodeModules;
//#region helpers
//#region prepare
function prepare(project, currentProject) {
    project.packageJson.save("prepare for smart node_modules");
    if (!tnp_helpers_1.Helpers.exists(project.smartNodeModules.path)) {
        tnp_helpers_1.Helpers.mkdirp(tnp_core_2.path.dirname(project.smartNodeModules.path));
        tnp_helpers_1.Helpers.createSymLink(project.packageJson.path, tnp_core_2.path.join(tnp_core_2.path.dirname(project.smartNodeModules.path), tnp_config_1.config.file.package_json));
    }
    var tmpProj = abstract_1.Project.From(tnp_core_2.path.dirname(project.smartNodeModules.path));
    var reinstallForceSmartNodeModules = (project.isContainerCoreProject && (project.location === currentProject.location));
    if (!tmpProj.node_modules.exist || reinstallForceSmartNodeModules) {
        tmpProj.npmPackages.installFromArgs('', false, true);
    }
    if (!reinstallForceSmartNodeModules) {
        tnp_helpers_1.Helpers.info("\n\n    No need for update of node_modules links for " + tnp_cli_1.CLI.chalk.bold(project.genericName) + "\n\n    ");
        return;
    }
    tnp_helpers_1.Helpers.actionWrapper(function () {
        tnp_helpers_1.Helpers.foldersFrom(tmpProj.node_modules.path).forEach(function (from) {
            var dest = tnp_core_2.path.join(project.node_modules.path, tnp_core_2.path.basename(from));
            tnp_helpers_1.Helpers.removeFileIfExists(dest);
            tnp_helpers_1.Helpers.createSymLink(from, dest);
        });
    }, "updating node_modules links for " + tnp_cli_1.CLI.chalk.bold(project.genericName) + " ");
}
//#endregion
//#endregion
//# sourceMappingURL=smart-node-modules.backend.js.map