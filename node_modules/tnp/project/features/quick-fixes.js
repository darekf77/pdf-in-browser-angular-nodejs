"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
//#region @backend
var tnp_core_1 = require("tnp-core");
var tnp_core_2 = require("tnp-core");
var tnp_core_3 = require("tnp-core");
var chalk_1 = require("chalk");
var abstract_1 = require("../abstract");
var tnp_helpers_1 = require("tnp-helpers");
var tnp_config_1 = require("tnp-config");
var QuickFixes = /** @class */ (function (_super) {
    tslib_1.__extends(QuickFixes, _super);
    function QuickFixes() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    QuickFixes.prototype.updateTsconfigsInTmpSrcBrowserFolders = function () {
        var _this = this;
        if (this.project.typeIs('angular-lib', 'isomorphic-lib')) {
            var tsconfigBrowserPath_1 = tnp_core_1.path.join(this.project.location, 'tsconfig.browser.json');
            var tempDirs = tnp_core_2.fse.readdirSync(this.project.location).filter(function (dir) { return dir.startsWith('tmp-src-'); });
            tempDirs.forEach(function (dirName) {
                var dest = tnp_core_1.path.join(_this.project.location, dirName, 'tsconfig.json');
                tnp_helpers_1.Helpers.copyFile(tsconfigBrowserPath_1, dest);
            });
            var componentsFolder = tnp_core_1.path.join(this.project.location, tnp_config_1.config.folder.components);
            if (tnp_core_2.fse.existsSync(componentsFolder)) {
                // TODO join isomorphic part with tsconfig.isomorphic.json
                tnp_helpers_1.Helpers.writeFile(tnp_core_1.path.join(componentsFolder, tnp_config_1.config.file.tsconfig_json), {
                    "compileOnSave": true,
                    "compilerOptions": {
                        "declaration": true,
                        "experimentalDecorators": true,
                        "emitDecoratorMetadata": true,
                        "allowSyntheticDefaultImports": true,
                        'importHelpers': true,
                        "moduleResolution": "node",
                        "module": "commonjs",
                        "skipLibCheck": true,
                        "sourceMap": true,
                        "target": "es5",
                        "lib": [
                            "es2015",
                            "es2015.promise",
                            "es2015.generator",
                            "es2015.collection",
                            "es2015.core",
                            "es2015.reflect",
                            "es2016",
                            "dom"
                        ],
                        "types": [
                            "node"
                        ],
                    },
                    "include": [
                        "./**/*"
                    ],
                    "exclude": [
                        "node_modules",
                        "preview",
                        "projects",
                        "docs",
                        "dist",
                        "bundle",
                        "example",
                        "examples",
                        "browser",
                        "module",
                        "tmp-src",
                        "src/tests",
                        "src/**/*.spec.ts",
                        "tmp-site-src",
                        "tmp-tests-context"
                    ]
                });
            }
        }
    };
    QuickFixes.prototype.removeUncessesaryFiles = function () {
        var filesV1 = [
            'src/tsconfig.packages.json',
            'src/tsconfig.spec.json',
            'src/tsconfig.app.json',
            '.angular-cli.json'
        ];
        if (this.project.frameworkVersionAtLeast('v2') && this.project.typeIs('angular-lib')) {
            for (var index = 0; index < filesV1.length; index++) {
                var oldFile = tnp_core_1.path.join(this.project.location, filesV1[index]);
                tnp_helpers_1.Helpers.removeFileIfExists(oldFile);
            }
        }
    };
    QuickFixes.prototype.missingAngularLibFiles = function () {
        if (this.project.typeIs('angular-lib')) {
            var indexTs = tnp_core_1.path.join(this.project.location, tnp_config_1.config.folder.components, 'index.ts');
            if (!tnp_core_2.fse.existsSync(indexTs)) {
                tnp_helpers_1.Helpers.writeFile(indexTs, "\n        export * from './public_api';\n        ".trimLeft());
            }
            var pubilcApiLoc = tnp_core_1.path.join(this.project.location, tnp_config_1.config.folder.components, tnp_config_1.config.file.publicApi_ts);
            if (!tnp_core_2.fse.existsSync(pubilcApiLoc)) {
                tnp_helpers_1.Helpers.writeFile(pubilcApiLoc, "\n        export function helloWorld() { }\n        ".trimLeft());
            }
        }
    };
    QuickFixes.prototype.badTypesInNodeModules = function () {
        var _this = this;
        if (this.project.frameworkVersionAtLeast('v2')) {
            [
                '@types/mocha',
                '@types/jasminewd2',
                '@types/jasmine',
                '@types/puppeteer-core',
                '@types/puppeteer',
            ].forEach(function (name) {
                tnp_helpers_1.Helpers.removeFolderIfExists(tnp_core_1.path.join(_this.project.node_modules.path, name));
            });
        }
    };
    QuickFixes.prototype.overritenBadNpmPackages = function () {
        var _this = this;
        tnp_helpers_1.Helpers.log("Fixing bad npm packages - START for " + this.project.genericName);
        if (this.project.isTnp) { // TODO for all packages ???
            this.project.node_modules.fixesForNodeModulesPackages
                .forEach(function (f) {
                var source = tnp_core_1.path.join(_this.project.location, f);
                var dest = tnp_core_1.path.join(_this.project.location, tnp_config_1.config.folder.node_modules, f);
                tnp_helpers_1.Helpers.tryCopyFrom(source, dest);
            });
        }
        if (this.project.isWorkspace) {
            if (this.project.isGenerated) {
                this.project.origin.node_modules.fixesForNodeModulesPackages
                    .forEach(function (f) {
                    var source = tnp_core_1.path.join(_this.project.origin.location, f);
                    var dest = tnp_core_1.path.join(_this.project.location, f);
                    if (tnp_core_2.fse.existsSync(dest)) {
                        tnp_helpers_1.Helpers.tryRemoveDir(dest);
                    }
                    tnp_helpers_1.Helpers.tryCopyFrom(source, dest);
                });
            }
            if (this.project.isSite) {
                this.project.baseline.node_modules.fixesForNodeModulesPackages
                    .forEach(function (f) {
                    var source = tnp_core_1.path.join(_this.project.baseline.location, f);
                    var dest = tnp_core_1.path.join(_this.project.location, f);
                    if (tnp_core_2.fse.existsSync(dest)) {
                        tnp_helpers_1.Helpers.tryRemoveDir(dest);
                    }
                    tnp_helpers_1.Helpers.tryCopyFrom(source, dest);
                });
            }
        }
        tnp_helpers_1.Helpers.log("Fixing bad npm packages - COMPLETE");
    };
    QuickFixes.prototype.missingLibs = function (missingLibsNames) {
        var _this = this;
        if (missingLibsNames === void 0) { missingLibsNames = []; }
        if (this.project.isContainer) {
            return;
        }
        missingLibsNames.forEach(function (missingLibName) {
            var pathInProjectNodeModules = tnp_core_1.path.join(_this.project.location, tnp_config_1.config.folder.node_modules, missingLibName);
            if (tnp_core_2.fse.existsSync(pathInProjectNodeModules)) {
                if (_this.project.isStandaloneProject || _this.project.isWorkspace) {
                    tnp_helpers_1.Helpers.warn("Package \"" + missingLibName + "\" will replaced with empty package mock. " + _this.project.genericName);
                }
            }
            // Helpers.remove(pathInProjectNodeModules);
            if (!tnp_core_2.fse.existsSync(pathInProjectNodeModules)) {
                tnp_helpers_1.Helpers.mkdirp(pathInProjectNodeModules);
            }
            tnp_helpers_1.Helpers.writeFile(tnp_core_1.path.join(pathInProjectNodeModules, 'index.js'), "\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.default = {};\n");
            tnp_helpers_1.Helpers.writeFile(tnp_core_1.path.join(pathInProjectNodeModules, 'index.d.ts'), "\ndeclare const _default: {};\nexport default _default;\n");
            tnp_helpers_1.Helpers.writeFile(tnp_core_1.path.join(pathInProjectNodeModules, tnp_config_1.config.file.package_json), {
                name: missingLibName,
                version: "0.0.0"
            });
        });
    };
    QuickFixes.prototype.linkSourceOfItselfToNodeModules = function () {
        if (!this.project.isStandaloneProject) {
            return;
        }
        // if(process.platform  === 'win32') { // TODO QUICKFIX
        tnp_helpers_1.Helpers.warn("[linkSourceOfItselfToNodeModules] [win32] functionality disabled");
        return;
        // }
        var pathToSelf = tnp_core_3.crossPlatformPath(tnp_core_1.path.join(this.project.location, tnp_config_1.config.folder.node_modules, this.project.name));
        var pathToSrc = tnp_core_3.crossPlatformPath(tnp_core_1.path.join(this.project.location, this.project.typeIs('angular-lib') ? tnp_config_1.config.folder.components : tnp_config_1.config.folder.src));
        tnp_helpers_1.Helpers.removeIfExists(pathToSelf);
        tnp_core_3.glob.sync(pathToSrc + "/**/*.*")
            .filter(function (f) { return !tnp_helpers_1.Helpers.isFolder(f); })
            .map(function (f) { return tnp_core_3.crossPlatformPath(f); })
            .forEach(function (f) {
            var relative = f.replace(pathToSrc + "/", '');
            tnp_helpers_1.Helpers.createSymLink(f, tnp_core_1.path.join(pathToSelf, relative), { continueWhenExistedFolderDoesntExists: true });
            tnp_helpers_1.Helpers.createSymLink(f, tnp_core_1.path.join(pathToSelf, tnp_config_1.config.folder.browser, relative), { continueWhenExistedFolderDoesntExists: true });
        });
    };
    QuickFixes.prototype.missingSourceFolders = function () {
        var _a;
        if (!tnp_core_2.fse.existsSync(this.project.location)) {
            return;
        }
        if (this.project.isWorkspace ||
            this.project.isWorkspaceChildProject ||
            this.project.isStandaloneProject) {
            // if (this.project.isStandaloneProject && this.project.type === 'angular-lib') {
            //   Helpers.writeFile(path.join(this.project.location, config.file.tnpEnvironment_json), {});
            // }
            var srcFolder = tnp_core_1.path.join(this.project.location, tnp_config_1.config.folder.src);
            if (this.project.isWorkspace) {
                // Helpers.removeFolderIfExists(srcFolder);
            }
            else {
                if (!tnp_core_2.fse.existsSync(srcFolder)) {
                    if (this.project.typeIs('angular-lib')) {
                        var coreProj = abstract_1.Project.by('angular-lib', this.project._frameworkVersion);
                        var coreSrcLocaion = tnp_core_1.path.join(coreProj.location, tnp_config_1.config.folder.src);
                        tnp_helpers_1.Helpers.copy(coreSrcLocaion, srcFolder, { recursive: true, overwrite: true });
                    }
                    else {
                        tnp_helpers_1.Helpers.mkdirp(srcFolder);
                    }
                }
                // log('SRC folder recreated')
            }
            var componentsFolder = tnp_core_1.path.join(this.project.location, tnp_config_1.config.folder.components);
            if ((_a = this.project).typeIs.apply(_a, tnp_config_1.config.projectTypes.with.componetsAsSrc) && !tnp_core_2.fse.existsSync(componentsFolder)) {
                // log('COMPONENTS folder recreated');
                tnp_helpers_1.Helpers.mkdirp(componentsFolder);
            }
            // TODO why would I do that ?
            // const browserStandaloneFolder = path.join(this.project.location, config.folder.browser);
            // if (this.project.type === 'angular-lib' && this.project.isStandaloneProject
            //   && !fse.existsSync(browserStandaloneFolder)) {
            //   // log('BROWSER folder recreated');
            //   fse.symlinkSync(this.project.location, browserStandaloneFolder);
            // }
            var customFolder = tnp_core_1.path.join(this.project.location, tnp_config_1.config.folder.custom);
            if (this.project.isSiteInStrictMode && !tnp_core_2.fse.existsSync(customFolder)) {
                // log('CUSTOM folder recreated');
                tnp_helpers_1.Helpers.mkdirp(customFolder);
            }
            if (this.project.isSiteInDependencyMode) {
                tnp_helpers_1.Helpers.removeFolderIfExists(customFolder);
            }
            var nodeModulesFolder = tnp_core_1.path.join(this.project.location, tnp_config_1.config.folder.node_modules);
            if (this.project.isWorkspace && !tnp_core_2.fse.existsSync(nodeModulesFolder)) {
                // log('NODE_MODULES folder recreated');
                tnp_helpers_1.Helpers.mkdirp(nodeModulesFolder);
            }
            if (this.project.isWorkspaceChildProject && !tnp_core_2.fse.existsSync(nodeModulesFolder)) {
                var paretnFolderOfNodeModules = tnp_core_1.path.join(this.project.parent.location, tnp_config_1.config.folder.node_modules);
                if (!tnp_core_2.fse.existsSync(paretnFolderOfNodeModules)) {
                    // log('NODE_MODULES (parent) folder recreated');
                    tnp_helpers_1.Helpers.mkdirp(paretnFolderOfNodeModules);
                }
                // log('NODE_MODULES folder link to child recreated');
                tnp_helpers_1.Helpers.createSymLink(paretnFolderOfNodeModules, nodeModulesFolder);
            }
            if (this.project.isSite) {
                if (this.project.isWorkspace) {
                    var baselineFolderInNodeModule = tnp_core_1.path.join(this.project.location, tnp_config_1.config.folder.node_modules, this.project.baseline.name);
                    if (!tnp_core_2.fse.existsSync(baselineFolderInNodeModule)) {
                        // log('BASELINE folder in NODE_MODUELS recreated');
                        tnp_helpers_1.Helpers.createSymLink(this.project.baseline.location, baselineFolderInNodeModule);
                    }
                }
            }
        }
    };
    Object.defineProperty(QuickFixes.prototype, "nodeModulesReplacementsZips", {
        get: function () {
            var _this = this;
            var npmReplacements = tnp_core_3.glob
                .sync(this.project.location + " /" + tnp_config_1.config.folder.node_modules + "-*.zip")
                .map(function (p) { return p.replace(_this.project.location, '').slice(1); });
            return npmReplacements;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * FIX for missing npm packages from npmjs.com
     *
     * Extract each file: node_modules-<package Name>.zip
     * to node_modules folder before instalation.
     * This will prevent packages deletion from npm
     */
    QuickFixes.prototype.nodeModulesPackagesZipReplacement = function () {
        var _this = this;
        if (!this.project.isWorkspace) {
            return;
        }
        var nodeModulesPath = tnp_core_1.path.join(this.project.location, tnp_config_1.config.folder.node_modules);
        if (!tnp_core_2.fse.existsSync(nodeModulesPath)) {
            tnp_helpers_1.Helpers.mkdirp(nodeModulesPath);
        }
        this.nodeModulesReplacementsZips.forEach(function (p) {
            var name = p.replace(tnp_config_1.config.folder.node_modules + "-", '');
            var moduleInNodeMdules = tnp_core_1.path.join(_this.project.location, tnp_config_1.config.folder.node_modules, name);
            if (tnp_core_2.fse.existsSync(moduleInNodeMdules)) {
                tnp_helpers_1.Helpers.info("Extraction " + chalk_1.default.bold(name) + " already exists in " +
                    (" " + chalk_1.default.bold(_this.project.genericName) + "/" + tnp_config_1.config.folder.node_modules));
            }
            else {
                tnp_helpers_1.Helpers.info("Extraction before instalation " + chalk_1.default.bold(name) + " in " +
                    (" " + chalk_1.default.bold(_this.project.genericName) + "/" + tnp_config_1.config.folder.node_modules));
                _this.project.run("extract-zip " + p + " " + nodeModulesPath).sync();
            }
        });
    };
    return QuickFixes;
}(abstract_1.FeatureForProject));
exports.QuickFixes = QuickFixes;
//#endregion
//# sourceMappingURL=quick-fixes.js.map