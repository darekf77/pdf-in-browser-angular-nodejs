"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var chalk_1 = require("chalk");
var tnp_helpers_1 = require("tnp-helpers");
var tnp_core_1 = require("tnp-core");
var tnp_core_2 = require("tnp-core");
var abstract_1 = require("../abstract");
//#endregion
var USE_HTTPS_INSTEAD_SSH = !tnp_core_2.os.hostname().endsWith('.local'); // TODO
var GitActions = /** @class */ (function (_super) {
    tslib_1.__extends(GitActions, _super);
    function GitActions() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    //#region before push,pull actions
    GitActions.prototype.before = function () {
        if (!this.project.git.isGitRepo) {
            tnp_helpers_1.Helpers.error("Project " + chalk_1.default.bold(this.project.name) + " is not a git repository\n      locaiton: " + this.project.location, false, true);
        }
        if (!this.project.git.isGitRoot) {
            tnp_helpers_1.Helpers.error("Project " + chalk_1.default.bold(this.project.name) + " is not a git root\n      locaiton: " + this.project.location, false, true);
        }
        if (this.project.git.currentBranchName !== 'master') {
            this.project.run("code .").async();
            tnp_helpers_1.Helpers.warn("\n\n      WARNGING default branch is not master...\n\n      ");
            tnp_helpers_1.Helpers.pressKeyAndContinue("press any key to continue or stop the process..");
        }
        fixRemote(this.project);
        this.project.removeFolderByRelativePath('node_modules/husky');
        if (this.project.targetProjects.exists) {
            tnp_helpers_1.Helpers.warn("\n\n      Don't forget to push target projects for project " + chalk_1.default.bold(this.project.name) + "\n\n      ");
        }
    };
    //#endregion
    //#region get unexisted projects
    GitActions.prototype.cloneUnexistedProjects = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var shouldBeProjectArr, _loop_1, this_1, index;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        shouldBeProjectArr = this.project.packageJson.linkedProjects.map(function (relativePath) {
                            if (!abstract_1.Project.From(tnp_core_1.path.join(_this.project.location, relativePath))) {
                                return relativePath;
                            }
                        }).filter(function (f) { return !!f; });
                        if (!(shouldBeProjectArr.length > 0)) return [3 /*break*/, 4];
                        tnp_helpers_1.Helpers.pressKeyAndContinue("\n\n    " + shouldBeProjectArr.map(function (p) { return "-" + p; }).join('\n') + "\n\n      press any key to clone each above project..");
                        _loop_1 = function (index) {
                            var relativePath, projectNameFromPackageJson, p, ADDRESS_GITHUB_SSH, githubGitUrl_1;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        relativePath = shouldBeProjectArr[index];
                                        projectNameFromPackageJson = tnp_core_1.path.basename(relativePath);
                                        if (!tnp_helpers_1.Helpers.isValidGitRepuUrl(relativePath)) return [3 /*break*/, 3];
                                        p = tnp_core_1.path.join(this_1.project.location, relativePath);
                                        if (!!tnp_helpers_1.Helpers.exists(p)) return [3 /*break*/, 2];
                                        return [4 /*yield*/, tnp_helpers_1.Helpers.actionWrapper(function () {
                                                _this.project.git.clone(relativePath);
                                            }, "Cloning unexisted project from url " + chalk_1.default.bold(relativePath))];
                                    case 1:
                                        _a.sent();
                                        _a.label = 2;
                                    case 2: return [3 /*break*/, 5];
                                    case 3:
                                        ADDRESS_GITHUB_SSH = this_1.project.git.originURL;
                                        githubGitUrl_1 = ADDRESS_GITHUB_SSH.replace(this_1.project.name + ".git", projectNameFromPackageJson + ".git");
                                        return [4 /*yield*/, tnp_helpers_1.Helpers.actionWrapper(function () {
                                                _this.project.git.clone(githubGitUrl_1);
                                            }, "Cloning unexisted project " + chalk_1.default.bold(projectNameFromPackageJson))];
                                    case 4:
                                        _a.sent();
                                        _a.label = 5;
                                    case 5: return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        index = 0;
                        _a.label = 1;
                    case 1:
                        if (!(index < shouldBeProjectArr.length)) return [3 /*break*/, 4];
                        return [5 /*yield**/, _loop_1(index)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        index++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    //#endregion
    //#region  get linked projects and childrens
    GitActions.prototype.getLinkedPorjectsAndChildrens = function (action, commitMessage) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var childrenToPush;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.cloneUnexistedProjects()];
                    case 1:
                        _a.sent();
                        childrenToPush = tslib_1.__spreadArrays(this.project.children.filter(function (c) {
                            return _this.project.packageJson.linkedProjects.includes(c.name);
                        }), this.project.linkedProjects);
                        childrenToPush = childrenToPush.filter(function (f) { return !!f; });
                        return [2 /*return*/, tnp_helpers_1.Helpers.arrays.uniqArray(childrenToPush, 'location')];
                }
            });
        });
    };
    //#endregion
    //#region repeat menu push,pull
    GitActions.prototype.repeatMenu = function (action, force) {
        if (force === void 0) { force = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var err_1;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!true) return [3 /*break*/, 5];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, tnp_helpers_1.Helpers.actionWrapper(function () {
                                if (action === 'pull') {
                                    _this.project.git.pullCurrentBranch(
                                    // force
                                    );
                                }
                                if (action === 'push') {
                                    _this.project.git.pushCurrentBranch(force);
                                }
                            }, action.toUpperCase() + "ing project " + chalk_1.default.bold(this.project.name) + "...")];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 3:
                        err_1 = _a.sent();
                        tnp_helpers_1.Helpers.error("Not able to " + action + " brench... ", true, true);
                        this.project.run("code .").async();
                        tnp_helpers_1.Helpers.pressKeyAndContinue(chalk_1.default.bold(this.project.name) + " "
                            + ("- check your repository and press any key to repeat " + action + ".."));
                        return [3 /*break*/, 4];
                    case 4: return [3 /*break*/, 0];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    //#endregion
    //#region push
    GitActions.prototype.push = function (commitMessage, force) {
        if (force === void 0) { force = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var childrenToPush, index, childProj;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!commitMessage) {
                            commitMessage = 'update';
                        }
                        if (!this.project.isContainer) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.project.recent.saveActiveProjects(false)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        this.before();
                        return [4 /*yield*/, this.getLinkedPorjectsAndChildrens('push')];
                    case 3:
                        childrenToPush = _a.sent();
                        index = 0;
                        _a.label = 4;
                    case 4:
                        if (!(index < childrenToPush.length)) return [3 /*break*/, 7];
                        childProj = childrenToPush[index];
                        return [4 /*yield*/, childProj.gitActions.push(commitMessage, force)];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6:
                        index++;
                        return [3 /*break*/, 4];
                    case 7:
                        if (this.project.git.thereAreSomeUncommitedChange) {
                            try {
                                this.project.run("git add --all . && git commit -m \"" + commitMessage + "\"").sync();
                            }
                            catch (error) { }
                        }
                        return [4 /*yield*/, this.repeatMenu('push', force)];
                    case 8:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    //#endregion
    //#region pull
    GitActions.prototype.pull = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var location, childrenToPull, index, childProj;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.project.typeIs('navi')) {
                            this.project.git.pullCurrentBranch();
                            return [2 /*return*/];
                        }
                        this.before();
                        if (this.project.git.thereAreSomeUncommitedChange) {
                            tnp_helpers_1.Helpers.warn("\n\n\n    [WARNING]  Stashing uncommit changes... in " + this.project.genericName + "\n\n\n      ");
                            try {
                                this.project.run("add --all .").sync();
                            }
                            catch (error) { }
                            this.project.run("git stash").sync();
                            // this.project.run(`code .`).async();
                            // Helpers.pressKeyAndContinue(`Commit your changes and press any key...`);
                        }
                        return [4 /*yield*/, this.repeatMenu('pull')];
                    case 1:
                        _a.sent();
                        location = this.project.location;
                        abstract_1.Project.unload(this.project);
                        this.project = abstract_1.Project.From(location);
                        if (!(this.project.isContainer && this.project.packageJson.linkedProjects.length > 0)) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.getLinkedPorjectsAndChildrens('pull')];
                    case 2:
                        childrenToPull = _a.sent();
                        index = 0;
                        _a.label = 3;
                    case 3:
                        if (!(index < childrenToPull.length)) return [3 /*break*/, 6];
                        childProj = childrenToPull[index];
                        return [4 /*yield*/, childProj.gitActions.pull()];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        index++;
                        return [3 /*break*/, 3];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    return GitActions;
}(abstract_1.FeatureForProject));
exports.GitActions = GitActions;
function fixRemote(project) {
    var originUrl = project.git.originURL;
    if (originUrl.startsWith('git@github') && USE_HTTPS_INSTEAD_SSH) {
        project.run("git remote set-url origin " + originUrl.replace('git@github.com:', 'https://github.com/')).sync();
    }
}
//# sourceMappingURL=git-actions.backend.js.map