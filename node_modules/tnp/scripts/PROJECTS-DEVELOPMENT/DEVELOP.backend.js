"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
//#region imports
var tnp_core_1 = require("tnp-core");
var tnp_core_2 = require("tnp-core");
var project_1 = require("../../project");
var tnp_helpers_1 = require("tnp-helpers");
var tnp_core_3 = require("tnp-core");
var tnp_config_1 = require("tnp-config");
var tnp_db_1 = require("tnp-db");
var tnp_core_4 = require("tnp-core");
var node_notifier_1 = require("node-notifier");
var typescript_class_helpers_1 = require("typescript-class-helpers");
var chalk_1 = require("chalk");
//#endregion
//#region sync to/from
function $SYNC_TO(args) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var destinationIps, _a, destinaitonProjects, commandString, currentProj_1, toSync_1, destProj_1, properContainerChild, _loop_1, j;
        var _this = this;
        return tslib_1.__generator(this, function (_b) {
            destinationIps = tnp_helpers_1.Helpers.cliTool.argsFromBegin(args, function (ip) {
                return tnp_helpers_1.Helpers.urlParse(ip);
            }).resolved;
            if (destinationIps.length > 0) {
                //#region notify sync server
                // const db = await TnpDB.Instance();
                // const projects = (await db.getProjects()).map(p => p.project) as Project[];
                // const res = await Helpers.autocompleteAsk(`Select project to sync notify`,
                //   projects.map(p => {
                //     return { name: p.genericName, value: p.genericName }
                //   })
                // )
                // for (let index = 0; index < destinationIps.length; index++) {
                //   const server = destinationIps[index];
                // }
                //#endregion
            }
            else {
                _a = tnp_helpers_1.Helpers.cliTool.argsFromBegin(args, function (location) {
                    return project_1.Project.From(location);
                }), destinaitonProjects = _a.resolved, commandString = _a.commandString;
                args = commandString;
                currentProj_1 = project_1.Project.Current;
                toSync_1 = tslib_1.__spreadArrays((currentProj_1.typeIs('angular-lib') ? [tnp_config_1.config.folder.components] : []), (currentProj_1.typeIsNot('unknow', 'unknow-npm-project') ? [tnp_config_1.config.folder.src] : []));
                tnp_helpers_1.Helpers.info("Folder to sync: " + toSync_1.join(','));
                if (destinaitonProjects.length === 0) {
                    tnp_helpers_1.Helpers.error("No project to sync", false, true);
                }
                destProj_1 = tnp_core_1._.first(destinaitonProjects);
                if (destProj_1.isContainer) {
                    properContainerChild = destProj_1.children.find(function (c) { return c.name === currentProj_1.name; });
                    destProj_1 = properContainerChild;
                }
                if (!destProj_1 || destProj_1.name !== currentProj_1.name) {
                    tnp_helpers_1.Helpers.error("You can only sync projects with same name", false, true);
                }
                _loop_1 = function (j) {
                    var source = tnp_core_3.path.join(currentProj_1.location, toSync_1[j]);
                    tnp_helpers_1.Helpers.info("\n        source: " + currentProj_1.genericName + "\n        destination:" + destProj_1.genericName + "\n      ");
                    tnp_core_4.chokidar.watch([source], {
                        ignoreInitial: false,
                        followSymlinks: false,
                        ignorePermissionErrors: true,
                    }).on('all', function (event, f) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        var dest;
                        return tslib_1.__generator(this, function (_a) {
                            if (event !== 'addDir' && event !== 'unlinkDir') {
                                dest = tnp_core_3.path.join(destProj_1.location, toSync_1[j], f.replace(source, ''));
                                if (!tnp_helpers_1.Helpers.exists(tnp_core_3.path.dirname(dest))) {
                                    tnp_helpers_1.Helpers.mkdirp(tnp_core_3.path.dirname(dest));
                                }
                                tnp_helpers_1.Helpers.copyFile(f, dest);
                                tnp_helpers_1.Helpers.log("Copy: " + dest);
                            }
                            return [2 /*return*/];
                        });
                    }); });
                };
                for (j = 0; j < toSync_1.length; j++) {
                    _loop_1(j);
                }
                //#endregion
            }
            return [2 /*return*/];
        });
    });
}
function $SYNC_FROM(args) {
    // //#region resolve projects
    // const { resolved: sourceProjects, commandString } = Helpers.cliTool.argsFromBegin<Project>(args, location => {
    //   return Project.From(location)
    // });
    // args = commandString;
    // const currentProj = (Project.Current as Project);
    // const toSync = [
    //   ...(currentProj.typeIs('angular-lib') ? [config.folder.components] : []),
    //   ...(currentProj.typeIsNot('unknow', 'unknow-npm-project') ? [config.folder.src] : []),
    //   config.folder.dist,
    // ];
    // Helpers.info(`Folder to sync: ${toSync.join(',')}`)
    // if (sourceProjects.length === 0) {
    //   Helpers.error(`No project to sync`, false, true);
    // }
    // const sourceProject = _.first(sourceProjects);
    // if (sourceProject.name !== currentProj.name) {
    //   Helpers.error(`Projects are not with the same name:
    //   source:  ${sourceProject.name}
    //   current: ${currentProj.name}
    //   `, false, true);
    // }
    // //#endregion
    // const projects = {
    //   current: currentProj,
    //   source: sourceProject,
    // };
    // const foldersToSyncFromSource = toSync.map(folder => {
    //   return `${sourceProject.location}/`;
    // });
    // for (let index = 0; index < foldersToSyncFromSource.length; index++) {
    //   const destProj = foldersToSyncFromSource[index];
    //   // for (let j = 0; j < toSync.length; j++) {
    //   //   const source = path.join(currentProj.location, toSync[j]);
    //   //   Helpers.info(`
    //   //   source: ${currentProj.genericName}
    //   //   destination:${destProj.genericName}
    //   // `);
    //   //   chokidar.watch([source], {
    //   //     ignoreInitial: false,
    //   //     followSymlinks: false,
    //   //     ignorePermissionErrors: true,
    //   //   }).on('all', async (event, f) => {
    //   //     if (event !== 'addDir' && event !== 'unlinkDir') {
    //   //       const dest = path.join(destProj.location, toSync[j], f.replace(source, ''));
    //   //       Helpers.copyFile(f, dest);
    //   //       Helpers.log(`Copy: ${dest}`);
    //   //     }
    //   //   });
    //   // }
    // }
}
//#endregion
//#region kill
function killAll() {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var db, projectsToKill, p, workspace;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, tnp_db_1.TnpDB.Instance()];
                case 1:
                    db = _a.sent();
                    projectsToKill = [];
                    p = project_1.Project.Current;
                    projectsToKill.push(p);
                    workspace = p.isWorkspaceChildProject ? p.parent : void 0;
                    if (!!workspace) {
                        projectsToKill = projectsToKill.concat(workspace.children);
                    }
                    return [4 /*yield*/, db.killInstancesFrom(projectsToKill)];
                case 2:
                    _a.sent();
                    process.exit(0);
                    return [2 /*return*/];
            }
        });
    });
}
exports.killAll = killAll;
function killonport(args, noExit) {
    if (noExit === void 0) { noExit = false; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var port;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    port = parseInt(args.trim());
                    return [4 /*yield*/, tnp_helpers_1.Helpers.killProcessByPort(port)];
                case 1:
                    _a.sent();
                    if (!noExit) {
                        process.exit(0);
                    }
                    return [2 /*return*/];
            }
        });
    });
}
exports.killonport = killonport;
var $KILL_ON_PORT = function (args) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, killonport(args)];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
var $KILLONPORT = function (args) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, killonport(args)];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
var $KILLALL = function () {
    killAll();
};
var $KILLALLNODE = function () {
    if (process.platform === 'win32') {
        tnp_helpers_1.Helpers.run("taskkill /f /im node.exe").sync();
        return;
    }
    tnp_helpers_1.Helpers.run("fkill -f node").sync();
};
var $KILLWORKER = function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var db;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, tnp_db_1.TnpDB.Instance()];
            case 1:
                db = _a.sent();
                return [4 /*yield*/, db.killWorker()];
            case 2:
                _a.sent();
                tnp_helpers_1.Helpers.info("Done killing worker");
                process.exit(0);
                return [2 /*return*/];
        }
    });
}); };
//#endregion
//#region develop
function $DEVELOP(args, exit) {
    if (exit === void 0) { exit = true; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var _a, kill, db, projects, igt, unknowNPm, projectsToOpen, projectForAction, index, projectToOpen;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = require('minimist')(!args ? [] : args.split(' ')).kill, kill = _a === void 0 ? false : _a;
                    return [4 /*yield*/, tnp_db_1.TnpDB.Instance()];
                case 1:
                    db = _b.sent();
                    return [4 /*yield*/, db.getProjects()];
                case 2:
                    projects = (_b.sent())
                        .map(function (p) { return p.project; })
                        .filter(function (p) { return !p.isGenerated && !p.isGeneratedForRelease; });
                    igt = tnp_core_3.path.join(project_1.Project.Tnp.location, '../..', 'igt');
                    unknowNPm = [];
                    if (tnp_core_2.fse.existsSync(igt)) {
                        projects = projects.concat(tnp_core_2.fse.readdirSync(igt)
                            .map(function (f) {
                            f = tnp_core_3.path.join(igt, f);
                            var proj = project_1.Project.From(f);
                            // console.log(`${f} proj name: ${proj && proj.name}`);
                            if (proj) {
                                unknowNPm.push(proj);
                            }
                            return proj;
                        }));
                    }
                    unknowNPm.forEach(function (p) {
                        var external = tnp_core_3.path.join(p.location, 'external');
                        if (tnp_core_2.fse.existsSync(external)) {
                            projects = projects.concat(tnp_core_2.fse.readdirSync(external)
                                .map(function (f) {
                                f = tnp_core_3.path.join(external, f);
                                var proj = project_1.Project.From(f);
                                // console.log(`external proj name: ${proj && proj.name}`);
                                if (proj) {
                                    unknowNPm.push(proj);
                                }
                                return proj;
                            }));
                        }
                    });
                    projectsToOpen = args.trim().split(' ');
                    projectForAction = [];
                    projectsToOpen.forEach(function (projectName) {
                        try {
                            var regex = new RegExp(projectName);
                        }
                        catch (err) {
                            tnp_helpers_1.Helpers.error("Invalid regular expresion: " + projectName, false, true);
                        }
                        // console.log(`source: "${regex.source}"`)
                        var projs = projects.filter(function (p) {
                            return p && (p.genericName === projectName || regex.test(p.name));
                        });
                        if (projs) {
                            projs.forEach(function (c) { return projectForAction.push(c); });
                        }
                        else {
                            tnp_helpers_1.Helpers.error("Cannot find project: \"" + projectName + "\"", true, true);
                        }
                        // projects.forEach(p => {
                        //   console.log(`Test: ${p && p.name} with ${regex.source} ${p && regex.test(p.name)}`)
                        //   return p && regex.test(p.name);
                        // });
                    });
                    tnp_helpers_1.Helpers.info("\n\n  TO OPEN:\n  " + projectForAction.map(function (p) { return chalk_1.default.bold(p.name) + " (" + p.location + ")"; }).join('\n') + "\n\n  ");
                    killvscode('', false);
                    for (index = 0; index < projectForAction.length; index++) {
                        projectToOpen = projectForAction[index];
                        projectToOpen.openInVscode();
                    }
                    process.exit(0);
                    return [2 /*return*/];
            }
        });
    });
}
exports.$DEVELOP = $DEVELOP;
function killvscode(args, exit) {
    if (exit === void 0) { exit = true; }
    try {
        tnp_helpers_1.Helpers.run("kill -9 $(pgrep Electron)").sync();
        tnp_helpers_1.Helpers.info("Killled");
    }
    catch (error) {
        tnp_helpers_1.Helpers.warn("kill not needed");
    }
    if (exit) {
        process.exit(0);
    }
}
function vscodekill(args) {
    killvscode(args);
}
function close(args) {
    killvscode(args);
}
//#endregion
//#region choki
var CHOKI = function () {
    var project = project_1.Project.Current;
    // console.log(`PRE ASYNC FOR ${this.project.genericName}`)
    tnp_core_4.chokidar.watch([tnp_config_1.config.folder.src, tnp_config_1.config.folder.components], {
        ignoreInitial: true,
        followSymlinks: false,
        ignorePermissionErrors: true,
        cwd: project.location
    }).on('unlinkDir', function (relativeDir) {
    });
};
//#endregion
//#region info / check
function $INFO(args) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var exists, isFolder, isFile, isLink, size, proj;
        return tslib_1.__generator(this, function (_a) {
            if ((args === null || args === void 0 ? void 0 : args.trim()) !== '') {
                if (!tnp_core_3.path.isAbsolute(args)) {
                    args = tnp_core_3.path.join(process.cwd(), args);
                }
                exists = tnp_helpers_1.Helpers.exists(args);
                isFolder = tnp_helpers_1.Helpers.isFolder(args);
                isFile = tnp_helpers_1.Helpers.isFile(args);
                isLink = tnp_helpers_1.Helpers.isLink(args);
                size = tnp_helpers_1.Helpers.size(args);
                tnp_helpers_1.Helpers.info("\n    path: " + args + "\n    cross platforma path: " + tnp_core_1.crossPlatformPath(args) + "\n    exists: " + exists + "\n    isFolder: " + isFolder + "\n    isFile: " + isFile + "\n    isLink: " + isLink + "\n    size: " + size + " bytes\n\n    ");
            }
            else {
                proj = project_1.Project.Current;
                console.clear();
                console.info("\n\n    name: " + proj.name + "\n    version: " + proj.version + "\n    last npm version: " + proj.lastNpmVersion + "\n    frameworkVersion: " + proj._frameworkVersion + "\n    genericName: " + proj.genericName + "\n    isStandaloneProject: " + proj.isStandaloneProject + "\n    isGenerated: " + proj.isGenerated + "\n    isCoreProject: " + proj.isCoreProject + "\n    type: " + proj._type + "\n    parent name: " + (proj.parent && proj.parent.name) + "\n    grandpa name: " + (proj.grandpa && proj.grandpa.name) + "\n    git origin: " + proj.git.originURL + "\n    git branch name: " + proj.git.currentBranchName + "\n    git commits number: " + proj.git.countComits() + "\n\n    ");
            }
            process.exit(0);
            return [2 /*return*/];
        });
    });
}
exports.$INFO = $INFO;
var $CHECK = function (args) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, $INFO(args)];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
//#endregion
//#region fork
var $FORK = function (args) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var argv, githubUrl, projectName, newProj;
    return tslib_1.__generator(this, function (_a) {
        argv = args.trim().split(' ');
        githubUrl = tnp_core_1._.first(argv);
        projectName = tnp_core_1._.last(githubUrl.replace('.git', '').split('/'));
        if (argv.length > 1) {
            projectName = argv[1];
        }
        tnp_helpers_1.Helpers.info("Forking " + githubUrl + " with name " + projectName);
        project_1.Project.Current.git.clone(githubUrl, projectName);
        newProj = project_1.Project.From(tnp_core_3.path.join(project_1.Project.Current.location, projectName));
        tnp_helpers_1.Helpers.setValueToJSON(tnp_core_3.path.join(newProj.location, tnp_config_1.config.file.package_json), 'name', projectName);
        tnp_helpers_1.Helpers.setValueToJSON(tnp_core_3.path.join(newProj.location, tnp_config_1.config.file.package_json), 'version', '0.0.0');
        if (newProj.containsFile('angular.json')) {
            tnp_helpers_1.Helpers.setValueToJSON(tnp_core_3.path.join(newProj.location, tnp_config_1.config.file.package_json), 'tnp.type', 'angular-lib');
            tnp_helpers_1.Helpers.setValueToJSON(tnp_core_3.path.join(newProj.location, tnp_config_1.config.file.package_json), 'tnp.version', 'v2');
            tnp_helpers_1.Helpers.setValueToJSON(tnp_core_3.path.join(newProj.location, tnp_config_1.config.file.package_json), 'scripts', {});
            // const dependencies = Helpers.readValueFromJson(path.join(newProj.location, config.file.package_json), 'dependencies') as Object;
            newProj.run("tnp init").sync();
            newProj = project_1.Project.From(tnp_core_3.path.join(project_1.Project.Current.location, projectName));
            newProj.removeFile('.browserslistrc');
        }
        tnp_helpers_1.Helpers.writeFile(tnp_core_3.path.join(newProj.location, tnp_config_1.config.file.README_MD), "\n# " + projectName + "\n\nbased on " + githubUrl + "\n\n  ");
        tnp_helpers_1.Helpers.run("code " + newProj.location).sync();
        tnp_helpers_1.Helpers.info("Done");
        process.exit(0);
        return [2 /*return*/];
    });
}); };
//#endregion
//#region childs requried
function $CHILDS_REQUIRED(args) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            if (!project_1.Project.Current.isWorkspaceChildProject) {
                tnp_helpers_1.Helpers.error("Not worksapce child", false, true);
            }
            console.log(project_1.Project.Current.sortedRequiredWorkspaceDependencies.map(function (c) { return c.name; }));
            process.exit(0);
            return [2 /*return*/];
        });
    });
}
//#endregion
//#region all projects
function $ALL_PROJECTS(args) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var db, projects;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, tnp_db_1.TnpDB.Instance()];
                case 1:
                    db = _a.sent();
                    return [4 /*yield*/, db.getProjects()];
                case 2:
                    projects = (_a.sent()).map(function (p) { return p.project; });
                    console.log(projects.map(function (p) { return p.info; }).join('\n'));
                    process.exit(0);
                    return [2 /*return*/];
            }
        });
    });
}
exports.$ALL_PROJECTS = $ALL_PROJECTS;
//#endregion
function $NAME_TEST() {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            // CLASS.getConfig($NAME_TEST)[0].
            console.log(typescript_class_helpers_1.CLASS.getName($NAME_TEST));
            return [2 /*return*/];
        });
    });
}
exports.$NAME_TEST = $NAME_TEST;
function NOT(args) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            tnp_core_1._.times(10, function (n) {
                node_notifier_1.notify({
                    message: 'hey' + args + n.toString(),
                    sound: true
                });
            });
            process.exit(0);
            return [2 /*return*/];
        });
    });
}
function $TARGET_PROJ_UPDATE() {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            project_1.Project.Current.targetProjects.update();
            process.exit(0);
            return [2 /*return*/];
        });
    });
}
exports.default = {
    //#region export default
    $TARGET_PROJ_UPDATE: tnp_helpers_1.Helpers.CLIWRAP($TARGET_PROJ_UPDATE, '$TARGET_PROJ_UPDATE'),
    $INFO: tnp_helpers_1.Helpers.CLIWRAP($INFO, '$INFO'),
    $CHECK: tnp_helpers_1.Helpers.CLIWRAP($CHECK, '$CHECK'),
    $ALL_PROJECTS: tnp_helpers_1.Helpers.CLIWRAP($ALL_PROJECTS, '$ALL_PROJECTS'),
    $CHILDS_REQUIRE: tnp_helpers_1.Helpers.CLIWRAP($CHILDS_REQUIRED, '$CHILDS_REQUIRED'),
    $DEVELOP: tnp_helpers_1.Helpers.CLIWRAP($DEVELOP, '$DEVELOP'),
    killvscode: tnp_helpers_1.Helpers.CLIWRAP(killvscode, 'killvscode'),
    vscodekill: tnp_helpers_1.Helpers.CLIWRAP(vscodekill, 'vscodekill'),
    close: tnp_helpers_1.Helpers.CLIWRAP(close, 'close'),
    $KILL_ON_PORT: tnp_helpers_1.Helpers.CLIWRAP($KILL_ON_PORT, '$KILL_ON_PORT'),
    $KILLONPORT: tnp_helpers_1.Helpers.CLIWRAP($KILLONPORT, '$KILLONPORT'),
    $KILLALL: tnp_helpers_1.Helpers.CLIWRAP($KILLALL, '$KILLALL'),
    $KILLALLNODE: tnp_helpers_1.Helpers.CLIWRAP($KILLALLNODE, '$KILLALLNODE'),
    $KILLWORKER: tnp_helpers_1.Helpers.CLIWRAP($KILLWORKER, '$KILLWORKER'),
    CHOKI: tnp_helpers_1.Helpers.CLIWRAP(CHOKI, 'CHOKI'),
    NOT: tnp_helpers_1.Helpers.CLIWRAP(NOT, 'NOT'),
    $FORK: tnp_helpers_1.Helpers.CLIWRAP($FORK, '$FORK'),
    $SYNC_TO: tnp_helpers_1.Helpers.CLIWRAP($SYNC_TO, '$SYNC_TO'),
    $SYNC_FROM: tnp_helpers_1.Helpers.CLIWRAP($SYNC_FROM, '$SYNC_FROM'),
};
//# sourceMappingURL=DEVELOP.backend.js.map