"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var tnp_core_1 = require("tnp-core");
var chalk_1 = require("chalk");
var project_1 = require("../../project");
var tnp_helpers_1 = require("tnp-helpers");
var tnp_core_2 = require("tnp-core");
var tnp_config_1 = require("tnp-config");
var tnp_models_1 = require("tnp-models");
var tnp_core_3 = require("tnp-core");
var USE_HTTPS_INSTEAD_SSH = !tnp_core_3.os.hostname().endsWith('.local'); // TODO
function $GIT_REMOVE_UNTRACKED() {
    var gitginoredfiles = project_1.Project.Current.recreate.filesIgnoredBy.gitignore
        .filter(function (f) { return !(f === tnp_config_1.config.folder.node_modules); }); // link/unlink takes care of node_modules
    gitginoredfiles.forEach(function (f) {
        var p = tnp_core_2.path.join(project_1.Project.Current.location, f);
        if (tnp_core_1.fse.existsSync(p)) {
            try {
                if (tnp_core_1.fse.statSync(p).isDirectory()) {
                    project_1.Project.Current.run("git rm -rf " + f).sync();
                }
                else {
                    project_1.Project.Current.run("git rm " + f).sync();
                }
            }
            catch (error) {
                console.log(error);
            }
        }
    });
    process.exit(0);
}
function $GIT_QUICK_COMMIT_AND_PUSH(args, exit) {
    if (exit === void 0) { exit = true; }
    if (project_1.Project.Current.git.isGitRepo) {
        global.tnpNonInteractive && tnp_models_1.PROGRESS_DATA.log({ msg: "Quick push start" });
        try {
            project_1.Project.Current.run("git add --all . && git commit -m \"update\"").sync();
            global.tnpNonInteractive && tnp_models_1.PROGRESS_DATA.log({ msg: "Adding and Commit Success" });
        }
        catch (e) {
            tnp_helpers_1.Helpers.warn("Error adding/commiting git " + e, false);
        }
        project_1.Project.Current.git.pushCurrentBranch();
        global.tnpNonInteractive && tnp_models_1.PROGRESS_DATA.log({ msg: "Pushing to repository success" });
    }
    else {
        tnp_helpers_1.Helpers.warn("This is not a git repo: " + process.cwd(), false);
    }
    exit && process.exit(0);
}
exports.$GIT_QUICK_COMMIT_AND_PUSH = $GIT_QUICK_COMMIT_AND_PUSH;
function $GIT_QUICK_RESET_HARD_AND_PULL(args, exit) {
    if (exit === void 0) { exit = true; }
    if (project_1.Project.Current.git.isGitRepo) {
        try {
            project_1.Project.Current.run("git reset --hard").sync();
        }
        catch (error) { }
        project_1.Project.Current.git.pullCurrentBranch();
    }
    else {
        tnp_helpers_1.Helpers.error("Not able to pull and reset hard: " + process.cwd());
    }
    exit && process.exit(0);
}
exports.$GIT_QUICK_RESET_HARD_AND_PULL = $GIT_QUICK_RESET_HARD_AND_PULL;
var $GIT_REMOVE_UNTRACKED_EVERYWHERE = function () {
    project_1.Project.projects.forEach(function (p) {
        tnp_helpers_1.Helpers.run(tnp_config_1.config.frameworkName + " " + tnp_helpers_1.Helpers.cliTool.simplifiedCmd($GIT_REMOVE_UNTRACKED.name), { cwd: p.location }).sync();
    });
    process.exit(0);
};
function $PUSH(comitMessage, exit, force) {
    if (exit === void 0) { exit = true; }
    if (force === void 0) { force = false; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, project_1.Project.Current.gitActions.push(comitMessage, force)];
                case 1:
                    _a.sent();
                    process.exit(0);
                    return [2 /*return*/];
            }
        });
    });
}
exports.$PUSH = $PUSH;
function $FORCE_PUSH(comitMessage, exit, force) {
    if (exit === void 0) { exit = true; }
    if (force === void 0) { force = false; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, project_1.Project.Current.gitActions.push(comitMessage, true)];
                case 1:
                    _a.sent();
                    process.exit(0);
                    return [2 /*return*/];
            }
        });
    });
}
exports.$FORCE_PUSH = $FORCE_PUSH;
function $PULL(args, exit) {
    if (exit === void 0) { exit = true; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, project_1.Project.Current.gitActions.pull()];
                case 1:
                    _a.sent();
                    process.exit(0);
                    return [2 /*return*/];
            }
        });
    });
}
exports.$PULL = $PULL;
function $CLONE(args, exit) {
    if (exit === void 0) { exit = true; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var argsss, url, newName;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    argsss = args.split(' ');
                    url = argsss.shift();
                    newName = argsss.shift();
                    return [4 /*yield*/, project_1.Project.Current.git.clone(url, newName)];
                case 1:
                    _a.sent();
                    process.exit(0);
                    return [2 /*return*/];
            }
        });
    });
}
exports.$CLONE = $CLONE;
function $RECOMMIT(args, exit) {
    if (exit === void 0) { exit = true; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var p, lastMsg;
        return tslib_1.__generator(this, function (_a) {
            p = project_1.Project.Current;
            lastMsg = p.run("git log -1 --pretty=%B", { output: false, cwd: p.location }).sync().toString().trim();
            p.run("git reset --soft HEAD~1 && git add --all . && git commit -m \"" + lastMsg + "\"").sync();
            tnp_helpers_1.Helpers.info("Recomit done..msg:\n        " + tnp_helpers_1.Helpers.terminalLine() + "\n        " + lastMsg + "\n        " + tnp_helpers_1.Helpers.terminalLine() + "\n        ");
            if (exit) {
                process.exit(0);
            }
            return [2 /*return*/];
        });
    });
}
exports.$RECOMMIT = $RECOMMIT;
function $REPUSH(args) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, $RECOMMIT(args, false)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, $PUSH(args, true, true)];
                case 2:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
exports.$REPUSH = $REPUSH;
function $SET_ORIGIN(newOriginNameOrUrl) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var proj;
        return tslib_1.__generator(this, function (_a) {
            proj = project_1.Project.Current;
            if (proj && proj.git.isGitRepo) {
                proj.run("git remote rm origin").sync();
                proj.run("git remote add origin " + newOriginNameOrUrl).sync();
                tnp_helpers_1.Helpers.info("Done");
            }
            else {
                tnp_helpers_1.Helpers.error("This folder is not a git repo... ", false, true);
            }
            process.exit(0);
            return [2 /*return*/];
        });
    });
}
exports.$SET_ORIGIN = $SET_ORIGIN;
function $RENAME_ORIGIN(newOriginNameOrUrl) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var proj;
        return tslib_1.__generator(this, function (_a) {
            proj = project_1.Project.Current;
            if (proj && proj.git.isGitRepo) {
                proj.git.renameOrigin(newOriginNameOrUrl);
            }
            else {
                tnp_helpers_1.Helpers.error("This folder is not a git repo... ", false, true);
            }
            process.exit(0);
            return [2 /*return*/];
        });
    });
}
exports.$RENAME_ORIGIN = $RENAME_ORIGIN;
function $DIFF(newOriginNameOrUrl) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        function cmd(p) {
            var out = p.run("git diff --name-only", { output: false }).sync().toString();
            if (out.trim() !== '' && out.trim().split('\n').length > 0) {
                tnp_helpers_1.Helpers.info("" + chalk_1.default.bold(p.genericName));
                console.log("" + out.trim().split('\n').map(function (l) { return [p.location] + "/" + l; }).join('\n'));
            }
            else {
                tnp_helpers_1.Helpers.info(chalk_1.default.bold(p.genericName) + " - nothing has changed...");
            }
        }
        var proj;
        return tslib_1.__generator(this, function (_a) {
            proj = project_1.Project.Current;
            if (proj) {
                if (proj.isContainer) {
                    if (proj.git.isGitRepo) {
                        cmd(proj);
                    }
                    proj.children.forEach(function (c) {
                        cmd(c);
                    });
                }
                else if (proj.git.isGitRepo) {
                    cmd(proj);
                }
            }
            else {
                tnp_helpers_1.Helpers.error("This folder is not a git repo... ", false, true);
            }
            process.exit(0);
            return [2 /*return*/];
        });
    });
}
exports.$DIFF = $DIFF;
function $GIT_INFO() {
    tnp_helpers_1.Helpers.info("\n  Global settings:\n\n  username: " + tnp_helpers_1.Helpers.commnadOutputAsString('git config --global user.name') + "\n  email: " + tnp_helpers_1.Helpers.commnadOutputAsString('git config --global user.email') + "\n\n  Local settings:\n\n  username: " + tnp_helpers_1.Helpers.commnadOutputAsString('git config user.name') + "\n  email: " + tnp_helpers_1.Helpers.commnadOutputAsString('git config user.email') + "\n\n  ");
    process.exit(0);
}
exports.default = {
    $GIT_INFO: tnp_helpers_1.Helpers.CLIWRAP($GIT_INFO, '$GIT_INFO'),
    $GIT_QUICK_COMMIT_AND_PUSH: tnp_helpers_1.Helpers.CLIWRAP($GIT_QUICK_COMMIT_AND_PUSH, '$GIT_QUICK_COMMIT_AND_PUSH'),
    $GIT_QUICK_RESET_HARD_AND_PULL: tnp_helpers_1.Helpers.CLIWRAP($GIT_QUICK_RESET_HARD_AND_PULL, '$GIT_QUICK_RESET_HARD_AND_PULL'),
    $GIT_REMOVE_UNTRACKED: tnp_helpers_1.Helpers.CLIWRAP($GIT_REMOVE_UNTRACKED, '$GIT_REMOVE_UNTRACKED'),
    $GIT_REMOVE_UNTRACKED_EVERYWHERE: tnp_helpers_1.Helpers.CLIWRAP($GIT_REMOVE_UNTRACKED_EVERYWHERE, '$GIT_REMOVE_UNTRACKED_EVERYWHERE'),
    $RENAME_ORIGIN: tnp_helpers_1.Helpers.CLIWRAP($RENAME_ORIGIN, '$RENAME_ORIGIN'),
    $SET_ORIGIN: tnp_helpers_1.Helpers.CLIWRAP($SET_ORIGIN, '$SET_ORIGIN'),
    $PUSH: tnp_helpers_1.Helpers.CLIWRAP($PUSH, '$PUSH'),
    $FORCE_PUSH: tnp_helpers_1.Helpers.CLIWRAP($FORCE_PUSH, '$FORCE_PUSH'),
    $REPUSH: tnp_helpers_1.Helpers.CLIWRAP($REPUSH, '$REPUSH'),
    $PULL: tnp_helpers_1.Helpers.CLIWRAP($PULL, '$PULL'),
    $DIFF: tnp_helpers_1.Helpers.CLIWRAP($DIFF, '$DIFF'),
    $RECOMMIT: tnp_helpers_1.Helpers.CLIWRAP($RECOMMIT, '$RECOMMIT'),
    $CLONE: tnp_helpers_1.Helpers.CLIWRAP($CLONE, '$CLONE'),
};
//# sourceMappingURL=GIT.backend.js.map