"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/operator/map");
require("rxjs/add/operator/takeUntil");
require("rxjs/add/operator/take");
require("rxjs/add/operator/toPromise");
var ng2_logger_1 = require("ng2-logger");
var log = ng2_logger_1.Log.create('resouce-service', ng2_logger_1.Level.__NOTHING);
var rest_class_1 = require("./rest.class");
var rest_request_1 = require("./rest-request");
var rest_headers_1 = require("./rest-headers");
var cookie_1 = require("./cookie");
var params_1 = require("./params");
var Resource = /** @class */ (function () {
    //#endregion
    //#region constructor
    function Resource() {
        var _this = this;
        setTimeout(function () {
            var zone = _this.getZone();
            if (!rest_request_1.RestRequest.zone)
                rest_request_1.RestRequest.zone = zone;
        });
    }
    Object.defineProperty(Resource, "listenErrors", {
        get: function () {
            return this._listenErrors.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    //#region private mthods and fields
    Resource.prototype.getZone = function () {
        var isNode = (typeof window === 'undefined');
        if (isNode)
            return;
        var ng = window['ng'];
        var getAllAngularRootElements = window['getAllAngularRootElements'];
        if (!ng || !getAllAngularRootElements)
            return;
        var probe = ng.probe;
        var coreTokens = ng.coreTokens;
        if (!coreTokens.NgZone)
            return;
        var zoneClass = coreTokens.NgZone;
        if (!probe || typeof probe !== 'function' || !getAllAngularRootElements)
            return;
        var angularElements = getAllAngularRootElements();
        if (!Array.isArray(angularElements) || angularElements.length === 0)
            return;
        var rootElement = ng.probe(angularElements[0]);
        if (!rootElement)
            return;
        var injector = rootElement.injector;
        if (!injector || !injector.get || typeof injector.get !== 'function')
            return;
        var zone = injector.get(zoneClass);
        return zone;
    };
    Resource.initAngularNgZone = function (zone) {
        rest_request_1.RestRequest.zone = zone;
    };
    Resource.prototype.checkNestedModels = function (model, allModels) {
        // if (model.indexOf('/') !== -1) { //TODO make this better, becouse now I unecesary checking shit
        for (var p in allModels) {
            if (allModels.hasOwnProperty(p)) {
                var m = allModels[p];
                if (params_1.isValid(p)) {
                    var urlModels = params_1.getModels(p);
                    if (params_1.containsModels(model, urlModels)) {
                        model = p;
                        break;
                    }
                }
            }
        }
        // }
        return model;
    };
    Resource.getModel = function (endpoint, model) {
        model = Resource.prepareModel(model);
        var e = Resource.endpoints[endpoint];
        if (!e) {
            return void 0;
        }
        var r = Resource.endpoints[endpoint].models[model];
        return Resource.endpoints[endpoint].models[model];
    };
    //#endregion
    //#region create
    Resource.create = function (e, model, entityMapping, circular) {
        var badRestRegEX = new RegExp('((\/:)[a-z]+)+', 'g');
        var matchArr = model.match(badRestRegEX) || [];
        var badModelsNextToEachOther = matchArr.join();
        var atleas2DoubleDots = ((badModelsNextToEachOther.match(new RegExp(':', 'g')) || []).length >= 2);
        if (atleas2DoubleDots && model.search(badModelsNextToEachOther) !== -1) {
            throw new Error("\n\nBad rest model: " + model + "\n\nDo not create rest models like this:    /book/author/:bookid/:authorid\nInstead use nested approach:            /book/:bookid/author/:authorid\n            ");
        }
        ;
        Resource.map(e, e);
        Resource.instance.add(e, model ? model : '', entityMapping, circular);
        // if (model.charAt(model.length - 1) !== '/') model = `${model}/`;
        return {
            model: function (params) { return Resource.instance.api(e, params_1.interpolateParamsToUrl(params, model)); },
            replay: function (method) {
                Resource.getModel(e, model).replay(method);
            },
            get headers() {
                return Resource.getModel(e, model).headers;
            }
        };
    };
    //#endregion
    //#region reset
    Resource.reset = function () {
        Resource.endpoints = {};
    };
    //#region map
    Resource.map = function (endpoint, url) {
        log.i('url', url);
        var regex = /(http|https):\/\/(\w+:{0,1}\w*)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%!\-\/]))?/;
        var e = endpoint;
        if (!regex.test(url)) {
            throw "Url address is not correct: " + url;
        }
        if (url.charAt(url.length - 1) === '/')
            url = url.slice(0, url.length - 1);
        log.i('url after', url);
        if (Resource.endpoints[e] !== void 0) {
            !global.hideLog && console.warn('Cannot use map function at the same API endpoint again ('
                + Resource.endpoints[e].url + ')');
            return false;
        }
        Resource.endpoints[e] = {
            url: url,
            models: {},
            entity: null
        };
        log.i('enpoints', Resource.endpoints);
        return true;
    };
    //#endregion
    Resource.prepareModel = function (model) {
        if (model.charAt(model.length - 1) === '/')
            model = model.slice(0, model.length - 1);
        if (model.charAt(0) === '/')
            model = model.slice(1, model.length);
        return model;
    };
    //#region add
    /**
     * And enipoint to application
     *
     * @param {E} endpoint
     * @param {string} model
     * @returns {boolean}
     */
    Resource.prototype.add = function (endpoint, model, entity, circular) {
        log.i("I am maping " + model + " on " + endpoint);
        model = Resource.prepareModel(model);
        var e;
        e = (endpoint).toString();
        if (Resource.endpoints[e] === void 0) {
            console.error('Endpoint is not mapped ! Cannot add model ' + model);
            return;
        }
        if (Resource.endpoints[e].models[model] !== void 0) {
            if (Resource.enableWarnings)
                console.warn("Model '" + model + "' is already defined in endpoint: "
                    + Resource.endpoints[e].url);
            return;
        }
        Resource.endpoints[e].models[model] =
            new rest_class_1.Rest(Resource.endpoints[e].url
                + '/' + model, Resource.request, {
                endpoint: e,
                path: model,
                entity: entity,
                circular: circular
            });
        return;
    };
    //#endregion
    //#region api
    /**
     * Access api throught endpoint
     *
     * @param {E} endpoint
     * @param {string} model
     * @returns {Rest<T, TA>}
     */
    Resource.prototype.api = function (endpoint, model) {
        // log.i(`[api]
        // creating for endpoint: "${endpoint}"
        // model: "${model}"
        // `)
        if (model.charAt(0) === '/')
            model = model.slice(1, model.length);
        var e = (endpoint).toString();
        if (Resource.endpoints[e] === void 0) {
            throw "Endpoint: " + endpoint + " is not mapped ! Cannot add model: " + model;
        }
        var allModels = Resource.endpoints[e].models;
        var orgModel = model;
        model = this.checkNestedModels(model, allModels);
        if (Resource.endpoints[e].models[model] === void 0) {
            // log.d('Resource.endpoints', Resource.endpoints);
            throw "Model '" + model + "' is undefined in endpoint: " + Resource.endpoints[e].url + " ";
        }
        var res = Resource.endpoints[(endpoint).toString()].models[model];
        // log.d(`
        // orgModel: ${orgModel}
        // model: ${model}
        // `)
        if (orgModel !== model) {
            var baseUrl = Resource.endpoints[(endpoint).toString()].url;
            // log.d('base', Resource.endpoints[<string>(endpoint).toString()])
            // log.d('baseUrl', baseUrl)
            // log.d('orgModel', orgModel)
            res.__rest_endpoint = baseUrl + "/" + orgModel;
        }
        else {
            res.__rest_endpoint = void 0;
        }
        ;
        // log.i(`Resource.endpoints`, Resource.endpoints)
        return res;
    };
    Resource.DEFAULT_HEADERS = rest_headers_1.RestHeaders.from({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    });
    Resource._listenErrors = new Subject_1.Subject();
    Resource.enableWarnings = true;
    Resource.instance = new Resource();
    Resource.endpoints = {};
    Resource.request = new rest_request_1.RestRequest();
    //#endregion
    Resource.Cookies = cookie_1.Cookie.Instance;
    return Resource;
}());
exports.Resource = Resource;
// const res = Resource.create('')
// res.model()
//   .mock({
//     code: 500,
//     data: {},
//     isArray: true
//   })
//   .array.
//# sourceMappingURL=resource.service.js.map