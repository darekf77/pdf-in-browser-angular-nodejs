import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';
import 'rxjs/add/operator/map';
import { RestHeaders } from './rest-headers';
import { Rest } from './rest.class';
import { Cookie } from './cookie';
import { Mapping } from './mapping';
import { Models as HelpersModels } from 'typescript-class-helpers';
import { Circ } from 'json10';
import { RequestCache } from './request-cache';
import { ConfigModels } from 'tnp-config';
export declare namespace Models {
    export import HttpMethod = ConfigModels.HttpMethod;
    export import ParamType = ConfigModels.ParamType;
    export import MethodConfig = HelpersModels.MethodConfig;
    export import ClassConfig = HelpersModels.ClassConfig;
    export import ParamConfig = HelpersModels.ParamConfig;
    interface HandleResultOptions {
        res: Models.MockResponse;
        method: Models.HttpMethod;
        jobid?: number;
        isArray?: boolean;
    }
    interface HandleResultSourceRequestOptions {
        url: string;
        method: Models.HttpMethod;
        body: any;
        isArray: boolean;
    }
    type BackendError = {
        msg?: string;
        stack?: string[];
        data: any;
    };
    type MetaRequest = {
        path: string;
        endpoint: string;
        entity: Mapping.Mapping;
        circular: Circ[];
    };
    type HttpCode = 200 | 400 | 401 | 404 | 500;
    type PromiseObservableMix<T> = Promise<T> & {
        cache?: RequestCache;
        observable: Observable<T>;
    };
    type MethodWithoutBody<E, T, R = PromiseObservableMix<E>> = (params?: UrlParams[], doNotSerializeParams?: boolean) => R;
    type MethodWithBody<E, T, R = PromiseObservableMix<E>> = (item?: T, params?: UrlParams[], doNotSerializeParams?: boolean) => R;
    type ReplayData = {
        subject: Subject<any>;
        data: {
            url: string;
            body: string;
            headers: RestHeaders;
            isArray: boolean;
        };
        /**
         * jobid
         */
        id: number;
    };
    type ReqParams = {
        url: string;
        method: ConfigModels.HttpMethod;
        headers?: RestHeaders;
        body?: any;
        jobid: number;
        isArray: boolean;
    };
    interface ResourceModel<A, TA> {
        model: (pathModels?: Object, responseObjectType?: Function) => Rest<A, TA>;
        replay: (method: ConfigModels.HttpMethod) => void;
        headers: RestHeaders;
    }
    interface Ng2RestMethods<E, T> {
        get: MethodWithoutBody<E, T>;
        post: MethodWithBody<E, T>;
        put: MethodWithBody<E, T>;
        patch: MethodWithBody<E, T>;
        head: MethodWithoutBody<E, T>;
        delete: MethodWithoutBody<E, T>;
        jsonp: MethodWithoutBody<E, T>;
    }
    type MockController = (url: string, method: ConfigModels.HttpMethod, headers?: RestHeaders, body?: any) => MockResponse;
    type MockHttp = (MockResponse | MockController);
    interface FnMethodsHttp<T, TA> extends Ng2RestMethods<HttpResponse<T>, T> {
        array: Ng2RestMethods<HttpResponse<TA>, TA>;
    }
    interface FnMethodsHttpWithMock<T, TA> extends Ng2RestMethods<HttpResponse<T>, T> {
        array: Ng2RestMethods<HttpResponse<TA>, TA>;
        mock(mock: MockHttp, code: HttpCode): FnMethodsHttp<T, TA>;
    }
    interface NestedParams {
        [params: string]: string;
    }
    interface UrlParams {
        [urlModelName: string]: string | number | boolean | RegExp | Object;
        regex?: RegExp;
    }
    abstract class BaseBody {
        protected toJSON(data: any, isJSONArray?: boolean): any;
    }
    class HttpBody<T> extends BaseBody {
        private body;
        private isArray;
        private entity;
        private circular;
        constructor(body: string, isArray: boolean, entity: Mapping.Mapping, circular: Circ[]);
        get booleanValue(): boolean;
        get json(): T;
        get text(): string;
    }
    class ErrorBody extends BaseBody {
        private data;
        constructor(data: any);
        get json(): Object;
        get text(): any;
    }
    abstract class BaseResponse<T> {
        responseText?: string;
        readonly headers?: RestHeaders;
        readonly statusCode?: HttpCode | number;
        isArray: boolean;
        protected static readonly cookies: Cookie;
        get cookies(): Cookie;
        constructor(responseText?: string, headers?: RestHeaders, statusCode?: HttpCode | number, isArray?: boolean);
    }
    class HttpResponse<T> extends BaseResponse<T> {
        sourceRequest: Models.HandleResultSourceRequestOptions;
        responseText?: string;
        headers?: RestHeaders;
        statusCode?: HttpCode | number;
        entity?: Mapping.Mapping;
        circular?: Circ[];
        jobid?: number;
        isArray: boolean;
        body?: HttpBody<T>;
        rq: RequestCache;
        constructor(sourceRequest: Models.HandleResultSourceRequestOptions, responseText?: string, headers?: RestHeaders, statusCode?: HttpCode | number, entity?: Mapping.Mapping, circular?: Circ[], jobid?: number, isArray?: boolean);
        init(): void;
        get cache(): RequestCache;
    }
    class HttpResponseError extends BaseResponse<any> {
        message: string;
        jobid?: number;
        private body;
        constructor(message: string, responseText?: string, headers?: RestHeaders, statusCode?: HttpCode | number, jobid?: number);
    }
    interface MockResponse {
        data?: any;
        code?: HttpCode;
        error?: string;
        headers?: RestHeaders;
        jobid?: number;
        isArray: boolean;
    }
}
