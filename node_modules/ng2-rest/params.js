"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var diff_1 = require("diff");
var tnp_core_1 = require("tnp-core");
var ng2_logger_1 = require("ng2-logger");
var helpers_1 = require("./helpers");
var log = ng2_logger_1.Log.create('[ng2-rest] params', ng2_logger_1.Level.__NOTHING);
/** check if string is a valid pattern */
function isValid(pattern) {
    return (new RegExp('\/:[a-zA-Z]*', 'g')).test(pattern.replace('://', ''));
}
exports.isValid = isValid;
function check(url, pattern) {
    if (!helpers_1.Helpers.checkValidUrl(url)) {
        log.error("Incorrect url: " + url);
        return false;
    }
    if (url.charAt(url.length - 1) === '/')
        url = url.slice(0, url.length - 2);
    if (pattern.charAt(pattern.length - 1) === '/')
        pattern = pattern.slice(0, url.length - 2);
    pattern = pattern.replace(/\//g, '\/');
    pattern = pattern.replace(new RegExp('\/:[a-zA-Z]*', 'g'), '.+');
    var reg = new RegExp(pattern, 'g');
    return reg.test(url);
}
exports.check = check;
function getModels(pattern) {
    var m = pattern.match(new RegExp('[a-z-A-Z]*\/:', 'g'));
    return m.map(function (p) { return p.replace('/:', ''); });
}
exports.getModels = getModels;
function getRestPramsNames(pattern) {
    if (pattern.charAt(pattern.length - 1) !== '/')
        pattern = pattern + "/";
    var m = pattern.match(new RegExp(':[a-zA-Z]*\/', 'g'));
    var res = m.map(function (p) { return p.replace(':', '').replace('/', ''); });
    return res.filter(function (p) { return p.trim() !== ''; });
}
exports.getRestPramsNames = getRestPramsNames;
function containsModels(url, models) {
    if (url.charAt(0) !== '/')
        url = '/' + url;
    // url = url.replace(new RegExp('\/', 'g'), '');
    var res = models.filter(function (m) {
        var word = '/' + m;
        // log.d('word', word)
        var iii = url.indexOf(word);
        // log.d('iii', iii)
        if (iii + word.length < url.length && url.charAt(iii + word.length) !== '/') {
            return false;
        }
        if (iii !== -1) {
            url = url.replace(new RegExp('\/' + m, 'g'), '');
            return true;
        }
        return false;
    }).length;
    // log.d('containsModels', res);
    return res === models.length;
}
exports.containsModels = containsModels;
function stars(n) {
    var res = '';
    for (var i = 0; i < n; i++)
        res += '*';
    return res;
}
exports.stars = stars;
function getRestParams(url, pattern) {
    var res = {};
    var models = getRestPramsNames(pattern);
    // log.d('models', models);
    models.forEach(function (m) {
        pattern = pattern.replace(":" + m, stars(m.length));
    });
    var currentModel = void 0;
    diff_1.diffChars(pattern, url).forEach(function (d) {
        // log.d('d', d);
        if (d.added) {
            if (!isNaN(Number(d.value)))
                res[currentModel] = Number(d.value);
            else if (d.value.trim() === 'true')
                res[currentModel] = true;
            else if (d.value.trim() === 'false')
                res[currentModel] = false;
            else
                res[currentModel] = decodeURIComponent(d.value);
            currentModel = void 0;
        }
        var m = d.value.replace(':', "");
        // log.d('model m', m)
        if (d.removed) {
            currentModel = models.shift();
        }
    });
    return res;
}
exports.getRestParams = getRestParams;
exports.regexisPath = /[^\..]+(\.[^\..]+)+/g;
/**
 * Models like books/:id
 */
function cutUrlModel(params, models, output) {
    if (models.length === 0)
        return output.join('\/');
    var m = models.pop();
    var param = m.match(/:[a-zA-Z0-9\.]+/)[0].replace(':', '');
    var paramIsPath = exports.regexisPath.test(param);
    // log.i('cut param', param)
    var model = m.match(/[a-zA-Z0-9]+\//)[0].replace('\/', '');
    if (params === void 0 ||
        (paramIsPath ? tnp_core_1._.get(params, param) === void 0 : params[param] === void 0) ||
        param === 'undefined') {
        output.length = 0;
        output.unshift(model);
        return cutUrlModel(params, models, output);
    }
    else {
        if (paramIsPath) {
            // log.i('param is path', param)
            var mrep = m.replace(new RegExp(":" + param, 'g'), "" + tnp_core_1._.get(params, param));
            output.unshift(mrep);
            return cutUrlModel(params, models, output);
        }
        else {
            // log.i('param is normal', param)
            var mrep = m.replace(new RegExp(":" + param, 'g'), "" + params[param]);
            output.unshift(mrep);
            return cutUrlModel(params, models, output);
        }
    }
}
function interpolateParamsToUrl(params, url) {
    var regexInt = /\[\[([^\..]+\.[^\..]+)+\]\]/g;
    url = url.split('/').map(function (p) {
        // log.d('url parts', p)
        var isParam = p.startsWith(':');
        if (isParam) {
            var part = p.slice(1);
            // log.d('url param part', p)
            if (regexInt.test(part)) {
                // let level = (url.split('.').length - 1)
                part = part.replace('[[', '');
                part = part.replace(']]', '');
            }
            return ":" + part;
        }
        return p;
    }).join('/');
    // log.i('URL TO EXPOSE', url)
    // log.i('params', params)
    var slash = {
        start: url.charAt(0) === '\/',
        end: url.charAt(url.length - 1) === '\/'
    };
    var morePramsOnEnd = url.match(/(\/:[a-zA-Z0-9\.]+){2,10}/g);
    if (morePramsOnEnd && (Array.isArray(morePramsOnEnd) && morePramsOnEnd.length === 1)) {
        // log.i('morePramsOnEnd', morePramsOnEnd)
        var m = morePramsOnEnd[0];
        var match = m.match(/\/:[a-zA-Z0-9\.]+/g);
        // log.i('match', match)
        match.forEach(function (e) {
            var c = e.replace('\/:', '');
            // log.i('c', c)
            if (exports.regexisPath.test(c)) {
                url = url.replace(e, "/" + tnp_core_1._.get(params, c));
            }
            else {
                url = url.replace(e, "/" + params[c]);
            }
            // log.i('prog url', url)
        });
        return url;
    }
    var nestedParams = url.match(/[a-zA-Z0-9]+\/:[a-zA-Z0-9\.]+/g);
    if (!nestedParams || (Array.isArray(nestedParams) && nestedParams.length === 0))
        return url;
    // check alone params
    if (!slash.end)
        url = url + "/";
    var addUndefinedForAlone = (!/:[a-zA-Z0-9\.]+\/$/g.test(url) && /[a-zA-Z0-9]+\/$/g.test(url));
    var replace = (nestedParams.length > 1 ? nestedParams.join('\/') : nestedParams[0]) +
        (addUndefinedForAlone ? '\/' + url.match(/[a-zA-Z0-9]+\/$/g)[0] : '\/');
    var beginHref = url.replace(replace, '');
    if (addUndefinedForAlone) {
        url = url.replace(/\/$/g, '/:undefined');
        nestedParams = url.match(/[a-zA-Z0-9]+\/:[a-zA-Z0-9\.]+/g);
        url = cutUrlModel(params, nestedParams, []);
    }
    else {
        url = cutUrlModel(params, nestedParams, []);
    }
    url = beginHref + url;
    if (url.charAt(url.length - 1) !== '/' && slash.end)
        url = url + "/";
    if (url.charAt(0) !== '\/' && slash.start)
        url = "/" + url;
    return url;
}
exports.interpolateParamsToUrl = interpolateParamsToUrl;
/**
 * Get query params from url, like 'ex' in /api/books?ex=value
*/
function decodeUrl(url) {
    var regex = /[?&]([^=#]+)=([^&#]*)/g, params = {}, match;
    while (match = regex.exec(url)) {
        params[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);
    }
    var paramsObject = params;
    for (var p in paramsObject) {
        if (paramsObject[p] === void 0) {
            delete paramsObject[p];
            continue;
        }
        if (paramsObject.hasOwnProperty(p)) {
            // chcek if property is number
            var n = Number(params[p]);
            if (!isNaN(n)) {
                params[p] = n;
                continue;
            }
            if (typeof params[p] === 'string') {
                // check if property is object
                var json = void 0;
                try {
                    json = JSON.parse(params[p]);
                }
                catch (error) { }
                if (json !== void 0) {
                    params[p] = json;
                    continue;
                }
                // chcek if property value is like regular rexpression
                // let regexExpression;
                // try {
                //     regexExpression = new RegExp(params[p]);
                // } catch (e) { }
                // if (regexExpression !== undefined) params[p] = regexExpression;
            }
        }
    }
    return params;
}
exports.decodeUrl = decodeUrl;
/**
 * Create query params string for url
 *
 * @export
 * @param {UrlParams[]} params
 * @returns {string}
 */
function getParamsUrl(params, doNotSerialize) {
    if (doNotSerialize === void 0) { doNotSerialize = false; }
    var urlparts = [];
    if (!params)
        return '';
    if (!(params instanceof Array))
        return '';
    if (params.length === 0)
        return '';
    params.forEach(function (urlparam) {
        if (JSON.stringify(urlparam) !== '{}') {
            var parameters = [];
            var paramObject = urlparam;
            for (var p in paramObject) {
                if (paramObject[p] === void 0)
                    delete paramObject[p];
                if (paramObject.hasOwnProperty(p) && typeof p === 'string' && p !== 'regex' && !(paramObject[p] instanceof RegExp)) {
                    if (p.length > 0 && p[0] === '/') {
                        var newName = p.slice(1, p.length - 1);
                        urlparam[newName] = urlparam[p];
                        urlparam[p] = void 0;
                        p = newName;
                    }
                    if (p.length > 0 && p[p.length - 1] === '/') {
                        var newName = p.slice(0, p.length - 2);
                        urlparam[newName] = urlparam[p];
                        urlparam[p] = void 0;
                        p = newName;
                    }
                    var v = urlparam[p];
                    if (v instanceof Object) {
                        urlparam[p] = JSON.stringify(urlparam[p]);
                    }
                    urlparam[p] = doNotSerialize ? urlparam[p] : encodeURIComponent(urlparam[p]);
                    if (urlparam.regex !== void 0 && urlparam.regex instanceof RegExp) {
                        if (!urlparam.regex.test(urlparam[p])) {
                            console.warn("Data: " + urlparam[p] + " incostistent with regex " + urlparam.regex.source);
                        }
                    }
                    parameters.push(p + "=" + urlparam[p]);
                }
            }
            urlparts.push(parameters.join('&'));
        }
    });
    var join = urlparts.join().trim();
    if (join.trim() === '')
        return '';
    return "?" + urlparts.join('&');
}
exports.getParamsUrl = getParamsUrl;
function transform(o) {
    if (typeof o === 'object') {
        return encodeURIComponent(JSON.stringify(o));
    }
    return o;
}
function prepareUrlOldWay(params) {
    if (!params)
        return this.endpoint;
    if (typeof params === 'object') {
        params = transform(params);
    }
    return this.endpoint + '/' + params;
}
exports.prepareUrlOldWay = prepareUrlOldWay;
//# sourceMappingURL=params.js.map