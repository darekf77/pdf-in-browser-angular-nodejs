"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Subject_1 = require("rxjs/Subject");
require("rxjs/add/operator/map");
require("rxjs/add/operator/takeUntil");
require("rxjs/add/operator/take");
var tnp_core_1 = require("tnp-core");
var models_1 = require("./models");
var rest_headers_1 = require("./rest-headers");
var tnp_core_2 = require("tnp-core");
var ng2_logger_1 = require("ng2-logger");
var axios_1 = require("axios");
var resource_service_1 = require("./resource.service");
var ng2_logger_2 = require("ng2-logger");
var util_1 = require("util");
var request_cache_1 = require("./request-cache");
var log = ng2_logger_2.Log.create('[ng2-rest] rest-request', ng2_logger_1.Level.__NOTHING);
var jobIDkey = 'jobID';
//#region mock request
//#endregion
var RestRequest = /** @class */ (function () {
    function RestRequest() {
        this.subjectInuUse = {};
        this.meta = {};
        //#endregion
        this.replaySubjects = {};
    }
    RestRequest.prototype.handlerResult = function (options, sourceRequest) {
        if (util_1.isUndefined(options)) {
            options = {};
        }
        // log.d(`HANDLE RESULT (jobid:${options.jobid}) ${sourceRequest.url}`);
        var res = options.res, jobid = options.jobid, isArray = options.isArray, method = options.method;
        // if (this.endedJobs[jobid]) {
        //   debugger
        // }
        // this.endedJobs[jobid] = true;
        // log.i(`handle jobid ${jobid}`)
        if (typeof res !== 'object') {
            throw new Error('No resposnse for request. ');
        }
        if (tnp_core_2.Helpers.isBrowser) {
            res.headers = rest_headers_1.RestHeaders.from(res.headers);
        }
        // error no internet
        if (res.error) {
            this.subjectInuUse[jobid].error(new models_1.Models.HttpResponseError(res.error, res.data, res.headers, res.code, jobid));
            return;
        }
        var entity = this.meta[jobid].entity;
        var circular = this.meta[jobid].circular;
        this.subjectInuUse[jobid].next(new models_1.Models.HttpResponse(sourceRequest, res.data, res.headers, res.code, entity, circular, jobid, isArray));
        this.meta[jobid] = void 0;
        return;
    };
    RestRequest.prototype.checkCache = function (sourceRequest, jobid) {
        var existedInCache = request_cache_1.RequestCache.findBy(sourceRequest);
        if (existedInCache) {
            log.i('cache exists', existedInCache);
            this.subjectInuUse[jobid].next(existedInCache);
            return true;
        }
        // log.i(`cache not exists for jobid ${jobid}`)
        return false;
    };
    RestRequest.prototype.req = function (url, method, headers, body, jobid, isArray, mockHttp) {
        if (isArray === void 0) { isArray = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response, r, catchedError_1, err, msg, stack, error;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.checkCache({
                            url: url,
                            body: body,
                            isArray: isArray,
                            method: method
                        }, jobid)) {
                            return [2 /*return*/];
                        }
                        if (mockHttp) {
                            if (typeof mockHttp === 'object') {
                                response = {
                                    data: mockHttp.data,
                                    status: mockHttp.code,
                                    headers: mockHttp.headers,
                                    statusText: mockHttp.error,
                                    config: {}
                                };
                            }
                            else if (typeof mockHttp === 'function') {
                                r = mockHttp(url, method, headers, body);
                                response = {
                                    data: r.data,
                                    status: r.code,
                                    headers: r.headers,
                                    statusText: r.error,
                                    config: {}
                                };
                            }
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        if (!!response) return [3 /*break*/, 3];
                        log.d("[" + method + "] (jobid=" + jobid + ") request to:  " + url);
                        return [4 /*yield*/, axios_1.default({
                                url: url,
                                method: method,
                                data: body,
                                responseType: 'text',
                                headers: headers.toJSON()
                            })
                            // log.d(`after response of jobid: ${jobid}`);
                        ];
                    case 2:
                        response = _a.sent();
                        _a.label = 3;
                    case 3:
                        this.handlerResult({
                            res: {
                                code: response.status,
                                data: JSON.stringify(response.data),
                                isArray: isArray,
                                jobid: jobid,
                                headers: rest_headers_1.RestHeaders.from(response.headers)
                            },
                            method: method,
                            jobid: jobid,
                            isArray: isArray
                        }, {
                            url: url,
                            body: body,
                            method: method,
                            isArray: isArray,
                        });
                        return [3 /*break*/, 5];
                    case 4:
                        catchedError_1 = _a.sent();
                        // console.log('ERROR RESPONESE catchedError typeof ', typeof catchedError)
                        // console.log('ERROR RESPONESE catchedError', catchedError)
                        if (typeof catchedError_1 === 'object' && catchedError_1.response && catchedError_1.response.data) {
                            err = catchedError_1.response.data;
                            msg = catchedError_1.response.data.message || '';
                            stack = (err.stack || '').split('\n');
                            resource_service_1.Resource['_listenErrors'].next({
                                msg: msg,
                                stack: stack,
                                data: catchedError_1.response.data
                            });
                        }
                        error = (catchedError_1 && catchedError_1.response) ? "[" + catchedError_1.response.statusText + "]: " : '';
                        this.handlerResult({
                            res: {
                                code: (catchedError_1 && catchedError_1.response) ? catchedError_1.response.status : void 0,
                                error: "" + error + catchedError_1.message,
                                data: (catchedError_1 && catchedError_1.response) ? JSON.stringify(catchedError_1.response.data) : void 0,
                                isArray: isArray,
                                jobid: jobid,
                                headers: rest_headers_1.RestHeaders.from(catchedError_1 && catchedError_1.response && catchedError_1.response.headers)
                            },
                            method: method,
                            jobid: jobid,
                            isArray: isArray
                        }, {
                            url: url,
                            body: body,
                            isArray: isArray,
                            method: method
                        });
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    RestRequest.prototype.getReplay = function (method, meta, onlyGetLastReplayForMethod) {
        var replay;
        //#region prevent empty tree
        if (tnp_core_1._.isUndefined(this.replaySubjects[meta.endpoint])) {
            // log.i(`(${meta.endpoint}) `);
            this.replaySubjects[meta.endpoint] = {};
        }
        if (tnp_core_1._.isUndefined(this.replaySubjects[meta.endpoint][meta.path])) {
            // log.i(`(${meta.endpoint})(${meta.path}) `);
            this.replaySubjects[meta.endpoint][meta.path] = {};
        }
        if (tnp_core_1._.isUndefined(this.replaySubjects[meta.endpoint][meta.path][method])) {
            // log.i(`(${meta.endpoint})(${meta.path}) `);
            this.replaySubjects[meta.endpoint][meta.path][method] = {};
        }
        //#endregion
        var objectIDToCreateOrLast = (Object.keys(this.replaySubjects[meta.endpoint][meta.path][method]).length) +
            (onlyGetLastReplayForMethod ? 0 : 1);
        if (onlyGetLastReplayForMethod && (objectIDToCreateOrLast === 0)) {
            return replay;
        }
        if (tnp_core_1._.isUndefined(this.replaySubjects[meta.endpoint][meta.path][method][objectIDToCreateOrLast])) {
            // log.i(`(${meta.endpoint})(${meta.path})(${method}) `);
            this.replaySubjects[meta.endpoint][meta.path][method][objectIDToCreateOrLast] = {
                subject: new Subject_1.Subject(),
                data: void 0,
            };
        }
        replay = this.replaySubjects[meta.endpoint][meta.path][method][objectIDToCreateOrLast];
        if (!tnp_core_1._.isNumber(replay.id)) {
            var jobid = RestRequest.jobId++;
            replay.id = jobid;
            var subject = replay.subject;
            subject[jobIDkey] = jobid; // modify internal rxjs subject obj
            this.meta[jobid] = meta;
            this.subjectInuUse[jobid] = subject;
            //#region DISPOSE  @UNCOMMENT AFTER TESTS
            // if (objectIDToCreateOrLast > 2) {
            //   const oldReq: Models.ReplayData = this.replaySubjects[meta.endpoint][meta.path][method][(objectIDToCreateOrLast - 2)];
            //   if (_.isUndefined(this.meta[oldReq.id])) {
            //     // cant delete this - for counter purpose
            //     this.replaySubjects[meta.endpoint][meta.path][method][(objectIDToCreateOrLast - 2)] = {};
            //     delete this.subjectInuUse[oldReq.id];
            //     delete this.meta[oldReq.id];
            //   }
            // }
            //#endregion
        }
        return replay;
    };
    //#region http methods
    RestRequest.prototype.generalReq = function (method, url, body, headers, meta, isArray, mockHttp) {
        var replay = this.getReplay(method, meta, false);
        replay.data = { url: url, body: body, headers: headers, isArray: isArray };
        (function (pthis, purl, pmethod, pheaders, pbody, pid, pisArray, pmockHttp) {
            // log.d(`for ${purl} jobid ${pid}`);
            setTimeout(function () { return pthis.req(purl, pmethod, pheaders, pbody, pid, pisArray, pmockHttp); });
        })(this, url, method, headers, body, replay.id, isArray, mockHttp);
        var resp = replay.subject.asObservable().take(1).toPromise();
        resp.observable = replay.subject.asObservable();
        resp.cache = request_cache_1.RequestCache.findBy({
            body: body,
            isArray: isArray,
            method: method,
            url: url
        });
        return resp;
    };
    RestRequest.prototype.get = function (url, body, headers, meta, isArray, mockHttp) {
        return this.generalReq('get', url, body, headers, meta, isArray, mockHttp);
    };
    RestRequest.prototype.head = function (url, body, headers, meta, isArray, mockHttp) {
        return this.generalReq('head', url, body, headers, meta, isArray, mockHttp);
    };
    RestRequest.prototype.delete = function (url, body, headers, meta, isArray, mockHttp) {
        return this.generalReq('delete', url, body, headers, meta, isArray, mockHttp);
    };
    RestRequest.prototype.post = function (url, body, headers, meta, isArray, mockHttp) {
        return this.generalReq('post', url, body, headers, meta, isArray, mockHttp);
    };
    RestRequest.prototype.put = function (url, body, headers, meta, isArray, mockHttp) {
        return this.generalReq('put', url, body, headers, meta, isArray, mockHttp);
    };
    RestRequest.prototype.patch = function (url, body, headers, meta, isArray, mockHttp) {
        return this.generalReq('patch', url, body, headers, meta, isArray, mockHttp);
    };
    RestRequest.prototype.jsonp = function (url, body, headers, meta, isArray, mockHttp) {
        var _this = this;
        var replay = this.getReplay('jsonp', meta, false);
        var jobid = replay.id;
        var method = 'jsonp';
        setTimeout(function () {
            if (url.endsWith('/'))
                url = url.slice(0, url.length - 1);
            var num = Math.round(10000 * Math.random());
            var callbackMethodName = "cb_" + num;
            window[callbackMethodName] = function (data) {
                if (_this.checkCache({
                    url: url,
                    body: body,
                    isArray: isArray,
                    method: method
                }, jobid)) {
                    return;
                }
                _this.handlerResult({
                    res: {
                        data: data, isArray: isArray
                    },
                    method: method,
                    jobid: jobid,
                    isArray: isArray
                }, {
                    url: url,
                    body: body,
                    isArray: isArray,
                    method: method,
                });
            };
            var sc = document.createElement('script');
            sc.src = url + "?callback=" + callbackMethodName;
            document.body.appendChild(sc);
            document.body.removeChild(sc);
        });
        // return replay.subject.asObservable();
        var resp = replay.subject.asObservable().take(1).toPromise();
        resp.observable = replay.subject.asObservable();
        resp.cache = request_cache_1.RequestCache.findBy({
            body: body,
            isArray: isArray,
            method: method,
            url: url
        });
        return resp;
    };
    RestRequest.prototype.replay = function (method, meta) {
        var _this = this;
        var replay = this.getReplay(method, meta, true);
        if (!replay || !replay.data) {
            console.warn("Canno replay first " + method + " request from " + meta.endpoint + "/" + meta.path);
            return;
        }
        ;
        if (replay && replay.subject && Array.isArray(replay.subject.observers) &&
            replay.subject.observers.length === 0) {
            console.warn("No observators for " + method + " request from " + meta.endpoint + "/" + meta.path);
            return;
        }
        var url = replay.data.url;
        var headers = replay.data.headers;
        var body = replay.data.body;
        var isArray = replay.data.isArray;
        setTimeout(function () { return _this.req(url, method, headers, body, replay.id, isArray); });
    };
    RestRequest.jobId = 0;
    return RestRequest;
}());
exports.RestRequest = RestRequest;
//# sourceMappingURL=rest-request.js.map